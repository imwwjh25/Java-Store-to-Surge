### 一、为什么需要适配器模式？

先看一个典型痛点场景：

- 你有一个`PayPalPayment`类，提供`sendPayment(double amount)`方法完成支付；
- 你的系统期望统一调用`Payment`接口的`pay(double money)`方法；
- 由于接口方法名、参数（或逻辑）不匹配，无法直接使用`PayPalPayment`。

适配器模式可以封装`PayPalPayment`，对外暴露系统期望的`pay()`接口，让两者无缝对接。

### 二、适配器模式的核心结构

适配器模式包含 4 个核心角色：

1. **目标接口（Target）**：客户端期望的接口（如`Payment`），定义客户端需要的方法；
2. **适配者（Adaptee）**：现有但接口不兼容的类（如`PayPalPayment`），是需要被适配的对象；
3. **适配器（Adapter）**：实现目标接口，并封装适配者对象，完成接口转换；
4. **客户端（Client）**：只调用目标接口的方法，无需关注适配者的具体实现。

### 三、两种核心实现方式（代码示例）

#### 场景说明

模拟支付系统适配：系统期望调用`Payment`接口的`pay()`方法，需适配第三方支付（PayPal、Alipay）的不同接口。

##### 1. 目标接口（Target）









```
// 系统期望的统一支付接口（目标接口）
public interface Payment {
    // 统一支付方法：参数为支付金额
    void pay(double money);
}
```

##### 2. 适配者（Adaptee）








```
// 适配者1：PayPal支付（接口不兼容：方法名是sendPayment，参数名是amount）
public class PayPalPayment {
    public void sendPayment(double amount) {
        System.out.println("通过PayPal支付：" + amount + " 元");
    }
}

// 适配者2：支付宝支付（接口不兼容：方法名是aliPay，参数还需要订单号）
public class AlipayPayment {
    public void aliPay(double total, String orderId) {
        System.out.println("通过支付宝支付订单[" + orderId + "]：" + total + " 元");
    }
}
```

------

#### 方式 1：对象适配器（推荐，组合方式）

**核心思路**：适配器类实现目标接口，通过**组合**（持有适配者对象）的方式调用适配者的方法，是最常用的实现方式（符合 “合成复用原则”）。







```
// 适配器1：PayPal适配器（适配PayPalPayment到Payment接口）
public class PayPalAdapter implements Payment {
    // 组合：持有适配者对象
    private PayPalPayment payPalPayment;

    // 构造器注入适配者
    public PayPalAdapter(PayPalPayment payPalPayment) {
        this.payPalPayment = payPalPayment;
    }

    // 实现目标接口方法，内部调用适配者的方法（接口转换）
    @Override
    public void pay(double money) {
        // 转换参数/方法名，调用适配者的sendPayment
        payPalPayment.sendPayment(money);
    }
}

// 适配器2：支付宝适配器（适配AlipayPayment到Payment接口）
public class AlipayAdapter implements Payment {
    private AlipayPayment alipayPayment;
    // 支付宝需要订单号，适配器可默认填充或外部传入
    private String defaultOrderId;

    public AlipayAdapter(AlipayPayment alipayPayment, String defaultOrderId) {
        this.alipayPayment = alipayPayment;
        this.defaultOrderId = defaultOrderId;
    }

    @Override
    public void pay(double money) {
        // 转换接口：补充订单号参数，调用aliPay
        alipayPayment.aliPay(money, defaultOrderId);
    }
}

// 客户端使用示例
public class ObjectAdapterDemo {
    public static void main(String[] args) {
        // 1. 使用PayPal支付（通过适配器）
        Payment payPal = new PayPalAdapter(new PayPalPayment());
        payPal.pay(100.0); // 输出：通过PayPal支付：100.0 元

        // 2. 使用支付宝支付（通过适配器）
        Payment alipay = new AlipayAdapter(new AlipayPayment(), "ORDER_123456");
        alipay.pay(200.0); // 输出：通过支付宝支付订单[ORDER_123456]：200.0 元
    }
}
```

##### 方式 2：类适配器（继承方式，Java 中受限）

**核心思路**：适配器类同时继承适配者类、实现目标接口，通过继承直接调用适配者的方法。

> 注意：Java 不支持多继承，因此类适配器只能适配**一个**适配者类，灵活性差，实际很少使用。











```
// 类适配器：继承PayPalPayment，实现Payment接口
public class PayPalClassAdapter extends PayPalPayment implements Payment {
    @Override
    public void pay(double money) {
        // 直接调用父类（适配者）的sendPayment方法
        super.sendPayment(money);
    }
}

// 客户端使用
public class ClassAdapterDemo {
    public static void main(String[] args) {
        Payment payPal = new PayPalClassAdapter();
        payPal.pay(150.0); // 输出：通过PayPal支付：150.0 元
    }
}
```

### 四、适配器模式的扩展：缺省适配器（Default Adapter）

这是适配器模式的变体，适用于目标接口方法过多，但客户端只需要使用其中少数方法的场景。

核心思路：创建一个抽象类实现目标接口，为空方法提供默认实现（空方法），客户端只需继承该抽象类，重写需要的方法即可。










```
// 复杂的目标接口（多个方法）
public interface FullPayment {
    void pay(double money);
    void refund(double money);
    void queryStatus(String orderId);
    void cancel(String orderId);
}

// 缺省适配器：实现所有方法，提供空实现
public abstract class DefaultPaymentAdapter implements FullPayment {
    @Override
    public void pay(double money) {}

    @Override
    public void refund(double money) {}

    @Override
    public void queryStatus(String orderId) {}

    @Override
    public void cancel(String orderId) {}
}

// 客户端：只需重写需要的方法
public class SimplePayAdapter extends DefaultPaymentAdapter {
    @Override
    public void pay(double money) {
        System.out.println("简化版支付：" + money + " 元");
    }
}

// 使用示例
public class DefaultAdapterDemo {
    public static void main(String[] args) {
        FullPayment payment = new SimplePayAdapter();
        payment.pay(300.0); // 输出：简化版支付：300.0 元
        // 其他方法无需实现，调用也不会报错
        payment.queryStatus("ORDER_789"); // 无输出
    }
}
```

### 五、适配器模式的核心特点

#### 优点：

1. **兼容性强**：无需修改原有代码，即可让接口不兼容的类协同工作（符合 “开闭原则”）；
2. **解耦性高**：将客户端与适配者解耦，客户端只需面向目标接口编程；
3. **复用性好**：可以复用现有适配者类，无需为了适配重新开发；
4. **灵活性高**：对象适配器可适配多个适配者（通过组合多个对象），类适配器虽受限但实现更简单。

#### 缺点：

1. **增加复杂度**：引入适配器会增加类的数量，代码层级变多；
2. **性能损耗**：适配器会增加一次方法调用的开销（可忽略，除非高频调用）；
3. **类适配器限制**：Java 中无法适配多个类，灵活性远低于对象适配器。

### 六、适配器模式 vs 装饰器模式（易混淆的区别）

很多新手会混淆两者，核心差异在于目标不同：






|    维度    |             适配器模式             |             装饰器模式             |
| :--------: | :--------------------------------: | :--------------------------------: |
|  核心目标  | 解决**接口不兼容**问题（转换接口） |    增强**原有功能**（扩展功能）    |
|  接口关系  |      适配者和目标接口**不同**      |  装饰器和被装饰者**实现同一接口**  |
| 客户端感知 | 客户端只知道目标接口，不知道适配者 | 客户端知道被装饰者，明确要扩展功能 |
|    示例    |      电源适配器、支付接口适配      |     给字符串添加加密、日志增强     |

### 总结

1. **核心思想**：适配器模式通过 “接口转换” 解决不兼容问题，核心是 “适配” 而非 “扩展”；

2. 选型建议 ：

    - 优先使用**对象适配器**（组合方式），灵活性高、符合合成复用原则；
    - 接口方法过多时，使用**缺省适配器**简化开发；
    - 避免使用类适配器（Java 中多继承限制）；



3. 适用场景 ：

    - 集成第三方库 / 接口，但其接口与系统接口不匹配；
    - 复用现有类，但接口不符合当前需求；
    - 统一多个相似类的接口，简化客户端调用；



4. **关键原则**：适配器模式是 “亡羊补牢” 的模式，适合后期扩展兼容，而非前期设计优先选择。