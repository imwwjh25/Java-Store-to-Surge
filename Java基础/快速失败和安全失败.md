在 Java 集合框架中，**安全失败（Fail-Safe）** 和 **快速失败（Fail-Fast）** 是两种针对「集合遍历期间并发修改」的错误检测机制，核心差异在于「是否允许遍历期间修改集合」以及「如何处理并发修改」，本质是「数据一致性」与「遍历可用性」的权衡。

### 一、核心定义与本质区别



| 机制                  | 核心定义                                                     | 本质逻辑                                                     |
| --------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 快速失败（Fail-Fast） | 遍历集合时，若其他线程（或当前线程）修改了集合的「结构」，立即抛出 `ConcurrentModificationException` 异常，终止遍历。 | 优先保证「数据一致性」：不允许遍历期间结构变更，一旦检测到变更，快速报错，避免遍历到脏数据。 |
| 安全失败（Fail-Safe） | 遍历集合时，允许其他线程修改集合结构；遍历的是集合的「副本」，而非原集合，因此不会抛出异常。 | 优先保证「遍历可用性」：牺牲数据一致性，允许遍历期间原集合变更，但遍历结果可能不是最新的。 |

注：「结构修改」指改变集合大小的操作（如 `add`、`remove`、`clear`），仅修改元素内容（如 `set` 替换元素值）不算结构修改，不会触发两种机制。

### 二、快速失败（Fail-Fast）详解



#### 1. 实现原理：modCount 计数器



- 核心变量：所有支持快速失败的集合（如 `ArrayList`、`HashMap`、`HashSet`）内部都有一个 `modCount` 变量，用于记录集合的「结构修改次数」（每次 `add`/`remove`/`clear` 都会让 `modCount++`）；

- 遍历检测：当通过集合的「迭代器（Iterator）」或「增强 for 循环（本质也是迭代器）」遍历集合时，迭代器会在每次迭代（```next()```方法）时，检查当前集合的```modCount```是否与迭代器创建时记录的```expectedModCount```相等；
- 相等：继续遍历；
- 不相等：说明遍历期间集合结构被修改，立即抛出 `ConcurrentModificationException`。

#### 2. 代码示例（以 ArrayList 为例）


```
List<String> list = new ArrayList<>(Arrays.asList("A", "B", "C"));

// 增强 for 循环（迭代器遍历）
for (String s : list) {
    if (s.equals("B")) {
        list.remove(s); // 遍历期间修改集合结构，触发快速失败
    }
}
// 运行结果：抛出 ConcurrentModificationException
```



#### 3. 关键细节



- 「当前线程修改」也会触发：即使是遍历的线程自己修改集合结构（如上例），也会抛出异常；
- 仅迭代器遍历触发：直接通过「索引遍历」（如 `for (int i=0; i<list.size(); i++)`）不会触发快速失败（因为不经过迭代器的 `modCount` 检测），但可能导致遍历越界或数据错乱；
- 非线程安全：支持快速失败的集合（`ArrayList`、`HashMap` 等）本身是非线程安全的，快速失败只是「错误检测机制」，不是「线程安全保障」—— 多线程环境下仍需手动加锁（如 `synchronized`）或使用线程安全集合。

#### 4. 适用场景



单线程环境下，或多线程环境已手动保证线程安全时，用于快速发现非法的并发修改，避免遍历脏数据（如业务不允许遍历期间修改集合）。

### 三、安全失败（Fail-Safe）详解



#### 1. 实现原理：遍历副本



- 核心逻辑：支持安全失败的集合（如 `CopyOnWriteArrayList`、`CopyOnWriteArraySet`、`ConcurrentHashMap`），在创建迭代器时，会先复制一份原集合的「快照（副本）」，迭代器遍历的是这份副本，而非原集合；
- 修改不影响遍历：遍历期间，其他线程对原集合的 `add`/`remove` 等结构修改，只会作用于原集合，不会影响副本 —— 因此迭代器不会检测到修改，也不会抛出异常；
- 副本特性：副本是「只读」的，迭代器的 `remove()` 方法会直接抛出 `UnsupportedOperationException`（不支持在遍历期间通过迭代器修改副本）。

#### 2. 代码示例（以 CopyOnWriteArrayList 为例）


```
List<String> list = new CopyOnWriteArrayList<>(Arrays.asList("A", "B", "C"));

// 遍历期间其他线程修改原集合
new Thread(() -> {
    try {
        Thread.sleep(100);
        list.remove("B"); // 修改原集合，不影响遍历的副本
        System.out.println("原集合修改后：" + list); // 输出 [A, C]
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
}).start();

// 遍历副本，不会抛出异常
for (String s : list) {
    System.out.println("遍历到：" + s); // 输出 A、B、C（副本内容，不受原集合修改影响）
    Thread.sleep(200);
}
```



#### 3. 关键细节



- 数据一致性问题：遍历的是「快照」，可能存在「数据滞后」—— 遍历结果可能不是原集合的最新状态（如上例，原集合已删除 B，但遍历仍能拿到 B）；
- 性能开销：复制副本需要消耗额外的内存（原集合越大，开销越高），且 `add`/`remove` 操作会触发副本创建（`CopyOnWrite` 机制：写时复制），导致写操作效率较低；
- 线程安全：支持安全失败的集合本身是「线程安全」的（如 `CopyOnWriteArrayList` 内部通过 `ReentrantLock` 保证写操作原子性），无需手动加锁。

#### 4. 适用场景



多线程环境下，遍历操作远多于写操作（如读多写少），且能容忍遍历结果不是最新的场景（如日志查询、配置读取）。

### 四、核心对比表



| 对比维度              | 快速失败（Fail-Fast）                        | 安全失败（Fail-Safe）                                  |
| --------------------- | -------------------------------------------- | ------------------------------------------------------ |
| 触发条件              | 遍历期间修改集合结构（add/remove/clear）     | 遍历期间修改原集合结构（不影响副本）                   |
| 异常抛出              | 立即抛出 `ConcurrentModificationException`   | 不抛出异常                                             |
| 遍历对象              | 原集合                                       | 原集合的快照（副本）                                   |
| 数据一致性            | 高（不允许遍历脏数据）                       | 低（遍历快照，可能滞后）                               |
| 线程安全性            | 非线程安全（需手动加锁）                     | 线程安全（集合自身保证）                               |
| 性能开销              | 低（无副本复制）                             | 高（写操作触发副本复制，消耗内存和时间）               |
| 支持的集合            | ArrayList、HashMap、HashSet 等非线程安全集合 | CopyOnWriteArrayList、ConcurrentHashMap 等线程安全集合 |
| 迭代器 remove () 支持 | 支持（需在迭代器中调用，而非集合直接调用）   | 不支持（抛出 `UnsupportedOperationException`）         |

### 五、常见误区澄清



1. 「快速失败 = 线程安全」？错误。快速失败只是「并发修改检测机制」，非线程安全集合（如 `ArrayList`）即使触发快速失败，也不能保证多线程操作的原子性（如两个线程同时 `add` 可能导致元素覆盖）。

2. 「安全失败 = 数据最新」？错误。安全失败遍历的是副本，原集合修改后，遍历结果不会同步更新，可能拿到旧数据。

3. 「迭代器遍历一定触发快速失败」？错误。仅非线程安全集合的迭代器会触发，且若遍历期间通过「迭代器的 `remove()` 方法」修改集合（而非集合自身的 `remove()`），不会触发快速失败（因为迭代器会同步 `expectedModCount` 与 `modCount`）：


   ```
   List<String> list = new ArrayList<>(Arrays.asList("A", "B", "C"));
   Iterator<String> it = list.iterator();
   while (it.hasNext()) {
       String s = it.next();
       if (s.equals("B")) {
           it.remove(); // 迭代器的 remove()，不会触发快速失败
       }
   }
   ```



### 总结



- 快速失败：「先检测，后遍历」，优先保证数据一致性，适合单线程或读少写少、不允许并发修改的场景；
- 安全失败：「先复制，后遍历」，优先保证遍历可用性，适合多线程读多写少、能容忍数据滞后的场景；
- 核心选择依据：是否需要线程安全、是否容忍脏数据、读写比例。