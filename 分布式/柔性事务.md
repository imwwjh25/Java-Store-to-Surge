柔性事务是分布式系统中为解决 “刚性事务（如 ACID）在跨服务场景下难以落地” 而设计的事务模型，核心是**在 “一致性” 和 “可用性、性能” 之间做权衡**—— 不追求强一致性（数据实时完全一致），而是通过 “最终一致性” 或 “部分一致性” 满足业务需求，同时保证服务高可用和低延迟。

### 一、先明确：为什么需要柔性事务？（刚性事务的困境）

在单体应用中，数据库的 ACID 事务（刚性事务）能保证数据一致性，但分布式场景下（如微服务跨多个数据库 / 服务调用），刚性事务会面临两大核心问题：

1. **性能与可用性瓶颈**：刚性事务依赖 “分布式锁”“两阶段提交（2PC）” 等机制，会导致服务间强耦合、长时间阻塞（如 2PC 的准备阶段锁定资源），一旦某个服务超时 / 故障，整个事务会失败，可用性极低。
2. **跨服务数据难统一**：分布式场景下数据存储在多个节点（如订单服务存订单库、支付服务存支付库），无法通过单库 ACID 保证跨节点数据一致，刚性事务的 “原子性” 难以实现。

柔性事务的本质是 “放弃强一致性，拥抱业务可接受的最终一致性”，通过更灵活的设计适配分布式环境。

### 二、柔性事务的核心特性（与刚性事务的区别）

| 特性     | 刚性事务（ACID）                       | 柔性事务（最终一致性）                       |
| -------- | -------------------------------------- | -------------------------------------------- |
| 一致性   | 强一致性（事务结束后数据实时一致）     | 最终一致性（允许短暂不一致，最终会修复）     |
| 可用性   | 低（依赖强锁和阻塞，易故障）           | 高（无强阻塞，服务独立容错）                 |
| 性能     | 低（锁竞争、网络通信开销大）           | 高（无锁或弱锁，异步化处理）                 |
| 适用场景 | 单体应用、核心强一致场景（如银行转账） | 分布式微服务、高并发场景（如电商订单、秒杀） |

### 三、柔性事务的典型实现方案（核心是 “如何保证最终一致”）

柔性事务通过不同的 “补偿机制” 或 “协议” 实现最终一致性，常见方案有 4 种，分别适配不同业务场景：

#### 1. 两阶段提交（2PC）的改进：TCC（Try-Confirm-Cancel）

- **核心思想**：将分布式事务拆分为 “Try（尝试）、Confirm（确认）、Cancel（取消）” 三个阶段，由业务代码主动实现 “确认” 和 “取消” 的补偿逻辑，避免刚性 2PC 的阻塞问题。

- 执行流程 ：

    1. **Try 阶段**：预留资源（不实际提交），如订单服务冻结库存、支付服务预扣余额（但不真正扣减）；
    2. **Confirm 阶段**：所有服务 Try 成功后，执行实际提交（如扣减库存、确认支付），该阶段是幂等的（重复执行不影响结果）；
    3. **Cancel 阶段**：若任一服务 Try 失败，执行回滚（如释放冻结的库存、恢复预扣的余额），同样保证幂等。

- **适用场景**：核心业务场景（如电商下单扣库存 + 支付），需要强业务一致性，且能接受开发成本（需手写 Confirm/Cancel 逻辑）。

#### 2. 异步化补偿：Saga 模式

- **核心思想**：将分布式事务拆分为 “多个本地事务步骤”，每个步骤执行后记录 “补偿操作”；若某个步骤失败，反向执行前面所有步骤的补偿操作，通过异步方式保证最终一致。

- 执行流程 ：

    1. 事务拆分为步骤：`T1（订单创建）→ T2（库存扣减）→ T3（支付确认）`；
    2. 每个步骤对应补偿操作：`C1（取消订单）→ C2（恢复库存）→ C3（退款）`；
    3. 正常执行：T1→T2→T3，全部成功则事务完成；
    4. 失败回滚：若 T3 失败，先执行 C2（恢复库存），再执行 C1（取消订单），最终所有数据回滚到初始状态。

- **适用场景**：长事务场景（如跨多个服务的流程化操作，如用户注册→开通会员→发送短信），且步骤间可异步执行，对实时性要求不高。

#### 3. 基于消息的最终一致：本地消息表（Local Message Table）

- **核心思想**：通过 “本地事务 + 消息队列” 实现跨服务异步通信，将 “业务操作” 和 “发送消息” 放在同一个本地事务中，保证 “业务执行成功则消息必发”，再通过消息队列触发下游服务，最终实现一致。

- 执行流程 （以 “订单创建→通知物流” 为例）：

    1. 订单服务在本地数据库中创建 “订单表” 和 “本地消息表”；
    2. 执行本地事务：同时 “创建订单” 和 “插入‘通知物流’的消息记录”（同一事务，要么都成功，要么都失败）；
    3. 启动定时任务，扫描本地消息表中 “未发送” 的消息，发送到消息队列；
    4. 物流服务消费消息，执行 “创建物流单” 的本地事务；若消费失败，消息队列重试，直到成功。

- **适用场景**：异步通知场景（如订单创建后通知物流、支付成功后通知积分服务），对实时性要求低，开发成本低（无需手写复杂补偿逻辑）。

#### 4. 基于可靠消息的事务：事务消息（RocketMQ/Kafka 支持）

- **核心思想**：是 “本地消息表” 的优化版，由消息中间件（如 RocketMQ）原生支持 “事务消息”，简化本地消息表的开发，本质仍是 “本地事务 + 消息异步投递”。

- 执行流程 ：

    1. 订单服务向 RocketMQ 发送 “半事务消息”（消息已存储，但未对下游可见）；
    2. RocketMQ 确认收到半事务消息后，订单服务执行 “创建订单” 的本地事务；
    3. 若本地事务成功，订单服务通知 RocketMQ “提交消息”，下游物流服务可消费消息；若本地事务失败，通知 RocketMQ “回滚消息”，消息被删除，下游无感知；
    4. 若 RocketMQ 长时间未收到确认，会主动回查订单服务的事务状态，自动完成提交 / 回滚。

- **适用场景**：依赖消息中间件的异步场景（如电商、社交），开发成本比本地消息表低，且中间件保证消息可靠性。

### 四、柔性事务的关键设计原则

无论哪种实现方案，柔性事务都需遵守 3 个核心原则，否则会导致最终一致性失效：

1. **幂等性**：所有操作（如 Confirm、Cancel、消息消费）必须支持重复执行（如通过订单 ID 去重），避免重复执行导致数据错误（如重复扣减库存）；
2. **可补偿性**：每个业务操作必须有对应的 “回滚补偿操作”（如扣库存对应恢复库存，支付对应退款），且补偿操作需保证正确性；
3. **异步化与重试**：尽量通过异步方式（如消息队列）触发下游操作，同时支持失败重试（设置合理的重试次数和间隔），确保最终能执行成功。

### 总结

柔性事务不是 “弱化的事务”，而是**分布式环境下对 “一致性” 和 “可用性” 的最优权衡**—— 通过放弃强一致性，换取服务的高可用和高性能，同时通过 “补偿”“异步”“重试” 等机制保证业务可接受的最终一致性。在微服务架构中，柔性事务是解决跨服务数据一致性的核心方案，实际选型需结合业务场景（如实时性、开发成本、一致性要求）选择 TCC、Saga、本地消息表或事务消息。