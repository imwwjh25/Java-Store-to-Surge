你的记忆方向完全正确！MySQL 的行锁（仅 InnoDB 支持，MyISAM 无行锁）核心就是通过 **`lock_sys` 锁系统 + 哈希表 + 页内 Bitmap** 实现的，只是有几个关键细节可以帮你补全，让逻辑更完整。下面用「通俗拆解 + 核心结构 + 流程步骤」的方式，把行锁实现讲清楚，方便你理解和记忆：

## 一、先明确：行锁是 InnoDB 的 “专利”，依赖索引

首先要记住前提：**InnoDB 的行锁是 “基于索引” 实现的**—— 如果查询没有走索引（全表扫描），InnoDB 会直接退化成「表锁」（因为无法精准定位到具体行）。这是行锁实现的基础，后面会解释为什么依赖索引。

## 二、行锁实现的核心结构（对应你的记忆点）

你提到的 `lock_sys` 是 InnoDB 锁系统的核心管理模块，里面最关键的就是「哈希表 + 页级锁结构 + Bitmap 行标记」，三者协同实现行锁的存储和查询：

### 1. 核心管理结构：lock_sys

`lock_sys` 是 InnoDB 全局的锁管理对象，里面包含一个关键的哈希表 `lock_hashtable`，作用是「快速查找某个数据页上的锁信息」。

### 2. 哈希表的 Key 和 Value

- Key（哈希键）：不是单纯的「页号」，而是「表空间 ID + 数据页号」的组合（```space_id + page_no```）。

  原因：不同表空间（如不同数据库、不同表）可能有相同的页号，组合后才能唯一标识一个数据页。

- Value（哈希值）：是一个「锁记录链表」（```lock_rec_t```结构体组成的链表），每个 ```lock_rec_t```
  
  对应一个「数据页的锁信息」，里面包含：

  - 锁的类型（共享锁 S / 排他锁 X）；
  - 锁的模式（意向锁、记录锁、间隙锁等）；
  - 持有锁的事务 ID；
  - 关键：**页内被锁行的 Bitmap（位图）**。

### 3. 行锁的最终标记：Bitmap（位图）

这就是你记住的核心点！InnoDB 会为每个被锁的「数据页」维护一个 Bitmap，用于标记该页内哪些行被锁定：

- 数据页内的每行记录，对应 Bitmap 中的一个「bit 位」（比如第 1 行对应 bit 0，第 2 行对应 bit 1...）；
- bit 位为 `1` 表示该行被锁定，为 `0` 表示未锁定；
- 优势：Bitmap 占用内存极少（一个 16KB 的数据页最多存 200 多行，一个 32 位整数的 Bitmap 就能覆盖，高效！）。

## 三、行锁的完整实现流程（获取 + 释放）

结合上面的结构，我们以「事务 A 更新某行数据（加排他锁 X）」为例，拆解行锁的实现步骤，帮你串起整个逻辑：

### 步骤 1：定位数据页（依赖索引）

事务 A 执行 `UPDATE user SET name='xxx' WHERE id=10`（id 是主键索引）：

- InnoDB 先通过主键索引，找到 `id=10` 对应的「数据页」（确定 `space_id=1`、`page_no=5`，假设表空间 ID 是 1，数据页号是 5）；
- 若没有索引，InnoDB 无法定位到具体页和行，只能对整个表的所有数据页加锁（退化成表锁）。

### 步骤 2：查询锁哈希表，判断是否已有锁结构

InnoDB 计算 `space_id=1 + page_no=5` 的哈希值，去 `lock_sys` 的 `lock_hashtable` 中查找：

- 若该数据页没有锁结构（首次加锁）：创建一个 `lock_rec_t` 结构体（包含锁类型 X、事务 A 的 ID、空 Bitmap），存入哈希表；
- 若该数据页已有锁结构（其他事务已锁该页的其他行）：直接复用已有的 `lock_rec_t` 结构体。

### 步骤 3：用 Bitmap 标记被锁的行

InnoDB 确定 `id=10` 在数据页内的「行号」（比如是第 3 行），然后：

- 在 `lock_rec_t` 的 Bitmap 中，将第 3 行对应的 bit 位设为 `1`（标记该行被锁）；
- 若其他事务要锁该页的第 5 行，则将 Bitmap 的第 5 位设为 `1`，同一个 `lock_rec_t` 可以管理页内多行的锁。

### 步骤 4：锁冲突检查

当另一个事务 B 要锁同一行（`id=10`）时：

- 同样定位到 `space_id=1 + page_no=5`，查到 `lock_rec_t`；
- 检查 Bitmap 中第 3 行的 bit 位（已为 1），再判断锁类型（事务 A 是 X 锁，事务 B 若要加 X 锁则冲突，加 S 锁也冲突）；
- 冲突时，事务 B 进入等待队列（挂在 `lock_rec_t` 的等待链表中）。

### 步骤 5：释放锁

事务 A 提交或回滚时：

- 找到 `space_id=1 + page_no=5` 对应的 `lock_rec_t`；
- 将 Bitmap 中第 3 行的 bit 位设为 `0`（取消该行锁定）；
- 若该 `lock_rec_t` 的 Bitmap 中所有 bit 位都是 `0`（该页没有任何行被锁），则将 `lock_rec_t` 从哈希表中删除，释放内存。

## 四、补充：你可能忽略的 2 个关键细节

### 1. 行锁为什么依赖索引？

因为索引的作用是「快速定位到数据所在的页和行」：

- 有索引时，InnoDB 能通过索引直接找到目标行的「表空间 ID + 页号 + 行号」，精准加锁；
- 无索引时，InnoDB 只能全表扫描，无法确定要锁的行，只能对全表所有数据页加锁（退化成表锁）。

### 2. 锁的粒度：行锁是 “页级管理，行级标记”

InnoDB 不会为每一行单独创建锁结构（那样内存开销太大），而是「按数据页分组管理锁」：

- 一个数据页的所有行锁，都存在同一个 `lock_rec_t` 中；
- 通过 Bitmap 标记具体哪行被锁，既节省内存，又能快速查询锁状态。

## 总结（帮你巩固记忆）

MySQL InnoDB 行锁的实现核心可以简化为：「**lock_sys 全局管理 → 哈希表（key：表空间 ID + 页号）→ 页级锁结构（lock_rec_t）→ Bitmap 标记页内被锁行**」

你之前记住的 “哈希保存在 lock_sys”“key 由页号计算”“bitmap 存被锁行” 完全正确，补充「表空间 ID + 页号」作为 key、「依赖索引定位」这两个细节后，整个实现逻辑就完整了。

面试时这么说：“InnoDB 的行锁依赖索引实现，核心通过 lock_sys 锁系统管理：lock_sys 里有个哈希表，key 是表空间 ID + 页号，value 是该数据页的锁结构（lock_rec_t），锁结构里用 Bitmap 标记页内被锁的行（1 表示被锁，0 未锁）。获取行锁时，先通过索引定位到数据页，再查哈希表找到锁结构，用 Bitmap 标记对应行；释放时重置 Bitmap 即可。没有索引的话会退化成表锁。”
