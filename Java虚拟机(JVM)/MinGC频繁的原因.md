MinGC（Minor GC）频繁触发的核心原因是**新生代内存供需失衡**—— 要么 “内存空间不足”，要么 “对象创建速度过快 / 存活对象过多”，具体可归纳为以下 4 类：

### 1. 新生代内存配置过小（最直接原因）

新生代（通过 `-Xmn` 配置）总空间不足以容纳业务创建的短期对象，导致刚分配部分对象就触发 “Allocation Failure”（分配失败），被迫执行 MinGC 释放空间。



- 示例：JVM 堆总大小 2GB，但新生代仅配置 256MB，而业务每秒创建 100MB 临时对象（如请求参数、中间计算结果），2-3 秒就会占满新生代，触发 MinGC。

### 2. 业务代码频繁创建大量短期对象

业务逻辑中存在 “高频创建临时对象” 的场景，对象生成速度超过 MinGC 的回收速度，导致新生代持续处于高占用状态。



- 典型场景：
    - 循环中重复创建对象（如循环内 new String、new List，未复用）；
    - 高频接口（如每秒万级请求）每次请求都创建大量中间对象（如 JSON 序列化 / 反序列化生成的临时对象）；
    - 未关闭的流 / 连接（如 IO 流、数据库连接），虽属于短期对象，但资源未释放导致对象无法回收，间接占用新生代空间。

### 3. 新生代对象存活时间过长，无法有效回收

正常 MinGC 会回收大部分短期对象（如请求结束后就无用的对象），但若存在 “本应短期存活却长期存活” 的对象，会导致 MinGC 后新生代剩余空间仍很高，很快再次占满。



- 典型场景：
    - 静态集合（如 `static List`）缓存过多临时数据（如缓存请求日志、中间计算结果），对象被静态引用持有，无法被 MinGC 回收；
    - 线程池核心线程持有对象（如线程局部变量 `ThreadLocal` 未及时清理，线程不销毁则对象长期存活）。

### 4. 对象提前晋升老年代，导致新生代可用空间被挤压

新生代对象未达到 “晋升阈值”（通过 `-XX:MaxTenuringThreshold` 配置，默认 15），却因特殊原因提前进入老年代，导致新生代可分配空间减少，间接引发 MinGC 频繁。



- 常见触发提前晋升的场景：
    - 新生代 Survivor 区空间不足：对象在 Eden 区 GC 后存活，转移到 Survivor 区时，Survivor 区剩余空间不足以容纳，触发 “晋升担保”，直接进入老年代；
    - 大对象直接入老年代：超过 `XX:PretenureSizeThreshold`（默认无值，取决于 JVM）的大对象（如几 MB 的数组、大 JSON 对象），会跳过新生代直接进入老年代，但如果配置了该参数且阈值过小，会导致较多对象提前晋升，挤压新生代空间。
