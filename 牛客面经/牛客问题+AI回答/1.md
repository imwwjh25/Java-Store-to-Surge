## [字节-后端搜索-更新：hr面已过，等排序](https://www.nowcoder.com/feed/main/detail/92b8d99a909a4d83acd3f41e51d1741b?sourceSSR=users)

## 回答

### 1. Java 为什么学习成本更低？



核心原因是**设计简洁、生态成熟、工程化规范明确**：

- 语法贴近自然语言，面向对象思想直观，无 Python 的动态类型歧义、无 C++ 的指针 / 内存管理复杂度；
- 生态完善（Spring、Maven 等），开发流程标准化，问题解决方案集中（Stack Overflow 资源多）；
- 强类型语言，编译期报错提前暴露问题，减少运行时排错成本；
- 企业级应用场景占比高，学习路径清晰（基础→框架→分布式），无技术选型混乱。

### 2. Python 和 Java 的核心区别



| 维度     | Python                          | Java                               |
| -------- | ------------------------------- | ---------------------------------- |
| 类型系统 | 动态类型（无需声明变量类型）    | 静态类型（强制声明变量类型）       |
| 执行效率 | 解释型（速度慢，依赖 JIT 优化） | 编译型（字节码运行在 JVM，速度快） |
| 应用场景 | 数据分析、AI、脚本、爬虫        | 后端开发、安卓、企业级系统         |
| 并发模型 | GIL 锁限制（单线程并发）        | 无 GIL，支持多线程 / 多进程 / 协程 |
| 工程化   | 灵活但规范弱，大型项目维护难    | 强规范（类、包结构），适合大型项目 |
| 语法风格 | 简洁（缩进代替大括号）          | 严谨（结构清晰，代码可读性强）     |

### 3. Redis 和 MySQL 是怎么配合的？



核心是**Redis 作为缓存加速读操作，MySQL 作为持久化存储保证数据可靠性**，经典流程：

1. **读流程**：先查 Redis → 命中则直接返回；未命中则查 MySQL → 结果写入 Redis → 返回给用户（下次读直接命中缓存）；
2. **写流程**：先更新 MySQL（保证数据持久化） → 再删除 Redis 缓存（避免缓存与数据库不一致）；
3. 适用场景：高频读、低频写（如商品详情、用户信息），Redis 缓存热点数据减轻 MySQL 压力。

### 4. 为什么先更新 MySQL 再删除缓存？



为了**避免数据不一致**，反例验证：

- 若先删缓存再更 MySQL：线程 A 删缓存后，线程 B 查询数据（缓存未命中）→ 查 MySQL（旧数据）→ 写入缓存，此时线程 A 才更新 MySQL，导致缓存存旧数据、数据库存新数据，一致性破坏；
- 先更 MySQL 再删缓存：即使更新 MySQL 后删除缓存失败，后续读请求会查 MySQL 新数据并更新缓存，最终数据一致（仅短期可能读旧缓存，风险更低）。

### 5. 为什么是删除缓存而不是更新？



核心是**避免缓存更新成本高、一致性难保证**：

1. 缓存可能是 “计算后结果”（如统计用户订单数），更新缓存需重复计算，效率低；
2. 分布式场景下，多线程同时更新缓存会导致 “覆盖冲突”（如线程 A、B 同时更新缓存，后写的覆盖先写的，可能丢失中间状态）；
3. 删除缓存是 “懒加载” 思想：下次读请求再从数据库加载最新数据到缓存，简单且可靠。

### 6. 两个线程更新缓存会出现缓存一致性问题吗？



**会，典型场景是 “缓存覆盖冲突”**：

- 场景：线程 1 和线程 2 同时更新同一条数据，流程如下：
    1. 线程 1 查 MySQL（旧数据）→ 计算新值（耗时）；
    2. 线程 2 查 MySQL（旧数据）→ 计算新值（更快完成）→ 写入缓存（新值 V2）；
    3. 线程 1 完成计算 → 写入缓存（新值 V1）；
- 结果：缓存最终是 V1（线程 1 的旧计算结果），数据库是 V2（线程 2 的正确结果），数据不一致；
- 本质：缓存更新无原子性，多线程并发写缓存导致 “后写覆盖先写”，破坏一致性。

### 7. 如果缓存删除失败，会出现什么问题？



核心问题是**缓存与数据库数据不一致**，具体影响：

- 短期：后续读请求会命中缓存的旧数据，返回错误结果（如商品库存已更新，但缓存还是旧库存）；
- 长期：若缓存无过期时间，旧数据会一直存在，直到下次主动更新 / 删除，不一致状态持续；
- 业务风险：如电商场景可能导致超卖、对账错误，金融场景可能导致金额计算异常。

### 8. 先更新 MySQL，再删除 Redis 数据，Redis 删除失败的后果？



与 “缓存删除失败” 本质一致，但场景更具体：

- 直接后果：Redis 缓存保留旧数据，数据库是新数据，读请求优先读 Redis，返回旧值（数据不一致）；
- 间接后果：若业务依赖缓存的实时性（如库存、价格），会导致用户看到错误信息，甚至业务损失（如超卖、低价下单）；
- 补救：需通过 “重试删除”“延迟双删”“缓存过期时间” 等机制兜底，避免长期不一致。

### 9. 延迟双删策略，靠什么实现的？



延迟双删是解决 “缓存删除失败”“并发更新一致性” 的方案，核心靠 **“两次删除缓存 + 中间延迟”** 实现，本质是：

- 流程：更新 MySQL → 第一次删除 Redis 缓存 → 延迟 N 秒 → 第二次删除 Redis 缓存；
- 核心逻辑：第一次删除缓存可能失败，延迟 N 秒是为了等待 “可能正在读取旧数据的线程” 完成（如线程 B 在第一次删除后、MySQL 更新前查了旧数据，延迟 N 秒让它写入缓存后，再第二次删除，避免旧数据残留）；
- 依赖：延迟机制（如定时任务、消息队列）、缓存操作的幂等性（多次删除同一 key 无副作用）。

### 10. 延迟双删的延迟如何实现？



延迟 N 秒的核心是 “等待并发读线程完成数据写入缓存”，实现方式有 3 种：

1. **线程睡眠**：简单场景用`Thread.sleep(N)`（如 Java），但阻塞线程，不适合高并发；
2. **定时任务**：用 Spring Scheduler、Quartz 等框架，将第二次删除操作作为定时任务提交（延迟 N 秒执行）；
3. **消息队列**：更新 MySQL 后，向 MQ（如 RabbitMQ、RocketMQ）发送延迟消息，消费者接收消息后执行第二次删除（推荐，解耦且支持高并发）；

- 延迟时间 N：通常取 “业务峰值下的平均读请求耗时 + 缓存写入耗时”，一般 1-5 秒（需压测调整）。

### 11. Redis 实现消息队列有什么缺点？



Redis 的 List/Stream/PubSub 可实现消息队列，但适合简单场景，缺点明显：

1. **无严格的消息可靠性保障**：Redis 宕机未持久化（如 RDB 未触发、AOF 未同步），消息会丢失；
2. **缺乏消息确认机制**：List 弹出消息（LPOP）后若消费者崩溃，消息无法恢复（Stream 支持 ACK，但功能弱于专业 MQ）；
3. **不支持复杂路由**：无专业 MQ 的交换机（Exchange）、绑定键（BindingKey）等路由功能，仅支持简单的生产者 - 消费者模式；
4. **并发性能有限**：高并发下（如每秒 10 万 + 消息），Redis 的单线程模型会成为瓶颈；
5. **无死信队列**：处理失败的消息无法重试或归档，需手动实现。

### 12. Redis 为什么使用 Lua 脚本？



核心目的是**保证多个 Redis 命令的原子性执行**，解决并发问题，其他优势：

1. **原子性**：Redis 执行 Lua 脚本时，会阻塞其他命令（单线程模型），确保脚本内的命令要么全部执行，要么全部不执行（避免并发下的中间状态）；
2. **减少网络开销**：将多个 Redis 命令（如查询 + 计算 + 写入）打包成一个 Lua 脚本，一次网络请求完成，降低延迟；
3. **复杂逻辑实现**：支持条件判断、循环等逻辑（如库存扣减时判断是否足够），Redis 原生命令无法实现；
4. **复用性**：Lua 脚本可存储在 Redis 中，通过脚本 ID 调用，避免重复编写。

### 13. 优惠券超卖问题的解决方案？



超卖本质是 “并发下库存扣减不一致”，核心思路是 “保证库存操作的原子性”，方案从简单到复杂：

1. **数据库乐观锁**：库存字段加版本号（如`version`），扣减时判断版本号：`UPDATE coupon SET stock=stock-1, version=version+1 WHERE id=? AND stock>0 AND version=?`，失败则重试；
2. **数据库悲观锁**：扣减库存时加行锁（`SELECT ... FOR UPDATE`），阻塞其他线程，适合低并发场景（高并发会导致锁竞争严重）；
3. **Redis 预扣减 + 原子操作**：将库存缓存到 Redis，用 Lua 脚本原子扣减（`if redis.call('get', 'coupon_stock') > 0 then return redis.call('decr', 'coupon_stock') else return -1 end`），再异步同步到数据库（最终一致性）；
4. **分布式锁**：用 Redis Redlock、ZooKeeper 等实现分布式锁，同一时间仅一个线程能扣减库存，适合高并发场景；
5. **MQ 削峰**：将下单请求放入 MQ，异步消费并扣减库存，避免瞬时高并发压垮数据库。

### 14. 缓存穿透、击穿、雪崩



三者都是缓存的核心问题，本质是 “缓存未命中导致的数据库压力飙升”，区别和解决方案如下：

| 问题     | 定义                                     | 原因                                   | 解决方案                                                     |
| -------- | ---------------------------------------- | -------------------------------------- | ------------------------------------------------------------ |
| 缓存穿透 | 查不存在的数据，缓存和数据库都未命中     | 恶意攻击（如查 id=-1）、业务逻辑错误   | 1. 空值缓存（缓存不存在的 key，设短期过期）；2. 布隆过滤器（提前拦截不存在的 key）；3. 接口参数校验 |
| 缓存击穿 | 热点 key 过期，大量请求同时命中数据库    | 热点 key（如爆款商品）无过期时间或过期 | 1. 逻辑过期（不设过期时间，缓存内存过期标识）；2. 互斥锁（Redis 分布式锁，仅一个线程查数据库更新缓存）；3. 热点 key 永不过期 |
| 缓存雪崩 | 大量缓存 key 同时过期，或 Redis 集群宕机 | 缓存 key 过期时间集中、Redis 集群故障  | 1. 过期时间随机化（避免同时过期）；2. 集群部署（主从 + 哨兵 / Cluster，避免单点故障）；3. 限流降级（数据库压力过大时拒绝非核心请求）；4. 缓存预热（启动时加载热点数据） |

### 15. 缓存击穿使用逻辑过期再介绍一下



逻辑过期是解决缓存击穿的 “无锁方案”，核心是**不依赖 Redis 的过期时间，而是在缓存数据中嵌入过期标识**，避免热点 key 过期后大量请求穿透到数据库：

1. **缓存存储结构**：缓存 value 是结构体（如 JSON），包含真实数据 + 过期时间戳，例：`{"data": "...", "expireAt": 1699999999}`（不设 Redis 的 TTL）；

2. 读流程：

    - 线程查询 Redis，获取数据后判断`expireAt`是否过期；
    - 未过期：直接返回数据；
    - 已过期：不删除缓存，直接返回旧数据（保证高可用），同时异步启动一个线程去查询数据库，更新缓存的`data`和`expireAt`（新的过期时间）；

3. **核心优势**：无锁，不阻塞请求（用户无感知延迟），避免分布式锁的竞争开销；

4. **缺点**：短期数据不一致（过期后到缓存更新前，返回旧数据），需业务能容忍。

### 16. 大圆桌 n 个位置，黑白棋轮流下棋，无空位置则对方输，如何保证我方获胜？



这是经典的**公平组合博弈问题**，核心结论和策略如下：

#### 前提假设：



- 规则：两人轮流下棋，每次只能在一个空位置放一枚棋子（黑白棋仅区分玩家，无特殊规则）；
- 获胜条件：对方无法落子（即我方占满最后一个空位置）。

#### 核心策略：



**镜像对称法**，前提是我方**先行**，且 n 为奇数（若 n 为偶数，先行方无法必胜，后行方可用同样策略反击）：

1. 第一步：我方占据圆桌的**中心位置**（若 n 为奇数，必有唯一中心；若 n 为偶数，无中心，此策略失效）；
2. 后续步骤：对方在任意位置落子后，我方立即在其**对称位置**（以中心为对称轴）落子；
3. 原理：圆桌是中心对称图形，我方始终模仿对方的落子位置，确保对方能落子的地方，我方一定能找到对称位置落子；最终对方会先无位置可落，我方获胜。

#### 特殊情况：



- 若 n 为偶数：无中心位置，先行方无法建立对称优势，后行方可采用 “镜像对称法” 反击，此时胜负取决于谁先失误；
- 若允许 “跳过回合” 或 “多放棋子”：规则变化，需重新分析，但默认规则下 “奇数 n + 先行 + 镜像对称” 是必胜策略。