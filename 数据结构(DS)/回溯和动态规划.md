动态规划（Dynamic Programming，简称 DP）和回溯（Backtracking）是算法设计中两种重要的思想，常用于解决不同类型的复杂问题。它们的核心思路和适用场景有显著差异，下面分别介绍并对比：

### **一、动态规划（DP）**

动态规划是一种通过**分解问题、存储中间结果**来高效解决**重叠子问题**和**最优子结构**问题的方法。其核心是 “避免重复计算”，通过将复杂问题拆解为更小的子问题，记录子问题的解，最终推导出原问题的解。

#### **1. 核心思想**

- **重叠子问题**：问题可以拆解为多个重复出现的子问题（即不同的大问题包含相同的小问题）。
- **最优子结构**：问题的最优解包含子问题的最优解（通过子问题的最优解可以推导出原问题的最优解）。
- **状态转移**：用一个 “状态” 表示子问题的解，通过定义 “状态转移方程” 描述子问题之间的关系，从已知的子问题解推导出更大的子问题解。
- **记忆化存储**：用数组或哈希表（称为 “DP 表”）存储子问题的解，避免重复计算。

#### **2. 解题步骤**

1. **定义状态**：确定 DP 表的含义（如 `dp[i]` 表示 “前 i 个元素的最优解”）。
2. **确定边界条件**：初始化最小子问题的解（如 `dp[0] = 0`）。
3. **推导状态转移方程**：描述 `dp[i]` 与 `dp[i-1]` 等前序状态的关系。
4. **填充 DP 表**：按顺序计算所有子问题的解，最终得到原问题的解。

#### **3. 典型应用场景**

- 最优解问题：如最长递增子序列、最短路径、背包问题（0-1 背包、完全背包）。
- 计数问题：如不同路径的数量、解码方法的总数。
- 字符串问题：如最长公共子序列、编辑距离。

#### **4. 示例：斐波那契数列**

斐波那契数列的递推公式为 `f(n) = f(n-1) + f(n-2)`，其中 `f(0)=0`，`f(1)=1`。

- 直接递归会重复计算大量子问题（如 `f(5)` 需计算 `f(4)` 和 `f(3)`，`f(4)` 又需计算 `f(3)` 和 `f(2)`，`f(3)` 被重复计算）。

- 动态规划解法：用```dp[i]```存储```f(i)```，通过迭代计算：








  ```java
  int fib(int n) {
      if (n <= 1) return n;
      int[] dp = new int[n + 1];
      dp[0] = 0;
      dp[1] = 1;
      for (int i = 2; i <= n; i++) {
          dp[i] = dp[i - 1] + dp[i - 2]; // 状态转移方程
      }
      return dp[n];
  }
  ```



### **二、回溯（Backtracking）**

回溯是一种通过**试错**寻找问题解的方法，本质是**深度优先搜索（DFS）的优化**。它通过逐步构建解的候选集，当发现候选集不可能成为有效解时，**回溯（撤销上一步选择）** 并尝试其他可能，直到找到所有有效解或遍历完所有可能。

#### **1. 核心思想**

- **试探与回溯**：从问题的起始状态出发，逐步做出选择，若当前选择无法得到解，则撤销选择（回溯），回到上一步尝试其他选择。
- **剪枝**：在搜索过程中，通过提前判断某些路径不可能得到解，减少无效搜索（如排除重复解、超出约束条件的路径）。
- **解的收集**：当构建的候选集满足问题的解条件时，记录该解。

#### **2. 解题步骤**

1. **定义解的结构**：确定需要构建的解的形式（如排列、组合、路径等）。
2. **递归搜索**：在每一步选择一个可能的选项，加入当前解的候选集。
3. **判断约束**：若候选集违反问题约束（如重复元素、不满足目标条件），则回溯（撤销选择）。
4. **收集解**：当候选集完整且满足条件时，记录该解。

#### **3. 典型应用场景**

- 排列组合问题：如全排列、子集、组合总和。
- 路径搜索问题：如迷宫求解、N 皇后问题、数独。
- 决策问题：如在多个选择中寻找所有满足条件的方案。

#### **4. 示例：全排列**

给定数组 `[1,2,3]`，求所有可能的排列。

- 思路：通过递归选择每个位置的元素，使用标记数组避免重复选择，当选择的元素数量等于数组长度时，记录当前排列。






  ```java
  List<List<Integer>> result = new ArrayList<>();
  void backtrack(int[] nums, boolean[] used, List<Integer> path) {
      if (path.size() == nums.length) {
          result.add(new ArrayList<>(path)); // 收集解
          return;
      }
      for (int i = 0; i < nums.length; i++) {
          if (used[i]) continue; // 剪枝：跳过已使用的元素
          used[i] = true;
          path.add(nums[i]); // 选择当前元素
          backtrack(nums, used, path); // 递归
          path.remove(path.size() - 1); // 回溯：撤销选择
          used[i] = false;
      }
  }
  ```



### **三、动态规划 vs 回溯：核心区别**

| 维度           | 动态规划（DP）                                 | 回溯（Backtracking）                                   |
| -------------- | ---------------------------------------------- | ------------------------------------------------------ |
| **目标**       | 求最优解或计数（通常是唯一解或总数）           | 求所有可能的解（或满足条件的解）                       |
| **方法**       | 自底向上或自顶向下（记忆化）计算子问题         | 深度优先搜索 + 剪枝，试错并回溯                        |
| **时间复杂度** | 通常较低（O (n²)、O (nm) 等，依赖子问题规模）  | 较高（最坏情况 O (2ⁿ) 或 O (n!)，依赖剪枝效果）        |
| **空间复杂度** | 主要用于存储 DP 表（O (n) 或 O (nm)）          | 主要用于递归栈和路径存储（O (n) 递归深度）             |
| **适用场景**   | 重叠子问题、最优子结构（如优化问题、计数问题） | 解空间较小、需要枚举所有解（如排列组合、约束满足问题） |

### **总结**

- **动态规划**适合解决有重叠子问题和最优子结构的问题，通过存储中间结果高效求解，更侧重 “计算”。
- **回溯**适合需要枚举所有可能解的问题，通过试错和剪枝探索解空间，更侧重 “搜索”。