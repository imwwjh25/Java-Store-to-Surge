在 Java 中，`String` 被设计为**不可变（Immutable）**，即一旦创建，其字符序列就无法被修改。这种设计是 Java 语言的经典决策，背后有多重原因，涉及安全性、性能、缓存和并发等多个维度。

### 一、为什么说 String 是不可变的？

从源码看，`String` 类的核心实现是一个 `char[]` 数组（JDK 9 及以上改为 `byte[]`，优化存储），且该数组被 `final` 修饰，同时 `String` 类本身也被 `final` 修饰：







```java
public final class String {
    private final char value[]; // JDK 8及以前
    // ... 其他方法
}
```

- `final` 修饰类：保证 `String` 不能被继承，避免子类重写方法破坏不可变性。
- `final` 修饰数组：保证数组引用不可变（不能指向向新的数组），且 `String` 类没有提供任何修改数组内容的方法（如 `setCharAt` 等），因此字符序列一旦创建就无法改变。

即使调用 `substring`、`concat` 等方法，也不会修改原 `String` 对象，而是创建一个新的 `String` 对象。

### 二、为什么要设计成不可变？

#### 1. 安全性：避免不可控的修改

`String` 是 Java 中最常用的数据类型之一，广泛用于存储敏感信息（如密码、URL、路径、网络连接参数等），以及作为参数传递（如方法参数、集合键值等）。

- 若```String```可变，攻击者可能在传递过程中修改其内容，导致安全漏洞。例如： 
假设```String```可变，当你将一个表示文件路径的```String```传递给某个方法时，该方法可能偷偷修改路径指向恶意文件，引发安全问题。

- 不可变性确保 `String` 一旦创建，其值就不会被任何代码（包括恶意代码）篡改，保证了数据的完整性。

#### 2. 缓存优化：提升性能

Java 设计了**字符串常量池（String Constant Pool）** 来缓存 `String` 对象，避免重复创建相同内容的 `String`，减少内存消耗。

- 例如：`String a = "abc"; String b = "abc";` 中，`a` 和 `b` 会指向常量池中的同一个对象，而非两个独立对象。
- 若 `String` 可变，当 `a` 修改时，`b` 的值也会被意外改变，破坏常量池的缓存逻辑。
- 不可变性保证了常量池中的 `String` 可以安全共享，不用担心被其他引用修改。

#### 3. 作为哈希表（HashMap）等集合的键时更可靠

`HashMap` 等哈希表的键依赖于 `hashCode` 的稳定性：键的 `hashCode` 必须在其生命周期内保持不变，否则会导致键值对无法正确查找。

- `String` 的 `hashCode` 是根据其字符序列计算的（缓存于 `hash` 字段）。
- 若 `String` 可变，修改字符序列会导致 `hashCode` 变化，此时哈希表中该键的位置（基于旧 `hashCode` 计算）与新 `hashCode` 不匹配，导致无法找到对应的值，破坏哈希表的正确性。
- 不可变性确保 `String` 的 `hashCode` 一旦计算就不会改变，使其成为哈希表的理想键。

#### 4. 线程安全：无需额外同步

在多线程环境中，不可变对象天然是线程安全的 —— 因为它们的状态不会被修改，多个线程可以安全地共享同一个 `String` 对象，无需加锁或同步处理。

- 若 `String` 可变，多线程并发修改时可能导致数据不一致（如部分线程读取到中间状态），需要额外的同步机制，增加复杂度和性能开销。

#### 5. 简化代码设计

不可变对象的状态固定，使用时无需担心被意外修改，降低了代码的复杂度和出错概率。例如：

- 传递 `String` 时无需复制副本（因为不会被修改），减少了内存复制的开销。
- 调试时，`String` 的值不会随执行流程变化，更容易追踪问题。

### 总结

`String` 的不可变性是 Java 基于**安全性、性能优化、集合可靠性、线程安全**等多方面考量的设计决策。虽然不可变性会导致每次修改都创建新对象（可能增加内存开销），但相比其带来的安全性和稳定性，这种代价在大多数场景下是可接受的。
