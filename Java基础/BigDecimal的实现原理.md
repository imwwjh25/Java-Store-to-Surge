### 一、核心数据结构：如何精确存储十进制数？



`BigDecimal` 内部通过两个核心字段存储数值信息，确保十进制数的精确性：

1. **`int val[]`：存储数值的 “无符号整数表示”**

   - 这是一个整数数组，用于存储十进制数的**有效数字（ significand）**，且以 “无符号” 形式保存（符号单独管理）。
   - 例如：`-123.45` 的有效数字是 `12345`，存储在 `val` 数组中为 `[1,2,3,4,5]`（实际实现中为了高效，数组元素可能是更大的整数，如每元素存储 9 位十进制数，减少数组长度）。

2. **`int scale`：表示小数点的位置（标度）**

   - ```
     scale
     ```

     

     定义了有效数字与实际值的映射关系，即：

     实际值 = (val 表示的整数) / 10^scale

   - 例如：

     - `123.45` 的 `val` 是 `12345`，`scale=2` → `12345 / 10² = 123.45`；
     - `12345`（整数）的 `scale=0` → `12345 / 10⁰ = 12345`；
     - `0.00123` 的 `val` 是 `123`，`scale=5` → `123 / 10⁵ = 0.00123`。

3. **`int signum`：表示符号**

   - `signum` 取值为 `-1`（负数）、`0`（零）、`1`（正数），独立于 `val` 数组存储，避免数组首位存储符号导致的复杂度。

### 二、标度（scale）的核心作用：控制精度与对齐



`BigDecimal` 的运算（如加减乘除）本质是对 **有效数字（val）** 和 **标度（scale）** 的组合操作，而 `scale` 是控制精度的关键：

1. 标度与精度的关系
   - 精度（precision）指有效数字的总位数（`val` 数组的长度），例如 `123.45` 的精度是 5（有效数字 1、2、3、4、5）。
   - 标度（scale）决定小数点位置，例如：
     - 同一精度（5 位）的 `12345`（scale=0）、`123.45`（scale=2）、`0.012345`（scale=6），其 `val` 均为 `12345`，仅 `scale` 不同。
2. 运算中的标度对齐
   - **加法 / 减法**：需先将两个数的标度对齐（类似十进制手动计算时 “小数点对齐”），再对有效数字进行加减。例：`1.23`（val=123, scale=2） + `4.567`（val=4567, scale=3）→ 对齐标度为 3：`1.230`（val=1230, scale=3） + `4.567`（val=4567, scale=3）→ 结果：val=5797, scale=3 → `5.797`。
   - **乘法**：有效数字直接相乘，标度为两个数的标度之和。例：`1.2`（val=12, scale=1） × `3.4`（val=34, scale=1）→ val=12×34=408，scale=1+1=2 → `4.08`。
   - **除法**：结果的标度需通过 “舍入模式（RoundingMode）” 指定（因除法可能产生无限小数），例如 `1 ÷ 3` 需指定保留几位小数（如 scale=2，结果为 `0.33`）。

### 三、舍入模式（RoundingMode）：解决精度溢出



由于除法、取模等运算可能产生无限小数，`BigDecimal` 强制要求指定舍入模式（避免默认行为导致的精度问题）。常见舍入模式包括：

- `ROUND_UP`：向上舍入（远离零），如 `1.234` 保留 2 位 → `1.24`；
- `ROUND_DOWN`：向下舍入（靠近零），如 `1.239` 保留 2 位 → `1.23`；
- `ROUND_HALF_UP`：四舍五入（最常用），如 `1.235` 保留 2 位 → `1.24`；
- `ROUND_HALF_EVEN`：银行家舍入（四舍六入五取偶），如 `1.235` 保留 2 位 → `1.24`，`1.245` 保留 2 位 → `1.24`。

### 四、缓存机制：优化小数值的性能



为避免频繁创建相同的小数值（如 `0`、`1`、`10` 等），`BigDecimal` 内部维护了一个缓存池（类似 `Integer` 的 `-128~127` 缓存）：

- 缓存范围：`0` 到 `10` 的整数（`BigDecimal.ZERO`、`BigDecimal.ONE`、`BigDecimal.TEN` 等）。
- 实现逻辑：通过静态工厂方法 `valueOf(long)` 创建时，若数值在缓存范围内，直接返回缓存对象，否则新建实例。

### 五、与浮点数（float/double）的本质区别



| 特性     | `float`/`double`                      | `BigDecimal`                      |
| -------- | ------------------------------------- | --------------------------------- |
| 存储方式 | 二进制浮点数（IEEE 754 标准）         | 十进制有效数字 + 标度（整数数组） |
| 精度问题 | 存在精度丢失（如 `0.1` 无法精确表示） | 完全精确（只要内存足够）          |
| 运算逻辑 | 硬件级二进制运算                      | 软件实现的十进制运算              |
| 适用场景 | 科学计算（允许精度误差）              | 金融、货币等需精确计算的场景      |

### 六、总结



`BigDecimal` 的核心实现原理可概括为：

1. 通过 **整数数组（val）** 存储有效数字，**标度（scale）** 定位小数点，**符号（signum）** 单独管理，实现十进制数的精确存储；
2. 运算时通过 **标度对齐** 和 **舍入模式** 保证精度，避免浮点数的二进制转换误差；
3. 附加缓存机制优化小数值的创建效率。

这使得 `BigDecimal` 成为金融、电商等对精度敏感场景的必备工具，但也因软件实现的十进制运算，性能略低于原生浮点数（需在精度和性能间权衡）。
