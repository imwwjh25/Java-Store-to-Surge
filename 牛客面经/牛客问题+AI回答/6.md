## [懂车帝后端一二面（已hr）](https://www.nowcoder.com/discuss/609867578508357632?sourceSSR=users)


### 1. 操作系统根据什么判断 CPU 的利用率？



核心结论：基于 **CPU 时间片的统计**，计算 “非空闲时间占总时间的比例”。

- 关键逻辑：
    1. OS 会给 CPU 划分时间片（如 10ms），并记录每个时间片的用途（运行用户进程、内核进程、空闲）；
    2. 每隔固定周期（如 1s），统计该周期内：
        - 忙碌时间：CPU 执行用户进程（user 态）、内核任务（sys 态，如调度、IO 处理）的总时间；
        - 空闲时间：CPU 无任务可执行（idle 态）的时间；
    3. CPU 利用率 = 忙碌时间 /（忙碌时间 + 空闲时间）× 100%。
- 补充：通过内核的 “进程调度器” 和 “时钟中断” 实现统计，比如 Linux 中通过 `/proc/stat` 文件暴露统计数据。

### 2. 为什么不直接基于 IP 通信，要有 UDP？



核心结论：IP 仅能定位 “主机”，UDP 补充了 “进程标识” 和 “传输层基础能力”，解决 “主机内多进程通信” 问题。

- 关键原因：
    1. IP 的局限性：IP 协议仅负责 “跨网络传输数据包”，只能通过 IP 地址定位目标主机，但无法确定主机内哪个进程接收数据（一台主机可能同时运行多个网络进程，如浏览器、微信）；
    2. UDP 提供端口号：端口号（1-65535）用于标识主机内的进程，实现 “主机 + 端口” 的精准寻址（如 IP:192.168.1.1 + 端口：8080 定位到具体服务进程）；
    3. 传输层基础能力：UDP 提供了简单的 “数据报封装”（源端口、目的端口、校验和），解决了 IP 协议无校验、无进程标识的问题，为应用层提供统一的传输接口。

### 3. MAC 地址是否唯一？



核心结论：**理论上全球唯一，实际存在极小概率冲突**。

- 关键逻辑：
    1. MAC 地址（物理地址）由 48 位二进制组成，前 24 位是 “厂商标识（OUI）”，由 IEEE 分配给网络设备厂商（如 Intel、华为）；后 24 位是厂商自定义的 “设备序列号”；
    2. 厂商需保证同一 OUI 下的设备序列号不重复，因此理论上全球所有网络设备（网卡、路由器）的 MAC 地址唯一；
    3. 冲突场景：人为修改 MAC 地址（如通过软件伪造）、厂商违规重复分配序列号（极罕见），可能导致同一局域网内 MAC 冲突（会触发 ARP 广播冲突处理）。

### 4. 堆排序了解吗？



核心结论：基于 “大顶堆 / 小顶堆” 的数据结构，时间复杂度 O (n log n)，空间复杂度 O (1)，不稳定排序。

- 核心流程（以大顶堆排序为例，升序排列）：
    1. 构建大顶堆：将待排序数组调整为大顶堆（每个父节点值 ≥ 子节点值），从最后一个非叶子节点（索引 n/2 - 1）开始，依次向下调整堆结构；
    2. 堆顶交换与调整：
        - 交换堆顶（最大值）与数组末尾元素，将最大值固定到数组尾部；
        - 剩余元素（前 n-1 个）重新调整为大顶堆（仅需调整堆顶，向下沉降）；
        - 重复上述步骤，直到数组完全有序。
- 特点：适合大数据量排序（空间开销小），但不稳定（相同值的元素可能交换位置）。

### 5. fork 子进程具体流程，父进程挂了怎么办？



#### （1）fork 子进程具体流程（Linux 系统）



fork 是 `unistd.h` 中的系统调用，用于创建子进程，核心是 “复制父进程资源”，流程如下：

1. 父进程调用 `fork()`，触发内核态切换；
2. 内核为子进程分配 PID（进程 ID）、PPID（父进程 ID，设为当前父进程 PID），以及独立的进程控制块（PCB）；
3. 资源复制（写时复制，Copy-On-Write）：
    - 不立即复制父进程的内存空间（如代码段、数据段、堆、栈），而是让父子进程共享只读内存；
    - 当任一进程修改内存数据时（如写变量），才为修改的页面创建副本，实现 “按需复制”（减少创建开销）；
4. 复制父进程的打开文件描述符（FD）、信号掩码、环境变量、工作目录等；
5. 内核将子进程加入就绪队列，调度器后续会分配 CPU 时间片；
6. 父子进程分别从 `fork()` 返回：父进程返回子进程 PID，子进程返回 0（通过返回值区分父子）。

#### （2）父进程挂了，子进程何去何从？



- 子进程会成为 “孤儿进程”，被 **init 进程（PID=1）或 systemd 进程** 收养；
- 具体过程：
    1. 父进程终止后，内核会发送 `SIGCHLD` 信号给所有子进程；
    2. 子进程的 PPID 被内核修改为 1（init 进程）；
    3. init 进程会定期调用 `wait()` 或 `waitpid()` 回收孤儿进程的退出状态，避免子进程成为 “僵尸进程”（Z 状态）。

### 6. Linux 文件管理系统怎么实现的？



核心结论：基于 “索引节点（inode）+ 目录项（dentry）+ 挂载点” 的分层结构，统一管理各类存储设备。

- 核心组件与流程：

1. 索引节点（inode）

   ：

    - 存储文件的元数据（大小、权限、创建时间、存储块地址等），每个文件对应唯一 inode（有 inode 编号）；
    - 不存储文件名，文件名由目录项管理。

2. 目录项（dentry）

   ：

    - 目录是特殊文件，其数据块存储 “文件名 → inode 编号” 的映射关系（即目录项）；
    - 通过目录项可快速查找文件对应的 inode（如 `ls` 命令本质是读取目录的 dentry 列表）。

3. 挂载点（mount point）

   ：

    - 不同文件系统（如 ext4、tmpfs、NTFS）通过挂载点接入根文件系统（/）；
    - 内核通过挂载表（mount table）记录 “挂载点 → 文件系统” 的映射，访问挂载点下的文件时，自动切换到对应文件系统。

4. 文件操作流程

   ：

    - 打开文件：`open("/home/test.txt")` → 内核解析路径（从 / 开始，逐层查找 dentry 得到 inode）→ 分配文件描述符（FD）绑定 inode；
    - 读写文件：通过 FD 找到 inode → 从 inode 中获取文件存储块的磁盘地址 → 与存储设备交互读写数据。

### 7. 进程几种状态以及怎么流转？



#### （1）Linux 进程核心状态（5 种）



- 运行态（R，Running/Runnable）：进程正在占用 CPU，或在就绪队列等待 CPU；
- 阻塞态（D，Uninterruptible Sleep）：进程等待不可中断的资源（如磁盘 IO），无法被信号唤醒；
- 可中断睡眠态（S，Interruptible Sleep）：进程等待可中断资源（如键盘输入、网络数据），可被信号唤醒（如 `SIGINT`）；
- 僵尸态（Z，Zombie）：进程已终止，但父进程未调用 `wait()` 回收其退出状态，PCB 仍存在；
- 停止态（T，Stopped）：进程被信号暂停（如 `SIGSTOP`），需 `SIGCONT` 信号恢复运行。

#### （2）状态流转核心场景



1. S → R：进程等待的资源就绪（如网络数据到达），内核将其移入就绪队列，调度器分配 CPU；
2. R → S：进程调用 `sleep()` 或等待资源（如 `wait()`），主动放弃 CPU；
3. R → D：进程发起磁盘 IO 等不可中断请求，进入阻塞态；
4. D → R：磁盘 IO 完成，内核唤醒进程；
5. R → T：进程收到 `SIGSTOP` 信号；
6. T → R：进程收到 `SIGCONT` 信号；
7. 任意态 → Z：进程调用 `exit()` 终止，父进程未回收；
8. Z → 释放：父进程调用 `wait()` 回收，或父进程终止后 init 进程回收。

### 8. TCP 累计应答机制



核心结论：TCP 不逐个应答每个报文段，而是通过 “期望接收的下一个字节序号”，一次性应答连续接收的多个报文段，提升传输效率。

- 核心逻辑：
    1. 发送方连续发送报文段（如序号 1-100、101-200、201-300）；
    2. 接收方成功接收前两个报文段（1-200），但第三个报文段（201-300）丢失；
    3. 接收方返回应答报文（ACK），其中 “确认号” 设为 201（表示已正确接收 1-200 字节，期望下一个接收 201 字节）；
    4. 发送方收到 ACK=201 后，知道前 200 字节已确认，仅重传丢失的 201-300 报文段，无需重传已确认的部分。
- 优势：减少 ACK 报文数量，降低网络开销；支持乱序接收（接收方会缓存乱序报文段，等待连续后统一应答）。

### 9. 超时重传和快重传



#### （1）超时重传



- 定义：发送方发送报文段后，启动超时计时器（重传超时 RTO），若超时未收到对应 ACK，则重传该报文段。
- 关键细节：
    - RTO 动态调整：基于往返时间（RTT）计算，RTT 越长，RTO 越大（避免误判）；
    - 重传策略：首次超时重传后，RTO 翻倍（指数退避），避免网络拥堵时频繁重传。

#### （2）快重传



- 定义：接收方收到乱序报文段时，立即发送 “重复 ACK”（确认号不变），发送方收到 3 个连续重复 ACK 后，无需等待超时，直接重传丢失的报文段。
- 核心场景：
    - 发送方发送 1-100、101-200、201-300；
    - 接收方收到 1-100（ACK=201）、201-300（乱序，缓存），未收到 101-200；
    - 接收方每收到一次乱序报文段，就发送一次 ACK=201（重复 ACK）；
    - 发送方收到 3 个 ACK=201 后，立即重传 101-200 报文段，提升重传效率。

### 10. MySQL 怎么保证事务的一致性，两阶段提交



#### （1）事务一致性的保证方式



一致性是 ACID 中的核心，指事务执行前后，数据从一个合法状态变为另一个合法状态，MySQL 主要通过以下方式保证：

1. 原子性（基础）：通过 “undo 日志” 实现，事务失败时回滚到执行前状态，避免部分修改；
2. 隔离性（保障）：通过锁机制（行锁、表锁）和 MVCC（多版本并发控制），避免并发事务相互干扰（如脏读、不可重复读）；
3. 持久性（支撑）：通过 “redo 日志” 实现，事务提交后数据持久化到磁盘，避免宕机丢失；
4. 约束校验：执行 SQL 时校验数据约束（主键、外键、唯一索引、非空约束），不符合约束则事务回滚。

#### （2）两阶段提交（2PC）—— 分布式事务一致性方案



- 适用场景：跨多个数据库（或 MySQL 实例）的分布式事务，保证所有节点要么同时提交，要么同时回滚。
- 核心流程（分协调者和参与者）：

1. 准备阶段（Phase 1）：
    - 协调者向所有参与者发送 “准备提交” 请求；
    - 参与者执行事务操作（写 redo/undo 日志），但不提交，将事务状态设为 “准备就绪”，向协调者返回 “同意提交”；
    - 若任一参与者执行失败，返回 “拒绝提交”。
2. 提交阶段（Phase 2）：
    - 若所有参与者都返回 “同意”：协调者向所有参与者发送 “提交” 请求，参与者执行提交操作，释放资源，返回 “提交成功”；
    - 若有参与者返回 “拒绝”：协调者向所有参与者发送 “回滚” 请求，参与者通过 undo 日志回滚，释放资源，返回 “回滚成功”。

- 缺点：存在阻塞问题（协调者宕机可能导致参与者长期阻塞），性能较低。

### 11. RoaringBitmap 数据结构，交并补具体过程



#### （1）RoaringBitmap 核心定义



RoaringBitmap 是优化的位图（Bitmap）数据结构，用于高效存储和查询整数集合，核心是 “分桶存储 + 压缩稀疏区间”，解决传统 Bitmap 稀疏数据占用空间大的问题。

- 结构：将 32 位整数分为高 16 位（桶编号）和低 16 位（桶内偏移），每个桶对应一个容器（密集区间用 Bitmap 容器，稀疏区间用数组容器）。

#### （2）交并补具体过程



假设两个 RoaringBitmap：A 和 B。

1. 交集（A ∩ B）：
    - 遍历 A 和 B 的共同桶（相同高 16 位）；
    - 对每个共同桶，计算两个桶内容器的交集（Bitmap 容器用按位与 `&`，数组容器用双指针遍历找共同元素）；
    - 收集所有桶的交集结果，组成最终交集。
2. 并集（A ∪ B）：
    - 遍历 A 和 B 的所有桶（包括仅 A 有、仅 B 有、共同有）；
    - 仅 A 有 / 仅 B 有的桶，直接将容器加入结果；
    - 共同桶，计算容器的并集（Bitmap 用按位或 `|`，数组用合并去重）；
    - 收集所有结果，组成最终并集。
3. 补集（A - B）：
    - 遍历 A 的所有桶；
    - 若桶不在 B 中，直接将 A 的桶容器加入结果；
    - 若桶在 B 中，计算 A 桶容器与 B 桶容器的差集（Bitmap 用 `A & ~B`，数组用双指针遍历找 A 独有的元素）；
    - 收集所有结果，组成最终补集。

### 12. 项目中的几种数据模型，表如何设计



#### （1）常见数据模型



1. 关系型模型：适用于结构化数据（如用户、订单），依赖表、主键、外键关联，MySQL 常用；
2. 文档型模型：适用于半结构化数据（如商品详情、日志），以 JSON/BSON 存储，MongoDB 常用；
3. 键值模型：适用于缓存、配置存储（如用户会话、热点数据），Redis 常用；
4. 时序模型：适用于时间序列数据（如监控指标、日志时间线），InfluxDB 常用。

#### （2）关系型表设计核心原则（以 MySQL 为例）



1. 遵循三大范式（避免冗余）：
    - 1NF：字段原子性（不可拆分，如不存 “姓名 + 电话” 合并字段）；
    - 2NF：消除部分依赖（非主键字段必须完全依赖主键，不能依赖主键的一部分）；
    - 3NF：消除传递依赖（非主键字段不能依赖其他非主键字段）。
2. 合理选择字段类型：
    - 主键用 INT/BIGINT（自增）或 UUID（分布式场景）；
    - 字符串用 VARCHAR（可变长度，节省空间），避免 CHAR（固定长度）；
    - 时间用 DATETIME/TIMESTAMP（TIMESTAMP 占空间更小，支持时区）。
3. 索引设计：
    - 主键默认索引，高频查询字段（如订单号、用户 ID）建单字段索引；
    - 联合查询字段建联合索引（遵循最左前缀原则）；
    - 避免过度索引（影响写入性能）。
4. 冗余设计（反范式）：
    - 高频查询的关联字段可冗余（如订单表冗余商品名称，避免 join 查询）；
    - 统计字段冗余（如用户表冗余订单数，避免实时计算）。

### 13. SQL：找到薪水第 N 的 ID



假设表名 `employee`，字段 `id`（员工 ID）、`salary`（薪水），需考虑薪水可能重复的情况（如并列第 2 名）。

#### 方案 1：使用窗口函数（MySQL 8.0+ 支持）



sql

```
-- 若薪水重复，并列第 N 名（如两个第 2 名，都会返回）
SELECT id
FROM (
    SELECT 
        id,
        salary,
        DENSE_RANK() OVER (ORDER BY salary DESC) AS rank  -- DENSE_RANK 不跳级，RANK 跳级
    FROM employee
) AS temp
WHERE rank = N;
```



#### 方案 2：兼容低版本 MySQL（无窗口函数）



sql

```
-- 找到薪水第 N 高的值，再查对应 ID（并列情况也会返回）
SELECT id
FROM employee
WHERE salary = (
    SELECT DISTINCT salary
    FROM employee
    ORDER BY salary DESC
    LIMIT N-1, 1  -- 偏移 N-1，取 1 条（即第 N 高的薪水）
);
```



### 14. 算法：实现 pow () 快速幂



#### 题目要求：实现 `pow(x, n)`，计算 x 的 n 次幂（n 为整数，可正可负）。



#### 核心思路：快速幂（分治思想），时间复杂度 O (log |n|)，空间复杂度 O (1)。



java

运行

```
public double myPow(double x, int n) {
    // 处理 n 为负数的情况：x^(-n) = 1 / x^n
    long exponent = n;  // 避免 n = Integer.MIN_VALUE 时取反溢出
    if (exponent < 0) {
        x = 1 / x;
        exponent = -exponent;
    }
    
    double result = 1.0;
    while (exponent > 0) {
        // 若 exponent 为奇数，当前 x 乘入结果
        if (exponent % 2 == 1) {
            result *= x;
        }
        // x 平方（分治：x^2 → x^4 → x^8...）
        x *= x;
        // exponent 除以 2（整数除法，等价于右移 1 位）
        exponent /= 2;
    }
    return result;
}
```



### 15. 算法：最小栈



#### 题目要求：设计一个支持 push、pop、top 操作，并能在常数时间内检索到最小元素的栈。



#### 核心思路：双栈实现（主栈存数据，辅助栈存当前最小值），所有操作 O (1) 时间。



java

运行

```
import java.util.Stack;

class MinStack {
    private Stack<Integer> dataStack;  // 主栈：存储所有元素
    private Stack<Integer> minStack;   // 辅助栈：存储当前最小值

    public MinStack() {
        dataStack = new Stack<>();
        minStack = new Stack<>();
    }

    // 入栈：辅助栈仅压入小于等于当前最小值的元素
    public void push(int val) {
        dataStack.push(val);
        // 辅助栈为空，或当前值 <= 辅助栈顶（最小值），则压入
        if (minStack.isEmpty() || val <= minStack.peek()) {
            minStack.push(val);
        }
    }

    // 出栈：若主栈弹出的是最小值，辅助栈也弹出
    public void pop() {
        int popVal = dataStack.pop();
        if (popVal == minStack.peek()) {
            minStack.pop();
        }
    }

    // 获取栈顶元素
    public int top() {
        return dataStack.peek();
    }

    // 获取最小值（辅助栈顶）
    public int getMin() {
        return minStack.peek();
    }
```