Spring 中的事务传播特性（Transaction Propagation）定义了 **多个事务方法嵌套调用时，事务如何传播和交互**（例如：是否复用现有事务、是否创建新事务、如何处理嵌套关系等）。传播特性是 `@Transactional` 注解的核心属性（`propagation`），由 `Propagation` 枚举类定义，共 7 种类型，具体如下：

### 1. `REQUIRED`（默认值）

- **含义**：如果当前存在活跃事务，则加入该事务；如果没有活跃事务，则创建一个新事务。

- **场景**：最常用的传播特性，适用于大多数业务场景（如 “下单” 方法调用 “扣库存” 和 “减余额” 方法，三者应在同一事务中）。

- 示例 ： 方法 A（无事务）调用方法 B（```REQUIRED```）→ B 创建新事务； 方法 A（有事务）调用方法 B（```REQUIRED```）→ B 加入 A 的事务，两者同成功、同失败。

### 2. `SUPPORTS`

- **含义**：如果当前存在活跃事务，则加入该事务；如果没有活跃事务，则以非事务方式执行（不开启事务）。
- **场景**：适用于 “可选事务” 的方法（如查询操作，可在事务中执行，也可单独执行，不强制需要事务）。

### 3. `MANDATORY`

- **含义**：必须在一个已存在的活跃事务中执行；如果当前没有活跃事务，则直接抛出 `IllegalTransactionStateException` 异常。
- **场景**：强制要求方法必须在事务中执行（如 “日志记录” 必须依赖于上游业务的事务，确保业务和日志同成败）。

### 4. `REQUIRES_NEW`

- **含义**：无论当前是否存在活跃事务，都创建一个新事务；如果存在活跃事务，则将其挂起（暂停执行），直到新事务完成。
- **场景**：需要 “独立事务” 的场景（如 “下单” 失败时，“扣库存” 需要回滚，但 “记录操作日志” 必须成功提交，不受下单事务影响）。
- **特点**：新事务与原事务完全独立，两者的提交 / 回滚互不影响。

### 5. `NOT_SUPPORTED`

- **含义**：以非事务方式执行；如果当前存在活跃事务，则将其挂起，直到方法执行完成后再恢复原事务。
- **场景**：明确不需要事务的操作（如耗时较长的统计计算，避免长期占用事务资源导致锁表）。

### 6. `NEVER`

- **含义**：必须以非事务方式执行；如果当前存在活跃事务，则直接抛出 `IllegalTransactionStateException` 异常。
- **场景**：严格禁止在事务中执行的方法（如某些不允许事务包裹的特殊操作）。

### 7. `NESTED`

- **含义**：如果当前存在活跃事务，则在嵌套事务中执行（嵌套事务是原事务的一部分，依赖于原事务）；如果没有活跃事务，则创建新事务（同 `REQUIRED`）。

- 特点 ：

    - 嵌套事务的提交需等待外层事务提交后才最终生效；
    - 嵌套事务回滚时，仅回滚自身操作，不影响外层事务（但外层事务可选择是否回滚）；
    - 依赖数据库对 “保存点（Savepoint）” 的支持（如 MySQL 的 InnoDB 引擎）。

- **场景**：需要 “部分回滚” 的场景（如 “批量插入” 时，某一条记录失败仅回滚该条，不影响其他记录和外层事务）。

### 总结

传播特性的核心是解决 **多事务方法嵌套时的边界问题**，选择时需结合业务对 “原子性” 和 “独立性” 的要求：

- 多数场景用 `REQUIRED`（共享事务）；
- 需独立事务用 `REQUIRES_NEW`；
- 需部分回滚用 `NESTED`（依赖数据库支持）；
- 强制事务或禁止事务用 `MANDATORY` 或 `NEVER`。

注意：传播特性仅在 **通过 Spring 代理对象调用方法** 时生效（同类中 `this` 调用会失效）。