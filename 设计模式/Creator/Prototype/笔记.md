### 一、为什么需要原型模式？

先看痛点场景：创建一个`User`对象，需要从数据库加载用户信息（ID、姓名、权限列表等），如果每次创建都执行`select * from user where id=1`，会频繁访问数据库，性能低下。

原型模式的解决思路：先创建一个 “原型对象”（加载一次数据库），后续新对象直接克隆这个原型，无需重复查库，大幅提升效率。

### 二、原型模式的核心结构

原型模式的核心只有 2 个角色：

1. **抽象原型（Creator.Prototype）**：定义克隆自身的方法（如`clone()`），通常是接口或抽象类；
2. **具体原型（Concrete Creator.Prototype）**：实现克隆方法，完成自身的复制。

在 Java 中，无需手动定义抽象原型，直接实现`Cloneable`接口（标记接口，标识该类支持克隆），并重写`Object`类的`clone()`方法即可。

### 三、核心概念：浅克隆 vs 深克隆

这是原型模式的核心区别，直接决定克隆后对象的独立性：





|  类型  |                           核心逻辑                           |                     优缺点                     |
| :----: | :----------------------------------------------------------: | :--------------------------------------------: |
| 浅克隆 | 复制对象的基本数据类型属性，引用类型属性仅复制**引用地址**（新旧对象共享引用对象） | 优点：速度快；缺点：引用类型属性修改会互相影响 |
| 深克隆 | 复制对象的所有属性（包括引用类型属性，递归克隆），新旧对象完全独立 | 优点：对象完全独立；缺点：速度稍慢，实现略复杂 |

### 四、完整代码实现

#### 1. 浅克隆实现（最常用）








```
import java.util.List;

// 具体原型类：实现Cloneable，重写clone()
class User implements Cloneable {
    // 基本数据类型
    private int id;
    private String name;
    // 引用数据类型（浅克隆仅复制引用）
    private List<String> permissions;

    // 构造器：模拟复杂初始化（如查库）
    public User(int id, String name, List<String> permissions) {
        System.out.println("执行复杂初始化（如数据库查询）...");
        this.id = id;
        this.name = name;
        this.permissions = permissions;
    }

    // 重写clone()实现浅克隆
    @Override
    protected User clone() throws CloneNotSupportedException {
        // 调用Object的native clone方法，实现浅克隆
        return (User) super.clone();
    }

    // getter/setter（方便测试）
    public int getId() { return id; }
    public void setId(int id) { this.id = id; }
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    public List<String> getPermissions() { return permissions; }
    public void setPermissions(List<String> permissions) { this.permissions = permissions; }

    @Override
    public String toString() {
        return "User{id=" + id + ", name='" + name + "', permissions=" + permissions + "}";
    }
}

// 浅克隆测试
public class ShallowCloneDemo {
    public static void main(String[] args) throws CloneNotSupportedException {
        // 1. 创建原型对象（执行一次复杂初始化）
        List<String> permissions = List.of("read", "write");
        User prototype = new User(1, "张三", permissions);
        System.out.println("原型对象：" + prototype);

        // 2. 克隆新对象（无需执行初始化，直接复制）
        User cloneUser = prototype.clone();
        cloneUser.setId(2);
        cloneUser.setName("李四");
        System.out.println("克隆对象：" + cloneUser);

        // 3. 验证浅克隆：引用类型属性共享（permissions是不可变List，这里换可变List测试更明显）
        // 替换为可变List测试：
        // List<String> mutablePerms = new ArrayList<>(List.of("read", "write"));
        // User prototype = new User(1, "张三", mutablePerms);
        // User cloneUser = prototype.clone();
        // prototype.getPermissions().add("delete"); // 原型添加权限
        // System.out.println("克隆对象permissions：" + cloneUser.getPermissions()); // 也会包含delete
    }
}
```

**输出结果**：












```
执行复杂初始化（如数据库查询）...
原型对象：User{id=1, name='张三', permissions=[read, write]}
克隆对象：User{id=2, name='李四', permissions=[read, write]}
```

#### 2. 深克隆实现（两种常用方式）

##### 方式 1：手动递归克隆（适合简单引用类型）










```
import java.util.ArrayList;
import java.util.List;

class UserDeepClone1 implements Cloneable {
    private int id;
    private String name;
    private List<String> permissions;

    public UserDeepClone1(int id, String name, List<String> permissions) {
        System.out.println("执行复杂初始化...");
        this.id = id;
        this.name = name;
        this.permissions = permissions;
    }

    // 手动实现深克隆：复制引用类型属性
    @Override
    protected UserDeepClone1 clone() throws CloneNotSupportedException {
        UserDeepClone1 clone = (UserDeepClone1) super.clone();
        // 手动克隆List（创建新List，复制元素）
        clone.permissions = new ArrayList<>(this.permissions);
        return clone;
    }

    // getter/setter
    public int getId() { return id; }
    public void setId(int id) { this.id = id; }
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    public List<String> getPermissions() { return permissions; }

    @Override
    public String toString() {
        return "UserDeepClone1{id=" + id + ", name='" + name + "', permissions=" + permissions + "}";
    }
}

// 测试手动深克隆
public class DeepCloneDemo1 {
    public static void main(String[] args) throws CloneNotSupportedException {
        List<String> mutablePerms = new ArrayList<>(List.of("read", "write"));
        UserDeepClone1 prototype = new UserDeepClone1(1, "张三", mutablePerms);
        UserDeepClone1 clone = prototype.clone();
        
        // 修改原型的permissions
        prototype.getPermissions().add("delete");
        System.out.println("原型permissions：" + prototype.getPermissions()); // [read, write, delete]
        System.out.println("克隆permissions：" + clone.getPermissions());     // [read, write]（独立，不受影响）
    }
}
```

##### 方式 2：序列化实现深克隆（适合复杂引用类型）

通过序列化将对象转为字节流，再反序列化生成新对象，天然实现深克隆（需实现`Serializable`接口）：








```
import java.io.*;
import java.util.List;

class UserDeepClone2 implements Serializable {
    private static final long serialVersionUID = 1L; // 序列化版本号
    private int id;
    private String name;
    private List<String> permissions;

    public UserDeepClone2(int id, String name, List<String> permissions) {
        System.out.println("执行复杂初始化...");
        this.id = id;
        this.name = name;
        this.permissions = permissions;
    }

    // 序列化实现深克隆
    public UserDeepClone2 deepClone() throws IOException, ClassNotFoundException {
        // 1. 序列化：对象转字节流
        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        ObjectOutputStream oos = new ObjectOutputStream(bos);
        oos.writeObject(this);

        // 2. 反序列化：字节流转新对象
        ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());
        ObjectInputStream ois = new ObjectInputStream(bis);
        return (UserDeepClone2) ois.readObject();
    }

    // getter/setter
    public List<String> getPermissions() { return permissions; }

    @Override
    public String toString() {
        return "UserDeepClone2{id=" + id + ", name='" + name + "', permissions=" + permissions + "}";
    }
}

// 测试序列化深克隆
public class DeepCloneDemo2 {
    public static void main(String[] args) throws Exception {
        List<String> mutablePerms = new ArrayList<>(List.of("read", "write"));
        UserDeepClone2 prototype = new UserDeepClone2(1, "张三", mutablePerms);
        UserDeepClone2 clone = prototype.deepClone();
        
        prototype.getPermissions().add("delete");
        System.out.println("原型permissions：" + prototype.getPermissions()); // [read, write, delete]
        System.out.println("克隆permissions：" + clone.getPermissions());     // [read, write]
    }
}
```

### 五、原型模式的核心特点

#### 优点：

1. **效率高**：克隆避免了重复执行复杂的初始化逻辑（如查库、网络请求），创建速度远快于 new；
2. **简化创建**：无需关注对象的构造细节，直接克隆原型即可；
3. **灵活性高**：可在运行时动态修改原型属性，克隆出不同配置的对象。

#### 缺点：

1. **浅克隆风险**：若未注意引用类型共享问题，修改克隆对象的引用属性会影响原型；
2. **深克隆实现复杂**：复杂对象（多层嵌套引用）的深克隆需要递归实现，或依赖序列化；
3. **克隆方法限制**：Java 中`clone()`是 protected 方法，需重写为 public；final 属性无法被克隆修改。

### 六、原型模式 vs 工厂模式（核心区别）






|   维度   |            原型模式            |            工厂模式            |
| :------: | :----------------------------: | :----------------------------: |
| 创建方式 |      复制已有对象（克隆）      |     全新创建（调用构造器）     |
| 适用场景 |  对象初始化成本高、需批量创建  |   产品类型固定、创建逻辑统一   |
| 核心优势 | 提升创建效率（避免重复初始化） | 解耦创建与使用（无需关注构造） |
| 对象关系 |  克隆对象与原型有 “模板” 关系  |     工厂创建的对象相互独立     |

### 总结

1. **核心思想**：原型模式通过克隆已有对象创建新对象，核心是解决 “复杂对象快速创建” 问题；

2. 关键选择：

    - 简单对象、引用类型无需独立 → 浅克隆（高效，优先使用）；
    - 复杂对象、引用类型需独立 → 深克隆（手动递归或序列化）；



3. 适用场景 ：

    - 对象初始化需要大量资源（数据库、IO、网络）；
    - 需要批量创建相同 / 相似对象（如游戏角色、配置对象）；
    - 避免构造器参数过多，简化对象创建；



4. **Java 注意点**：实现`Cloneable`接口是标记支持克隆，必须重写`clone()`方法才能使用。