
### 第一道题：死锁代码 + 解决方案

#### 1. 死锁代码实现

死锁的核心条件：**资源互斥、持有并等待、不可剥夺、循环等待**。以下代码通过两个线程互相持有对方需要的锁，触发死锁：


```java
public class DeadLockDemo {
    // 定义两个互斥资源（锁对象）
    private static final Object LOCK_A = new Object();
    private static final Object LOCK_B = new Object();

    public static void main(String[] args) {
        // 线程1：先拿 LOCK_A，再尝试拿 LOCK_B
        new Thread(() -> {
            synchronized (LOCK_A) {
                System.out.println("线程1：已获取锁A，尝试获取锁B...");
                try {
                    // 模拟业务耗时，增加死锁概率
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
                // 尝试获取锁B（此时锁B已被线程2持有）
                synchronized (LOCK_B) {
                    System.out.println("线程1：成功获取锁B，执行完成");
                }
            }
        }, "Thread-1").start();

        // 线程2：先拿 LOCK_B，再尝试拿 LOCK_A
        new Thread(() -> {
            synchronized (LOCK_B) {
                System.out.println("线程2：已获取锁B，尝试获取锁A...");
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
                // 尝试获取锁A（此时锁A已被线程1持有）
                synchronized (LOCK_A) {
                    System.out.println("线程2：成功获取锁A，执行完成");
                }
            }
        }, "Thread-2").start();
    }
}
```

**运行结果**：线程 1 和线程 2 互相等待对方的锁，永远阻塞，控制台输出如下（无后续执行）：







```plaintext
线程1：已获取锁A，尝试获取锁B...
线程2：已获取锁B，尝试获取锁A...
```

#### 2. 死锁解决方案（8 种常用方法）

##### 方法 1：统一锁获取顺序（最核心、最常用）

破坏 “循环等待” 条件：所有线程按固定顺序获取锁（如先拿 LOCK_A，再拿 LOCK_B）。



```java
public class SolveDeadLock1 {
    private static final Object LOCK_A = new Object();
    private static final Object LOCK_B = new Object();

    public static void main(String[] args) {
        // 线程1：按 A→B 顺序获取锁
        new Thread(() -> {
            synchronized (LOCK_A) {
                System.out.println("线程1：已获取锁A，尝试获取锁B...");
                try { Thread.sleep(100); } catch (InterruptedException e) {}
                synchronized (LOCK_B) {
                    System.out.println("线程1：成功获取锁B，执行完成");
                }
            }
        }, "Thread-1").start();

        // 线程2：同样按 A→B 顺序获取锁（不再先拿 B）
        new Thread(() -> {
            synchronized (LOCK_A) { // 统一先拿锁A
                System.out.println("线程2：已获取锁A，尝试获取锁B...");
                try { Thread.sleep(100); } catch (InterruptedException e) {}
                synchronized (LOCK_B) {
                    System.out.println("线程2：成功获取锁B，执行完成");
                }
            }
        }, "Thread-2").start();
    }
}
```

##### 方法 2：使用可重入锁（ReentrantLock）+ 超时获取

破坏 “持有并等待” 条件：通过 `tryLock(timeout)` 尝试获取锁，超时则放弃，避免无限等待。








```java
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class SolveDeadLock2 {
    private static final Lock LOCK_A = new ReentrantLock();
    private static final Lock LOCK_B = new ReentrantLock();

    public static void main(String[] args) {
        new Thread(() -> {
            try {
                // 尝试获取锁A，超时时间2秒
                if (LOCK_A.tryLock(2000, java.util.concurrent.TimeUnit.MILLISECONDS)) {
                    System.out.println("线程1：已获取锁A，尝试获取锁B...");
                    try {
                        // 尝试获取锁B，超时时间2秒
                        if (LOCK_B.tryLock(2000, java.util.concurrent.TimeUnit.MILLISECONDS)) {
                            try {
                                System.out.println("线程1：成功获取锁B，执行完成");
                            } finally {
                                LOCK_B.unlock(); // 释放锁B
                            }
                        } else {
                            System.out.println("线程1：获取锁B超时，放弃");
                        }
                    } finally {
                        LOCK_A.unlock(); // 释放锁A
                    }
                } else {
                    System.out.println("线程1：获取锁A超时，放弃");
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }, "Thread-1").start();

        // 线程2逻辑同上（顺序仍为 B→A，但通过超时避免死锁）
        new Thread(() -> {
            try {
                if (LOCK_B.tryLock(2000, java.util.concurrent.TimeUnit.MILLISECONDS)) {
                    System.out.println("线程2：已获取锁B，尝试获取锁A...");
                    try {
                        if (LOCK_A.tryLock(2000, java.util.concurrent.TimeUnit.MILLISECONDS)) {
                            try {
                                System.out.println("线程2：成功获取锁A，执行完成");
                            } finally {
                                LOCK_A.unlock();
                            }
                        } else {
                            System.out.println("线程2：获取锁A超时，放弃");
                        }
                    } finally {
                        LOCK_B.unlock();
                    }
                } else {
                    System.out.println("线程2：获取锁B超时，放弃");
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }, "Thread-2").start();
    }
}
```

##### 方法 3：一次性获取所有锁（破坏 “持有并等待”）

通过工具类统一申请所有需要的锁，成功则执行，失败则全部放弃并重试。






```java
import java.util.Collections;
import java.util.List;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class SolveDeadLock3 {
    private static final Lock LOCK_A = new ReentrantLock();
    private static final Lock LOCK_B = new ReentrantLock();

    // 一次性获取所有锁，成功返回true，失败返回false
    private static boolean acquireAllLocks(List<Lock> locks) {
        // 排序锁对象（避免不同线程申请顺序不一致）
        Collections.sort((List<Object>) locks, (a, b) -> System.identityHashCode(a) - System.identityHashCode(b));
        boolean allAcquired = true;
        for (Lock lock : locks) {
            try {
                if (!lock.tryLock(1000, java.util.concurrent.TimeUnit.MILLISECONDS)) {
                    allAcquired = false;
                    break;
                }
            } catch (InterruptedException e) {
                allAcquired = false;
                break;
            }
        }
        // 若有锁未获取到，释放已获取的锁
        if (!allAcquired) {
            for (Lock lock : locks) {
                if (lock.tryLock()) { // 尝试获取（能获取说明已持有）
                    lock.unlock();
                }
            }
        }
        return allAcquired;
    }

    public static void main(String[] args) {
        new Thread(() -> {
            List<Lock> locks = List.of(LOCK_A, LOCK_B);
            if (acquireAllLocks(locks)) {
                try {
                    System.out.println("线程1：成功获取所有锁，执行完成");
                } finally {
                    locks.forEach(Lock::unlock);
                }
            } else {
                System.out.println("线程1：获取锁失败，重试");
            }
        }, "Thread-1").start();

        new Thread(() -> {
            List<Lock> locks = List.of(LOCK_B, LOCK_A); // 申请顺序不同，但工具类会排序
            if (acquireAllLocks(locks)) {
                try {
                    System.out.println("线程2：成功获取所有锁，执行完成");
                } finally {
                    locks.forEach(Lock::unlock);
                }
            } else {
                System.out.println("线程2：获取锁失败，重试");
            }
        }, "Thread-2").start();
    }
}
```

##### 方法 4：使用 LockSupport 中断线程（破坏 “不可剥夺”）

通过 `LockSupport.unpark()` 中断死锁线程，释放已持有锁。









```java
import java.util.concurrent.locks.LockSupport;

public class SolveDeadLock4 {
    private static final Object LOCK_A = new Object();
    private static final Object LOCK_B = new Object();
    private static Thread thread1, thread2;

    public static void main(String[] args) {
        thread1 = new Thread(() -> {
            synchronized (LOCK_A) {
                System.out.println("线程1：已获取锁A，尝试获取锁B...");
                try { Thread.sleep(100); } catch (InterruptedException e) {}
                synchronized (LOCK_B) {
                    System.out.println("线程1：成功获取锁B，执行完成");
                }
            }
        }, "Thread-1");

        thread2 = new Thread(() -> {
            synchronized (LOCK_B) {
                System.out.println("线程2：已获取锁B，尝试获取锁A...");
                try { Thread.sleep(100); } catch (InterruptedException e) {}
                synchronized (LOCK_A) {
                    System.out.println("线程2：成功获取锁A，执行完成");
                }
            }
        }, "Thread-2");

        thread1.start();
        thread2.start();

        // 3秒后检测到死锁，中断线程1（释放锁A）
        new Thread(() -> {
            try { Thread.sleep(3000); } catch (InterruptedException e) {}
            System.out.println("检测到死锁，中断线程1...");
            LockSupport.unpark(thread1); // 中断线程1
            thread1.interrupt();
        }).start();
    }
}
```

##### 方法 5：使用信号量（Semaphore）控制并发

通过信号量限制同时访问资源的线程数，间接避免死锁。






```java
import java.util.concurrent.Semaphore;

public class SolveDeadLock5 {
    private static final Object LOCK_A = new Object();
    private static final Object LOCK_B = new Object();
    // 信号量：最多允许1个线程同时执行（串行化）
    private static final Semaphore SEMAPHORE = new Semaphore(1);

    public static void main(String[] args) {
        new Thread(() -> {
            try {
                SEMAPHORE.acquire(); // 获取信号量（串行执行）
                synchronized (LOCK_A) {
                    System.out.println("线程1：已获取锁A，尝试获取锁B...");
                    try { Thread.sleep(100); } catch (InterruptedException e) {}
                    synchronized (LOCK_B) {
                        System.out.println("线程1：成功获取锁B，执行完成");
                    }
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            } finally {
                SEMAPHORE.release(); // 释放信号量
            }
        }, "Thread-1").start();

        new Thread(() -> {
            try {
                SEMAPHORE.acquire();
                synchronized (LOCK_B) {
                    System.out.println("线程2：已获取锁B，尝试获取锁A...");
                    try { Thread.sleep(100); } catch (InterruptedException e) {}
                    synchronized (LOCK_A) {
                        System.out.println("线程2：成功获取锁A，执行完成");
                    }
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            } finally {
                SEMAPHORE.release();
            }
        }, "Thread-2").start();
    }
}
```

##### 方法 6：减少锁的持有时间

尽量缩短锁的持有范围（如将非核心逻辑移出同步块），降低死锁概率。








```java
public class SolveDeadLock6 {
    private static final Object LOCK_A = new Object();
    private static final Object LOCK_B = new Object();

    public static void main(String[] args) {
        new Thread(() -> {
            synchronized (LOCK_A) {
                System.out.println("线程1：已获取锁A（仅执行核心逻辑）");
                // 核心逻辑（快速执行，不sleep）
            }
            // 非核心逻辑移出同步块（释放锁A后再执行）
            try { Thread.sleep(100); } catch (InterruptedException e) {}
            synchronized (LOCK_B) {
                System.out.println("线程1：已获取锁B，执行完成");
            }
        }, "Thread-1").start();

        new Thread(() -> {
            synchronized (LOCK_B) {
                System.out.println("线程2：已获取锁B（仅执行核心逻辑）");
            }
            try { Thread.sleep(100); } catch (InterruptedException e) {}
            synchronized (LOCK_A) {
                System.out.println("线程2：已获取锁A，执行完成");
            }
        }, "Thread-2").start();
    }
}
```

##### 方法 7：使用无锁编程（如 Atomic 类）

避免使用显式锁，通过 CAS 操作实现线程安全，从根源上杜绝死锁。






```java
import java.util.concurrent.atomic.AtomicInteger;

public class SolveDeadLock7 {
    // 无锁原子类（无需显式锁）
    private static final AtomicInteger COUNT_A = new AtomicInteger(0);
    private static final AtomicInteger COUNT_B = new AtomicInteger(0);

    public static void main(String[] args) {
        // 线程1：操作原子类（无锁）
        new Thread(() -> {
            COUNT_A.incrementAndGet();
            System.out.println("线程1：操作资源A完成，尝试操作资源B...");
            try { Thread.sleep(100); } catch (InterruptedException e) {}
            COUNT_B.incrementAndGet();
            System.out.println("线程1：操作资源B完成，执行完成");
        }, "Thread-1").start();

        // 线程2：操作原子类（无锁）
        new Thread(() -> {
            COUNT_B.incrementAndGet();
            System.out.println("线程2：操作资源B完成，尝试操作资源A...");
            try { Thread.sleep(100); } catch (InterruptedException e) {}
            COUNT_A.incrementAndGet();
            System.out.println("线程2：操作资源A完成，执行完成");
        }, "Thread-2").start();
    }
}
```

##### 方法 8：死锁检测与恢复（JVM 层面）

通过 `jstack` 命令检测死锁，手动重启线程或服务（适用于生产环境应急）：

1. 执行 `jps` 获取 Java 进程 ID；
2. 执行 `jstack 进程ID`，若存在死锁，会输出死锁线程信息；
3. 重启死锁的线程或整个服务。

### 第二道题：手写 HashMap（拉链法解决哈希冲突）

#### 核心设计：

- 数组 + 链表结构（拉链法）：数组存储链表头节点，哈希冲突时元素插入链表尾部；
- 动态扩容：负载因子超过 0.75 时，数组容量翻倍（保证查询效率）；
- 支持 `put`、`get`、`remove` 核心操作。





```java
import java.util.Objects;

public class MyHashMap<K, V> {
    // 默认初始容量（2的幂，便于扩容时哈希重新计算）
    private static final int DEFAULT_INITIAL_CAPACITY = 16;
    // 默认负载因子（扩容阈值 = 容量 * 负载因子）
    private static final float DEFAULT_LOAD_FACTOR = 0.75f;

    // 存储链表的数组（桶数组）
    private Node<K, V>[] table;
    // 元素个数
    private int size;
    // 扩容阈值
    private int threshold;
    // 负载因子
    private final float loadFactor;

    // 链表节点类
    static class Node<K, V> {
        K key;
        V value;
        Node<K, V> next; // 下一个节点（拉链法核心）
        int hash; // 缓存key的哈希值，避免重复计算

        Node(int hash, K key, V value, Node<K, V> next) {
            this.hash = hash;
            this.key = key;
            this.value = value;
            this.next = next;
        }

        // 重写equals和hashCode，用于key比较
        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            Node<?, ?> node = (Node<?, ?>) o;
            return Objects.equals(key, node.key) && Objects.equals(value, node.value);
        }

        @Override
        public int hashCode() {
            return Objects.hash(key, value);
        }
    }

    // 构造方法（默认参数）
    public MyHashMap() {
        this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);
    }

    // 构造方法（自定义容量和负载因子）
    public MyHashMap(int initialCapacity, float loadFactor) {
        if (initialCapacity <= 0) throw new IllegalArgumentException("容量必须大于0");
        if (loadFactor <= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException("负载因子非法");
        this.table = new Node[initialCapacity];
        this.loadFactor = loadFactor;
        this.threshold = (int) (initialCapacity * loadFactor);
        this.size = 0;
    }

    // 核心：计算key的哈希值（减少哈希冲突）
    private int hash(K key) {
        if (key == null) return 0;
        // 二次哈希：扰动函数，让哈希值分布更均匀
        return (key.hashCode() ^ (key.hashCode() >>> 16)) & (table.length - 1);
    }

    // 1. put操作：添加/更新键值对
    public V put(K key, V value) {
        return putVal(hash(key), key, value);
    }

    private V putVal(int hash, K key, V value) {
        Node<K, V>[] tab = table;
        int n = tab.length;
        Node<K, V> p;
        int index;

        // 1. 桶为空，创建新节点作为桶的头节点
        if ((p = tab[index = (n - 1) & hash]) == null) {
            tab[index] = new Node<>(hash, key, value, null);
        } else {
            Node<K, V> e;
            K k;
            // 2. 桶的头节点key与当前key相同，直接更新value
            if (p.hash == hash && ((k = p.key) == key || (key != null && key.equals(k)))) {
                e = p;
            } else {
                // 3. 遍历链表，查找key是否存在
                while ((e = p.next) != null) {
                    if (e.hash == hash && ((k = e.key) == key || (key != null && key.equals(k)))) {
                        break; // 找到相同key，退出循环
                    }
                    p = e; // 移动到下一个节点
                }
                // 4. 链表中无相同key，添加新节点到链表尾部
                if (e == null) {
                    p.next = new Node<>(hash, key, value, null);
                }
            }
            // 5. 存在相同key，更新value并返回旧值
            if (e != null) {
                V oldValue = e.value;
                e.value = value;
                return oldValue;
            }
        }

        // 6. 元素个数+1，判断是否需要扩容
        if (++size > threshold) {
            resize();
        }
        return null;
    }

    // 2. get操作：根据key获取value
    public V get(K key) {
        Node<K, V> node = getNode(hash(key), key);
        return node == null ? null : node.value;
    }

    private Node<K, V> getNode(int hash, K key) {
        Node<K, V>[] tab = table;
        Node<K, V> first, e;
        int n = tab.length;
        K k;

        // 1. 桶不为空，开始查找
        if (tab != null && n > 0 && (first = tab[(n - 1) & hash]) != null) {
            // 2. 检查头节点
            if (first.hash == hash && ((k = first.key) == key || (key != null && key.equals(k)))) {
                return first;
            }
            // 3. 遍历链表查找
            if ((e = first.next) != null) {
                do {
                    if (e.hash == hash && ((k = e.key) == key || (key != null && key.equals(k)))) {
                        return e;
                    }
                } while ((e = e.next) != null);
            }
        }
        return null;
    }

    // 3. remove操作：根据key删除键值对
    public V remove(K key) {
        return removeNode(hash(key), key);
    }

    private V removeNode(int hash, K key) {
        Node<K, V>[] tab = table;
        Node<K, V> p;
        int n, index;
        K k;
        V oldValue = null;

        // 1. 找到桶的位置
        if (tab != null && n > 0 && (p = tab[index = (n - 1) & hash]) != null) {
            Node<K, V> e = null;
            // 2. 头节点是目标节点
            if (p.hash == hash && ((k = p.key) == key || (key != null && key.equals(k)))) {
                e = p;
            } else if ((e = p.next) != null) {
                // 3. 遍历链表查找目标节点
                do {
                    if (e.hash == hash && ((k = e.key) == key || (key != null && key.equals(k)))) {
                        break;
                    }
                    p = e; // 记录前驱节点
                } while ((e = e.next) != null);
            }
            // 4. 找到目标节点，删除并更新链表
            if (e != null) {
                oldValue = e.value;
                if (e == p) { // 目标节点是头节点
                    tab[index] = e.next;
                } else { // 目标节点是链表中间节点
                    p.next = e.next;
                }
                size--; // 元素个数-1
            }
        }
        return oldValue;
    }

    // 动态扩容：数组容量翻倍，重新分配所有元素
    private void resize() {
        Node<K, V>[] oldTab = table;
        int oldCap = oldTab == null ? 0 : oldTab.length;
        int oldThr = threshold;
        int newCap, newThr = 0;

        // 1. 计算新容量（翻倍）
        if (oldCap > 0) {
            if (oldCap >= Integer.MAX_VALUE >>> 1) { // 防止溢出
                threshold = Integer.MAX_VALUE;
                return;
            }
            newCap = oldCap << 1; // 容量翻倍（2的幂）
            newThr = oldThr << 1; // 扩容阈值翻倍
        } else if (oldThr > 0) {
            newCap = oldThr;
        } else {
            newCap = DEFAULT_INITIAL_CAPACITY;
            newThr = (int) (DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR);
        }

        // 2. 创建新桶数组
        Node<K, V>[] newTab = new Node[newCap];
        table = newTab;
        threshold = newThr;

        // 3. 重新分配旧数组中的元素到新数组
        if (oldTab != null) {
            for (int j = 0; j < oldCap; j++) {
                Node<K, V> e;
                if ((e = oldTab[j]) != null) {
                    oldTab[j] = null; // 释放旧数组引用
                    // 遍历链表，重新计算哈希值并放入新桶
                    do {
                        Node<K, V> next = e.next;
                        int newIndex = (newCap - 1) & e.hash; // 新桶位置
                        e.next = newTab[newIndex]; // 头插法（或尾插法，此处用头插）
                        newTab[newIndex] = e;
                        e = next;
                    } while (e != null);
                }
            }
        }
    }

    // 获取元素个数
    public int size() {
        return size;
    }

    // 测试方法
    public static void main(String[] args) {
        MyHashMap<String, Integer> map = new MyHashMap<>();
        map.put("a", 1);
        map.put("b", 2);
        map.put("c", 3);
        System.out.println("size: " + map.size()); // 输出3
        System.out.println("get 'a': " + map.get("a")); // 输出1

        map.put("a", 10); // 更新key="a"的值
        System.out.println("get 'a' after update: " + map.get("a")); // 输出10

        map.remove("b");
        System.out.println("size after remove 'b': " + map.size()); // 输出2
        System.out.println("get 'b': " + map.get("b")); // 输出null
    }
}
```

### 第三道题：手写堆排序（大顶堆实现）

#### 核心原理：

1. 构建大顶堆：将数组调整为 “父节点>= 子节点” 的完全二叉树；
2. 堆排序：每次将堆顶（最大值）与数组末尾元素交换，然后调整剩余元素为大顶堆，重复直至数组有序。






```java
public class HeapSort {
    /**
     * 堆排序入口方法
     * @param arr 待排序数组（原地排序，无额外空间）
     */
    public static void heapSort(int[] arr) {
        if (arr == null || arr.length <= 1) return;
        int n = arr.length;

        // 1. 构建大顶堆（从最后一个非叶子节点开始向前调整）
        // 最后一个非叶子节点索引：n/2 - 1（完全二叉树性质）
        for (int i = n / 2 - 1; i >= 0; i--) {
            adjustHeap(arr, n, i);
        }

        // 2. 堆排序（每次提取堆顶元素，调整堆）
        for (int i = n - 1; i > 0; i--) {
            // 交换堆顶（最大值）和当前数组末尾元素
            swap(arr, 0, i);
            // 调整剩余元素为大顶堆（堆大小变为i，调整根节点）
            adjustHeap(arr, i, 0);
        }
    }

    /**
     * 调整堆：将以i为根的子树调整为大顶堆
     * @param arr 待调整数组
     * @param heapSize 堆的大小（当前有效元素个数）
     * @param i 要调整的根节点索引
     */
    private static void adjustHeap(int[] arr, int heapSize, int i) {
        int largest = i; // 初始化最大值为根节点
        int left = 2 * i + 1; // 左子节点索引
        int right = 2 * i + 2; // 右子节点索引

        // 若左子节点大于根节点，更新最大值索引
        if (left < heapSize && arr[left] > arr[largest]) {
            largest = left;
        }

        // 若右子节点大于当前最大值，更新最大值索引
        if (right < heapSize && arr[right] > arr[largest]) {
            largest = right;
        }

        // 若最大值不是根节点，交换并递归调整子树
        if (largest != i) {
            swap(arr, i, largest);
            // 递归调整被交换的子节点所在的子树
            adjustHeap(arr, heapSize, largest);
        }
    }

    /**
     * 交换数组中两个元素的位置
     */
    private static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }

    // 测试方法
    public static void main(String[] args) {
        int[] arr = {3, 1, 4, 1, 5, 9, 2, 6};
        System.out.println("排序前：");
        for (int num : arr) {
            System.out.print(num + " ");
        }

        heapSort(arr);

        System.out.println("\n排序后：");
        for (int num : arr) {
            System.out.print(num + " ");
        }
    }
}
```

**运行结果**：





```plaintext
排序前：
3 1 4 1 5 9 2 6 
排序后：
1 1 2 3 4 5 6 9 
```

#### 复杂度分析：

- 时间复杂度：O (n log n)（构建堆 O (n)，排序阶段 O (n log n)）；
- 空间复杂度：O (1)（原地排序，仅递归调用栈开销，可优化为迭代实现）；
- 稳定性：不稳定排序（交换过程可能改变相同元素的相对位置）。