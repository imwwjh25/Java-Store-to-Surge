### 一、四种限流算法的 Java 实现

常见的限流算法包括：**固定窗口计数器、滑动窗口计数器、漏桶算法、令牌桶算法**。以下实现均考虑线程安全，适用于高并发场景。

#### 1. 固定窗口计数器（Fixed Window Counter）

**原理**：将时间划分为固定长度的窗口（如 1 秒），每个窗口设置请求阈值；统计窗口内请求数，超过阈值则限流；窗口结束后重置计数器。






```java
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;

/**
 * 固定窗口计数器限流
 */
public class FixedWindowLimiter {
    // 窗口时间（毫秒），如1秒
    private final long windowMs;
    // 窗口最大请求数
    private final int limit;
    // 当前窗口的起始时间
    private final AtomicLong windowStartTime = new AtomicLong(System.currentTimeMillis());
    // 当前窗口的请求计数
    private final AtomicInteger count = new AtomicInteger(0);

    public FixedWindowLimiter(long windowMs, int limit) {
        this.windowMs = windowMs;
        this.limit = limit;
    }

    /**
     * 尝试获取请求许可
     * @return true-允许，false-限流
     */
    public boolean tryAcquire() {
        long now = System.currentTimeMillis();
        // 1. 检查是否进入新窗口，若是则重置计数器和窗口起始时间
        if (now - windowStartTime.get() >= windowMs) {
            // 原子操作，避免并发重置问题
            if (windowStartTime.compareAndSet(windowStartTime.get(), now)) {
                count.set(0);
            }
        }
        // 2. 检查当前窗口请求数是否超过阈值
        return count.incrementAndGet() <= limit;
    }
}
```

#### 2. 滑动窗口计数器（Sliding Window Counter）

**原理**：将固定窗口拆分为更小的时间片（如 1 秒窗口拆分为 10 个 100ms 时间片）；每个时间片有独立计数器；请求时淘汰过期时间片，累加剩余时间片的计数，超过阈值则限流。解决固定窗口的 “临界突发” 问题。






```java
import java.util.LinkedList;
import java.util.Queue;
import java.util.concurrent.locks.ReentrantLock;

/**
 * 滑动窗口计数器限流
 */
public class SlidingWindowLimiter {
    // 总窗口时间（毫秒），如1秒
    private final long totalWindowMs;
    // 窗口拆分的时间片数量（如10个）
    private final int sliceCount;
    // 每个时间片的时长（毫秒）
    private final long sliceMs;
    // 总窗口最大请求数
    private final int limit;
    // 保存时间片的计数和时间戳（线程安全队列）
    private final Queue<Slice> sliceQueue = new LinkedList<>();
    // 保证队列操作的线程安全
    private final ReentrantLock lock = new ReentrantLock();

    // 时间片实体
    private static class Slice {
        long timestamp; // 时间片起始时间
        int count;      // 该时间片的请求数

        Slice(long timestamp, int count) {
            this.timestamp = timestamp;
            this.count = count;
        }
    }

    public SlidingWindowLimiter(long totalWindowMs, int sliceCount, int limit) {
        this.totalWindowMs = totalWindowMs;
        this.sliceCount = sliceCount;
        this.sliceMs = totalWindowMs / sliceCount;
        this.limit = limit;
    }

    public boolean tryAcquire() {
        lock.lock();
        try {
            long now = System.currentTimeMillis();
            // 1. 淘汰过期的时间片（超出总窗口范围的）
            while (!sliceQueue.isEmpty() && now - sliceQueue.peek().timestamp >= totalWindowMs) {
                sliceQueue.poll();
            }
            // 2. 计算当前窗口总请求数
            int totalCount = sliceQueue.stream().mapToInt(s -> s.count).sum();
            // 3. 若未超阈值，更新当前时间片的计数
            if (totalCount < limit) {
                // 找到当前时间片，不存在则新建
                if (sliceQueue.isEmpty() || now - sliceQueue.peek().timestamp >= sliceMs) {
                    sliceQueue.offer(new Slice(now, 1));
                } else {
                    sliceQueue.peek().count++;
                }
                return true;
            }
            return false;
        } finally {
            lock.unlock();
        }
    }
}
```

#### 3. 漏桶算法（Leaky Bucket）

**原理**：请求如同 “水滴” 进入漏桶，漏桶以固定速率 “漏水”（处理请求）；桶满时新请求被拒绝；核心是**控制输出速率**，平滑突发流量。









```java
import java.util.concurrent.atomic.AtomicLong;

/**
 * 漏桶算法限流
 */
public class LeakyBucketLimiter {
    // 桶的容量（最大可积累的请求数）
    private final int capacity;
    // 漏出速率（每秒处理的请求数）
    private final double leakRate;
    // 最后一次漏水的时间戳（毫秒）
    private final AtomicLong lastLeakTime = new AtomicLong(System.currentTimeMillis());
    // 当前桶内的水量（未处理的请求数）
    private final AtomicLong water = new AtomicLong(0);

    public LeakyBucketLimiter(int capacity, double leakRate) {
        this.capacity = capacity;
        this.leakRate = leakRate;
    }

    public boolean tryAcquire() {
        long now = System.currentTimeMillis();
        // 1. 先计算从上次到现在漏出的水量，更新桶内剩余水量
        long lastTime = lastLeakTime.get();
        double elapsedSec = (now - lastTime) / 1000.0;
        long leakedWater = (long) (elapsedSec * leakRate);
        if (leakedWater > 0) {
            // 原子更新剩余水量（避免并发覆盖）
            water.getAndUpdate(w -> Math.max(0, w - leakedWater));
            lastLeakTime.set(now);
        }
        // 2. 检查桶是否已满，未满则加水（+1）
        long currentWater = water.get();
        if (currentWater < capacity) {
            water.incrementAndGet();
            return true;
        }
        return false;
    }
}
```

#### 4. 令牌桶算法（Token Bucket）

**原理**：令牌桶以固定速率生成令牌并放入桶中，桶有最大容量；请求到来时需获取令牌，有令牌则处理，无则限流；支持突发流量（桶内令牌可积累）。




```java
import java.util.concurrent.atomic.AtomicLong;

/**
 * 令牌桶算法限流
 */
public class TokenBucketLimiter {
    // 桶的最大容量（最多可积累的令牌数）
    private final long capacity;
    // 令牌生成速率（每秒生成的令牌数）
    private final double tokenRate;
    // 最后一次生成令牌的时间戳（毫秒）
    private final AtomicLong lastTokenTime = new AtomicLong(System.currentTimeMillis());
    // 当前桶内的令牌数
    private final AtomicLong tokens = new AtomicLong(0);

    public TokenBucketLimiter(long capacity, double tokenRate) {
        this.capacity = capacity;
        this.tokenRate = tokenRate;
    }

    public boolean tryAcquire() {
        long now = System.currentTimeMillis();
        // 1. 补充令牌：计算上次到现在应生成的令牌数，更新桶内令牌
        long lastTime = lastTokenTime.get();
        double elapsedSec = (now - lastTime) / 1000.0;
        long newTokens = (long) (elapsedSec * tokenRate);
        if (newTokens > 0) {
            // 原子更新，避免并发补充令牌冲突
            if (lastTokenTime.compareAndSet(lastTime, now)) {
                tokens.getAndUpdate(t -> Math.min(capacity, t + newTokens));
            }
        }
        // 2. 尝试获取令牌（减1）
        return tokens.get() > 0 && tokens.decrementAndGet() >= 0;
    }
}
```

### 二、算法优缺点与适用场景对比

| 算法类型       | 优点                                                         | 缺点                                                         | 适用场景                                                   |
| -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ---------------------------------------------------------- |
| 固定窗口计数器 | 实现极简，内存 / CPU 开销极低；逻辑清晰                      | 临界突发问题（窗口切换时请求叠加超限）；限流不平滑           | 对限流精度要求低、流量平稳的场景（如普通接口限流）         |
| 滑动窗口计数器 | 解决固定窗口的临界问题；限流更平滑                           | 实现较复杂；需维护时间片，有一定内存开销                     | 对限流精度有要求、流量有小幅波动的场景（如 API 网关）      |
| 漏桶算法       | 严格控制输出速率；彻底平滑突发流量；防止后端过载             | 无法处理合理的突发流量（即使后端有能力）；配置不当易导致性能浪费 | 需严格控制请求输出速率的场景（如对接第三方 API、网络限流） |
| 令牌桶算法     | 支持突发流量（令牌积累）；灵活性高；可限制平均速率 + 允许峰值 | 实现稍复杂；需合理配置令牌速率和桶容量                       | 大多数限流场景（如秒杀接口、高并发接口、网关限流）         |

### 三、核心总结

1. **简单场景选固定窗口**：若系统对限流精度要求低，优先选固定窗口，开发 / 维护成本最低；
2. **精度要求选滑动窗口**：需要避免临界突发问题时，滑动窗口是固定窗口的最优改进；
3. **严格控速选漏桶**：对接外部系统、需严格遵守 QPS 限制时，漏桶是最佳选择；
4. **通用场景选令牌桶**：秒杀、高并发接口等需要允许合理突发流量的场景，令牌桶是工业界主流方案（如 Guava 的 RateLimiter 就是基于令牌桶）。

### 四、测试示例








```java
public class LimiterTest {
    public static void main(String[] args) throws InterruptedException {
        // 测试令牌桶（1秒生成10个令牌，桶容量20）
        TokenBucketLimiter limiter = new TokenBucketLimiter(20, 10);
        for (int i = 0; i < 30; i++) {
            System.out.println("第" + (i+1) + "次请求：" + limiter.tryAcquire());
            Thread.sleep(50);
        }
    }
}
```