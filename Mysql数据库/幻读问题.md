核心结论：MySQL 默认隔离级别 **可重复读（RR）** 通过「MVCC 多版本并发控制」和「next-key 锁」部分解决幻读，但在 **跨版本写 + 读、快照读与当前读混用、批量更新未命中索引** 这三类场景下，仍可能出现幻读。

### 先明确核心前提

1. 幻读的定义：同一事务内，两次执行相同的范围查询（如 `WHERE id BETWEEN 1 AND 10`），第二次查询返回了第一次未出现的 “新数据”（被其他事务插入），或丢失了第一次存在的 “旧数据”（被其他事务删除），导致结果集不一致。
2. RR 隔离级别的防幻读机制：
   - 快照读（普通 `SELECT`）：通过 MVCC 读取事务启动时的 “数据快照”，不感知其他事务后续插入 / 删除的数据，避免基础幻读；
   - 当前读（`SELECT ... FOR UPDATE`/`SELECT ... LOCK IN SHARE MODE`、`UPDATE`/`DELETE`）：通过 next-key 锁（行锁 + 间隙锁）锁定查询范围及间隙，阻止其他事务在该范围插入新数据，避免 “插入型幻读”。

但上述机制存在覆盖盲区，以下场景仍会触发幻读：

### 场景 1：快照读与当前读混用（最常见）

同一事务内，先执行「快照读」（普通 `SELECT`），再执行「当前读」（加锁查询 / 更新），当前读会感知其他事务插入的新数据，导致两次查询结果不一致。

#### 示例（事务 A 为测试事务，事务 B 为干扰事务）

| 时间顺序 | 事务 A（RR 隔离级别）                                        | 事务 B（RR 隔离级别）                                        |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 1        | 开启事务：`START TRANSACTION;`                               | 开启事务：`START TRANSACTION;`                               |
| 2        | 快照读（普通查询）：`SELECT * FROM user WHERE id BETWEEN 1 AND 10;`结果：仅返回 id=1、2、3 的数据 |                                                              |
| 3        |                                                              | 插入新数据：`INSERT INTO user(id, name) VALUES (4, '小明');`提交事务：`COMMIT;` |
| 4        | 当前读（加锁查询）：`SELECT * FROM user WHERE id BETWEEN 1 AND 10 FOR UPDATE;`结果：返回 id=1、2、3、4 的数据 |                                                              |

#### 幻读原因：

- 步骤 2 的快照读依赖 MVCC，读取的是事务 A 启动时的快照（无 id=4）；
- 步骤 4 的当前读会忽略快照，直接读取数据库最新数据（包含事务 B 插入的 id=4）；
- 同一事务内两次相同范围查询，结果集行数变化，触发幻读。

### 场景 2：跨版本写 + 读（事务内更新后，快照读升级为当前读）

同一事务内，先执行快照读，再更新查询范围内的 “旧数据”，更新后再次执行快照读时，会升级为当前读，感知其他事务插入的新数据。

#### 示例

| 时间顺序 | 事务 A（RR 隔离级别）                                        | 事务 B（RR 隔离级别）                                     |
| -------- | ------------------------------------------------------------ | --------------------------------------------------------- |
| 1        | `START TRANSACTION;`                                         | `START TRANSACTION;`                                      |
| 2        | 快照读：`SELECT * FROM user WHERE id BETWEEN 1 AND 10;`结果：id=1、2、3 |                                                           |
| 3        |                                                              | `INSERT INTO user(id, name) VALUES (4, '小明');``COMMIT;` |
| 4        | 更新旧数据：`UPDATE user SET name='小红' WHERE id=3;`（更新成功） |                                                           |
| 5        | 再次快照读：`SELECT * FROM user WHERE id BETWEEN 1 AND 10;`结果：id=1、2、3（已更新）、4（新数据） |                                                           |

#### 幻读原因：

- 事务 A 在步骤 4 执行更新操作后，MVCC 快照会 “失效”（或说事务状态变为 “已修改数据”）；
- 步骤 5 的快照读会自动升级为当前读，读取最新数据（包含事务 B 插入的 id=4），导致两次查询结果不一致。

### 场景 3：批量更新未命中索引（间隙锁失效，允许插入新数据）

当 `UPDATE`/`DELETE` 语句的 `WHERE` 条件未命中索引时，next-key 锁会退化为「表锁」，但表锁仅阻止全表更新 / 删除，不阻止 “插入新数据” 到查询范围，导致后续查询出现幻读。

#### 示例（user 表未给 `age` 字段建索引）

| 时间顺序 | 事务 A（RR 隔离级别）                                        | 事务 B（RR 隔离级别）                                        |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 1        | `START TRANSACTION;`                                         | `START TRANSACTION;`                                         |
| 2        | 批量更新（未命中索引）：`UPDATE user SET name='小李' WHERE age=20;`（假设当前无 age=20 的数据，更新 0 行） |                                                              |
| 3        |                                                              | 插入新数据（age=20）：`INSERT INTO user(id, name, age) VALUES (4, '小明', 20);``COMMIT;` |
| 4        | 范围查询：`SELECT * FROM user WHERE age=20;`结果：返回 id=4 的数据（事务 A 步骤 2 未感知，步骤 4 突然出现） |                                                              |

#### 幻读原因：

- `age` 无索引，事务 A 的 `UPDATE` 语句无法使用行锁 / 间隙锁，退化为表锁；
- 表锁仅阻止其他事务更新 / 删除表中已有数据，但允许插入新数据（插入操作不冲突）；
- 事务 A 步骤 2 的更新未影响任何数据，步骤 4 的查询感知到事务 B 插入的新数据，触发幻读。

### 场景 4：删除数据后，其他事务插入相同范围数据（当前读未覆盖间隙）

事务 A 删除某范围数据后，若 next-key 锁未完全覆盖该范围的 “间隙”，其他事务可插入新数据，事务 A 再次查询时会出现幻读。

#### 示例（user 表 id 为自增主键，存在 id=1、3、5 的数据，间隙为 (1,3)、(3,5)、(5, +∞)）

| 时间顺序 | 事务 A（RR 隔离级别）                                        | 事务 B（RR 隔离级别）                                        |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 1        | `START TRANSACTION;`                                         | `START TRANSACTION;`                                         |
| 2        | 删除 id=3 的数据：`DELETE FROM user WHERE id=3;`             |                                                              |
| 3        |                                                              | 插入 id=4 的数据（落在间隙 (3,5)）：`INSERT INTO user(id, name) VALUES (4, '小明');``COMMIT;` |
| 4        | 范围查询：`SELECT * FROM user WHERE id BETWEEN 1 AND 5 FOR UPDATE;`结果：返回 id=1、4、5（id=4 是新插入的，事务 A 步骤 2 删除后未存在，步骤 4 突然出现） |                                                              |

#### 幻读原因：

- 事务 A 删除 id=3 时，next-key 锁锁定的是 (1,3] 范围（行锁 + 间隙锁），但未锁定 (3,5) 间隙；
- 事务 B 可在 (3,5) 间隙插入 id=4 的数据；
- 事务 A 步骤 4 的当前读会感知到该新数据，导致结果集出现 “幻读数据”。

### 核心总结：RR 隔离级别幻读的本质

RR 级别的防幻读机制是「快照读靠 MVCC 隔离版本，当前读靠 next-key 锁锁定范围」，但这两种机制无法覆盖所有场景：

- 当快照读与当前读混用，或事务内写操作导致快照失效，会突破 MVCC 的隔离；
- 当 next-key 锁因 “无索引退化为表锁” 或 “未覆盖全部间隙”，会允许其他事务插入新数据；
- 最终导致同一事务内两次范围查询结果不一致，触发幻读。

### 如何彻底解决幻读？

- 升级隔离级别到「串行化（Serializable）」：完全禁止并发，事务串行执行，从根本上避免幻读（但性能损耗大）；
- 确保当前读覆盖全范围：所有范围查询 / 更新都使用 `SELECT ... FOR UPDATE`（当前读），且 `WHERE` 条件命中索引，让 next-key 锁完全锁定查询范围及间隙；
- 避免快照读与当前读混用：同一事务内，若需多次执行范围查询，统一使用当前读（加锁查询）。
