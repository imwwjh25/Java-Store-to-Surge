在 Java 虚拟机（JVM）中，局部变量表（Local Variable Table）是方法栈帧（Stack Frame）的重要组成部分，其内容、内存大小及确定时机如下：

### **一、局部变量表中存放什么？**

局部变量表用于存储方法执行过程中所需的局部变量，具体包括：

1. **方法参数**：包括实例方法中的隐含参数 `this`（静态方法无 `this`），以及显式声明的形参。
2. **方法内部声明的局部变量**：包括基本数据类型（`boolean`、`byte`、`short`、`char`、`int`、`long`、`float`、`double`）和引用类型（对象引用、数组引用等）。
3. **临时变量**：编译器可能会为某些操作（如表达式计算）隐式生成临时变量，也会存储在局部变量表中。

需要注意：

- 基本数据类型直接存储值，引用类型存储的是对象在堆中的地址（或句柄）。
- `long` 和 `double` 是 64 位类型，会占用局部变量表中的 **2 个连续槽位（Slot）**，其他类型（包括引用类型）占用 1 个槽位。

### **二、局部变量表的内存大小如何确定？**

局部变量表的内存大小以 **槽位（Slot）** 为基本单位（1 个 Slot 通常为 32 位），其总槽位数量由方法的 **编译期常量** 决定，具体规则：

1. 编译器在编译 Java 源码为字节码（`.class` 文件）时，会计算该方法所需的最大局部变量槽位数量，并将其存储在方法的 **Code 属性** 中（`max_locals` 字段）。

2. 槽位数量取决于方法参数数量、局部变量数量及类型（是否包含```long```/```double```）。例如：

- 一个无参实例方法，至少包含 1 个槽位（`this`）。
- 一个接收 `int` 和 `long` 两个参数的方法，参数需占用 1 + 2 = 3 个槽位（`this` + `int` + `long`），若方法内再声明一个 `String` 变量，总槽位可能为 4（`String` 占 1 个槽位）。

### **三、局部变量表的内存大小什么时候确定？**

局部变量表的槽位数量（即内存大小）在 **编译阶段** 就已确定，具体来说：

- 当 Java 编译器将源码编译为字节码时，会分析方法的参数、局部变量的声明和使用情况，计算出该方法所需的最大槽位数量，并写入 `.class` 文件的 `max_locals` 字段中。
- 运行时，JVM 加载类后，在方法被调用并创建栈帧时，会根据 `max_locals` 的值直接分配对应大小的局部变量表内存（无需动态计算）。

因此，局部变量表的内存大小是 **编译期确定，运行期直接使用** 的常量值，不会随方法执行过程动态变化。

总结：局部变量表存储方法参数和局部变量，其内存大小（槽位数量）由编译器在编译时计算并写入字节码，运行时 JVM 依据该值分配内存，全程大小固定。
