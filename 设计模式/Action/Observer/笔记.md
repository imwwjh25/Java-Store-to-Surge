### 一、为什么需要观察者模式？

先看痛点场景：

- 你开发一个股票行情系统，`Stock`类存储股票价格，需要让多个模块（行情面板、预警模块、日志模块）实时获取价格变化；
- 若用硬编码实现：`Stock`类中直接调用各模块的更新方法，新增 / 删除模块时必须修改`Stock`代码，耦合度极高；
- 模块之间也会因直接依赖变得难以维护。

观察者模式的解决思路：将`Stock`设计为被观察者，各模块作为观察者注册到`Stock`，价格变化时`Stock`主动通知所有观察者，新增模块只需实现观察者接口即可，无需修改`Stock`。

### 二、观察者模式的核心结构

观察者模式包含 4 个核心角色：

1. **抽象被观察者（Subject）**：定义注册、移除观察者，以及通知观察者的接口；
2. **具体被观察者（Concrete Subject）**：维护观察者列表，状态变化时触发通知；
3. **抽象观察者（Observer）**：定义更新方法（接收被观察者的状态变化）；
4. **具体观察者（Concrete Observer）**：实现更新方法，处理被观察者的通知。

### 三、完整代码实现（股票行情场景）

#### 1. 抽象观察者（Observer）






```
// 抽象观察者：定义更新方法
public interface Observer {
    /**
     * 接收被观察者的通知并更新
     * @param stockName 股票名称
     * @param price 最新价格
     */
    void update(String stockName, double price);
}
```

#### 2. 具体观察者（Concrete Observer）








```
// 具体观察者1：行情面板（显示最新价格）
public class PriceDisplayObserver implements Observer {
    @Override
    public void update(String stockName, double price) {
        System.out.println("【行情面板】" + stockName + "最新价格：" + price + "元");
    }
}

// 具体观察者2：价格预警（价格超过阈值时提醒）
public class PriceAlertObserver implements Observer {
    private double threshold; // 预警阈值

    public PriceAlertObserver(double threshold) {
        this.threshold = threshold;
    }

    @Override
    public void update(String stockName, double price) {
        if (price > threshold) {
            System.out.println("【价格预警】" + stockName + "价格超过阈值" + threshold + "，当前：" + price + "元");
        }
    }
}

// 具体观察者3：日志记录（记录价格变化）
public class LogObserver implements Observer {
    @Override
    public void update(String stockName, double price) {
        System.out.println("【日志记录】" + stockName + "价格更新：" + price + "元，时间：" + System.currentTimeMillis());
    }
}
```

#### 3. 抽象被观察者（Subject）








```
import java.util.List;

// 抽象被观察者：定义观察者管理和通知接口
public interface Subject {
    // 注册观察者
    void registerObserver(Observer observer);
    // 移除观察者
    void removeObserver(Observer observer);
    // 通知所有观察者
    void notifyObservers();
}
```

#### 4. 具体被观察者（Concrete Subject）








```
import java.util.ArrayList;
import java.util.List;

// 具体被观察者：股票（维护价格状态，管理观察者）
public class Stock implements Subject {
    private String stockName; // 股票名称
    private double price;     // 当前价格
    // 观察者列表
    private List<Observer> observerList = new ArrayList<>();

    public Stock(String stockName, double initialPrice) {
        this.stockName = stockName;
        this.price = initialPrice;
    }

    // 模拟价格变化（核心：状态变化后通知观察者）
    public void setPrice(double newPrice) {
        if (this.price != newPrice) {
            this.price = newPrice;
            // 价格变化，通知所有观察者
            notifyObservers();
        }
    }

    @Override
    public void registerObserver(Observer observer) {
        observerList.add(observer);
    }

    @Override
    public void removeObserver(Observer observer) {
        observerList.remove(observer);
    }

    @Override
    public void notifyObservers() {
        // 遍历所有观察者，调用更新方法
        for (Observer observer : observerList) {
            observer.update(stockName, price);
        }
    }

    // 获取当前价格（辅助方法）
    public double getPrice() {
        return price;
    }
}
```

#### 5. 客户端使用示例








```
public class ObserverPatternDemo {
    public static void main(String[] args) {
        // 1. 创建被观察者：茅台股票（初始价格1800元）
        Stock maotaiStock = new Stock("贵州茅台", 1800.0);

        // 2. 创建观察者并注册
        Observer priceDisplay = new PriceDisplayObserver();
        Observer priceAlert = new PriceAlertObserver(1850.0); // 阈值1850元
        Observer log = new LogObserver();

        maotaiStock.registerObserver(priceDisplay);
        maotaiStock.registerObserver(priceAlert);
        maotaiStock.registerObserver(log);

        // 3. 模拟价格变化：触发通知
        System.out.println("===== 价格更新为1820元 =====");
        maotaiStock.setPrice(1820.0);

        System.out.println("\n===== 价格更新为1860元 =====");
        maotaiStock.setPrice(1860.0);

        // 4. 移除预警观察者，再次更新价格
        System.out.println("\n===== 移除预警观察者，价格更新为1870元 =====");
        maotaiStock.removeObserver(priceAlert);
        maotaiStock.setPrice(1870.0);
    }
}
```

**输出结果**：




```
===== 价格更新为1820元 =====
【行情面板】贵州茅台最新价格：1820.0元
【日志记录】贵州茅台价格更新：1820.0元，时间：1739880000000

===== 价格更新为1860元 =====
【行情面板】贵州茅台最新价格：1860.0元
【价格预警】贵州茅台价格超过阈值1850.0，当前：1860.0元
【日志记录】贵州茅台价格更新：1860.0元，时间：1739880001000

===== 移除预警观察者，价格更新为1870元 =====
【行情面板】贵州茅台最新价格：1870.0元
【日志记录】贵州茅台价格更新：1870.0元，时间：1739880002000
```

### 四、Java 内置的观察者模式（Observable + Observer）

Java 提供了现成的`java.util.Observable`（被观察者）和`java.util.Observer`（观察者），可直接使用（注意：Java 9 后已标记为过时，推荐自定义实现）：







```
import java.util.Observable;
import java.util.Observer;

// 具体被观察者：继承Observable
class JdkStock extends Observable {
    private String stockName;
    private double price;

    public JdkStock(String stockName, double price) {
        this.stockName = stockName;
        this.price = price;
    }

    public void setPrice(double newPrice) {
        if (this.price != newPrice) {
            this.price = newPrice;
            setChanged(); // 标记状态已变化
            notifyObservers(new Object[]{stockName, price}); // 通知观察者并传递数据
        }
    }
}

// 具体观察者：实现Observer
class JdkPriceDisplay implements Observer {
    @Override
    public void update(Observable o, Object arg) {
        Object[] data = (Object[]) arg;
        String stockName = (String) data[0];
        double price = (double) data[1];
        System.out.println("【JDK观察者】" + stockName + "价格：" + price);
    }
}

// 使用示例
public class JdkObserverDemo {
    public static void main(String[] args) {
        JdkStock stock = new JdkStock("宁德时代", 200.0);
        stock.addObserver(new JdkPriceDisplay());
        stock.setPrice(205.0); // 输出：【JDK观察者】宁德时代价格：205.0
    }
}
```

### 五、观察者模式的核心特点

#### 优点：

1. **解耦性高**：被观察者和观察者无直接依赖，新增 / 删除观察者无需修改被观察者；
2. **实时响应**：被观察者状态变化时，观察者能立即收到通知并更新；
3. **符合开闭原则**：扩展新的观察者只需实现接口，无需改动原有代码；
4. **一对多通信**：一个被观察者可通知多个观察者，简化多模块联动逻辑。

#### 缺点：

1. **通知顺序问题**：默认按注册顺序通知，若观察者之间有依赖，顺序可能影响结果；
2. **内存泄漏风险**：若观察者未被正确移除（如匿名内部类持有外部类引用），会导致内存泄漏；
3. **性能问题**：观察者过多时，通知过程可能耗时，需考虑异步通知；
4. **循环依赖风险**：观察者更新时若修改被观察者状态，可能触发重复通知。

### 六、观察者模式 vs 发布 - 订阅模式（易混淆的区别）

很多人将两者等同，但严格来说发布 - 订阅是观察者模式的升级版：







|   维度   |               观察者模式               |                       发布 - 订阅模式                        |
| :------: | :------------------------------------: | :----------------------------------------------------------: |
|  耦合度  | 被观察者直接持有观察者引用（耦合较高） | 引入 “消息队列 / 经纪人”，发布者和订阅者无直接引用（解耦更彻底） |
| 通信方式 | 同步通知（被观察者主动调用观察者方法） |                   异步通知（通过消息队列）                   |
| 适用场景 |        进程内、低延迟的简单联动        |            跨进程、分布式系统（如 MQ、消息推送）             |
|   示例   |  股票行情、GUI 组件事件（如按钮点击）  |   RabbitMQ/Kafka 消息推送、微信公众号（实际是发布 - 订阅）   |

### 总结

1. **核心思想**：观察者模式实现 “一对多” 的联动，核心是 “状态变化自动通知”，解耦被观察者和观察者；

2. 适用场景 ：

    - 一个对象状态变化需要通知多个其他对象；
    - 通知的对象列表不固定（需动态添加 / 移除）；
    - 希望被观察者和观察者独立扩展，互不影响；



3. 实现关键 ：

    - 被观察者维护观察者列表，提供注册 / 移除 / 通知接口；
    - 观察者实现统一的更新方法，接收被观察者的状态；
    - 状态变化时必须触发通知（如`setPrice`中调用`notifyObservers`）；



4. 优化建议 ：

    - 观察者过多时，采用**异步通知**（线程池）避免阻塞；
    - 谨慎处理观察者的异常，防止一个观察者报错导致整个通知流程中断；
    - 及时移除无用的观察者，避免内存泄漏。

   