Redis 协议（RESP，Redis Serialization Protocol）是 **二进制安全的文本协议**，设计目标是「简单易实现、可读性强、高效传输」，被 Redis 用于客户端与服务器之间的所有通信（命令发送、结果返回）。

核心特点：

- 基于「类型标记 + 数据长度 + 数据内容 + 终止符」的结构；
- 支持字符串、整数、数组、错误、空值 5 种数据类型；
- 每行以 `\r\n`（CRLF）作为终止符，避免粘包问题。

## 一、核心数据类型与协议格式

RESP 用「首字符」标记数据类型，后续紧跟数据长度（可选）、数据内容，最终以 `\r\n` 结束。以下是 5 种核心类型的格式细节：

### 1. 简单字符串（Simple String）

- **用途**：返回简单结果（如 `OK`、`PONG`），二进制安全（但不支持换行符）；

- **格式**：`+` + 字符串内容 + `\r\n`；

- 示例 ：

    - 服务器返回成功：`+OK\r\n`
    - 心跳响应：`+PONG\r\n`

### 2. 错误（Error）

- **用途**：返回错误信息（如 `ERR invalid command`）；

- **格式**：`-` + 错误类型（可选） + 空格 + 错误描述 + `\r\n`；

- 示例 ：

    - 命令不存在：`-ERR unknown command 'hello'\r\n`
    - 类型错误：`-WRONGTYPE Operation against a key holding the wrong kind of value\r\n`

### 3. 整数（Integer）

- **用途**：返回计数、状态码等整数结果（如 `DEL` 命令的删除个数、`EXISTS` 的存在标识）；

- **格式**：`:` + 整数数值 + `\r\n`；

- 示例 ：

    - 删除 2 个键：`:2\r\n`
    - 键存在（`EXISTS key`）：`:1\r\n`
    - 键不存在：`:0\r\n`

### 4. 批量字符串（Bulk String）

- **用途**：存储任意二进制数据（如字符串、序列化对象），支持换行符，是最常用的类型（键、值多为批量字符串）；

- 格式 ：

    1. `$` + 数据字节长度（`-1` 表示空值 `null`） + `\r\n`；
    2. 数据内容（长度与第一步一致） + `\r\n`；

- 示例 ：

    - 存储字符串 `redis`（字节长度 5）：`$5\r\nredis\r\n`
    - 存储空字符串（长度 0）：`$0\r\n\r\n`
    - 键不存在（返回 `null`）：`$-1\r\n`（Redis 中称为 `nil`）

### 5. 数组（Array）

- **用途**：传递命令（客户端→服务器）或返回多元素结果（如 `MGET`、`LRANGE`）；

- 格式 ：

    1. `*` + 数组元素个数（`-1` 表示空数组） + `\r\n`；
    2. 后续紧跟每个元素的 RESP 编码（元素类型可不同）；

- 示例 ：

    - 客户端发送命令```SET name tom```（3 个元素：```SET```、```name```、```tom```）：

    
    

    


    

```plaintext
    *3\r\n        # 数组长度 3
    $3\r\nSET\r\n # 第一个元素：批量字符串 "SET"（长度 3）
    $4\r\nname\r\n# 第二个元素：批量字符串 "name"（长度 4）
    $3\r\ntom\r\n # 第三个元素：批量字符串 "tom"（长度 3）
```



- 服务器返回```MGET name age```结果（```name=tom```，```age=20```）：

    
    

    

    

    

    

```plaintext
    *2\r\n        # 数组长度 2
    $3\r\ntom\r\n # 第一个元素："tom"
    $2\r\n20\r\n  # 第二个元素："20"
```


- 返回空数组：`*-1\r\n`

## 二、关键场景：命令发送与结果返回流程

以「客户端执行 `SET user:1 "张三"` 并获取结果」为例，完整展示协议交互过程：

### 1. 客户端→服务器：发送命令（数组格式）

命令 `SET user:1 "张三"` 拆分为 3 个元素，按数组格式编码：

plaintext











```plaintext
*3\r\n                # 数组长度 3
$3\r\nSET\r\n         # 命令名 "SET"（长度 3）
$6\r\nuser:1\r\n      # 键 "user:1"（长度 6）
$6\r\n张三\r\n        # 值 "张三"（UTF-8 编码，3 个汉字占 6 字节）
```

### 2. 服务器→客户端：返回结果（简单字符串）

命令执行成功，返回简单字符串 `OK`：

plaintext











```plaintext
+OK\r\n
```

### 另一个场景：执行 `GET user:1`（返回批量字符串）

- 客户端发送命令：`*2\r\n$3\r\nGET\r\n$6\r\nuser:1\r\n`

- 服务器返回结果（值为 "张三"，UTF-8 编码 6 字节）：

  plaintext











  ```plaintext
  $6\r\n张三\r\n
  ```



## 三、特殊情况处理

### 1. 空值与空数组

- 空值（`nil`）：用批量字符串 `$-1\r\n` 表示（如 `GET 不存在的键`）；
- 空数组：用 `*-1\r\n` 表示（如 `LRANGE 空列表 0 -1`）。

### 2. 二进制安全

批量字符串支持任意二进制数据（如图片、序列化的 Java 对象），只需正确指定「字节长度」即可，Redis 不会解析数据内容。例如存储一张 1024 字节的图片：

plaintext











```plaintext
$1024\r\n[图片二进制数据]\r\n
```

### 3. 换行符处理

- 协议终止符固定为 `\r\n`（CRLF），不能用 `\n` 单独替代；
- 若数据内容中包含 `\r` 或 `\n`，批量字符串仍可正常存储（只需按实际字节长度编码）。

## 四、协议设计优势

1. **简单易实现**：无需复杂解析逻辑，按「首字符 + 长度」即可拆分数据；

2. **高效**：长度前缀避免遍历数据找终止符，减少 IO 开销；

3. **二进制安全**：支持任意数据（包括不可打印字符）；

4. 可读性强

   ：文本协议，可通过



   ```
   telnet
   ```



直接调试（示例如下）：



   ```bash
   telnet 127.0.0.1 6379
   *3\r\n$3\r\nSET\r\n$4\r\nname\r\n$3\r\ntom\r\n  # 输入命令
   +OK\r\n                                       # 服务器响应
   *2\r\n$3\r\nGET\r\n$4\r\nname\r\n             # 输入 GET 命令
   $3\r\ntom\r\n                                 # 服务器返回结果
   ```



## 五、总结

Redis 协议（RESP）的核心是「类型标记 + 长度前缀 + CRLF 终止」，通过 5 种数据类型覆盖所有通信场景：

- 客户端发送命令：用「数组」编码；
- 服务器返回结果：根据结果类型选择「简单字符串 / 错误 / 整数 / 批量字符串 / 数组」。

理解协议格式后，即使不依赖 Redis 客户端库，也能手动构造命令与 Redis 通信（如通过 Socket 发送编码后的字节流），这也是 Redis 协议设计的灵活性所在。