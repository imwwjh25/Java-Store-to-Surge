NIO（Non-blocking I/O，非阻塞 IO）和 BIO（Blocking I/O，阻塞 IO）是 Java 中两种核心 IO 模型，核心区别在于 **线程对 IO 操作的等待方式**：BIO 是 “线程阻塞等待 IO 完成”，NIO 是 “线程非阻塞等待，可同时处理多个 IO”。但 NIO 并非一定比 BIO 好，二者适用场景不同，需结合并发量、IO 类型（读写频率）选择。

## 一、NIO 与 BIO 的核心区别（从 5 个维度拆解）

| 对比维度        | BIO（阻塞 IO）                                               | NIO（非阻塞 IO）                                             |
| --------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **线程模型**    | 一连接一线程：每个 IO 连接（如 Socket）对应一个独立线程，线程阻塞等待 IO 完成（如数据读取、连接建立）。 | 多路复用：一个线程通过 **Selector（选择器）** 同时监听多个 IO 连接，仅当 IO 就绪（如数据到达）时才处理，线程不阻塞。 |
| **IO 等待方式** | 阻塞：线程调用 `read()`/`write()` 后，会一直阻塞到 IO 操作完成（如数据读完、写成功），期间无法做其他事。 | 非阻塞：线程调用 `read()`/`write()` 时，若 IO 未就绪（如无数据），会立即返回 `0` 或 `-1`，线程可继续处理其他连接的 IO。 |
| **核心组件**    | 无特殊组件，依赖 `Socket`/`InputStream`/`OutputStream` 等基础类。 | 三大核心组件：- **Channel（通道）**：双向 IO 操作载体（替代 BIO 的流）；- **Buffer（缓冲区）**：数据读写的容器（BIO 是字节流，NIO 是缓冲块）；- **Selector（选择器）**：监听多个 Channel 的 IO 就绪事件。 |
| **并发能力**    | 低：线程数量与连接数成正比，大量连接会导致线程爆炸（上下文切换、内存占用高），支持并发量通常在百级。 | 高：一个线程可处理数千甚至数万连接，并发能力取决于 Selector 的效率，支持并发量可达万级。 |
| **编程复杂度**  | 低：逻辑直观，线程与连接一一对应，无需处理多路复用和非阻塞逻辑。 | 高：需理解 Selector 事件监听、Buffer 读写、Channel 状态管理，还需处理 “IO 就绪但数据未读完” 等边缘场景。 |

## 二、NIO 并非一定比 BIO 好：适用场景决定优劣

NIO 的 “高并发” 优势是有前提的，在 **低并发、IO 密集且读写频繁** 的场景下，BIO 反而更简单、高效；只有在 **高并发、IO 稀疏（大部分连接长期无数据）** 的场景下，NIO 才更优。

### 1. 场景 1：低并发、IO 读写频繁 → BIO 更优

当连接数少（如几十到几百），且每个连接的 IO 操作频繁（如频繁发送 / 接收数据）时，BIO 的 “一连接一线程” 模型更简单，且性能不逊于 NIO：

- **例子**：本地文件拷贝工具、小型 TCP 服务（如设备间点对点通信，连接数固定为 10）。

- 原因：

    - NIO 的 Selector 存在 “事件轮询” 开销（线程需不断检查 Channel 是否就绪），若每个连接都频繁有数据，轮询开销会抵消 “多路复用” 的优势；
    - BIO 无需处理非阻塞逻辑和缓冲管理，代码更简洁，调试成本低；
    - 低并发下，线程数量少（如 100 个线程），上下文切换和内存占用可忽略，性能接近 NIO。

### 2. 场景 2：高并发、IO 稀疏 → NIO 更优

当连接数多（如数千到数万），且大部分连接长期无数据（IO 稀疏，如长连接服务、物联网设备连接）时，NIO 的 “多路复用” 优势会被放大：

- **例子**：IM 后台服务（同时在线 10 万用户，大部分用户长期不发消息）、Web 服务器（Nginx 底层是 IO 多路复用，Java 中 Tomcat 8+ 的 NIO 模式）、物联网平台（连接 100 万设备，设备每 10 分钟发一次数据）。

- 原因：

    - BIO 若处理 10 万连接，需 10 万线程，内存占用会超过 100GB（每个线程默认栈大小 1MB），且上下文切换频繁（CPU 利用率 100% 但实际处理效率低）；
    - NIO 用 10 个线程即可处理 10 万连接，线程资源占用极少，仅在 IO 就绪时才处理数据，CPU 利用率高。

### 3. 场景 3：IO 密集 vs CPU 密集 → 无绝对优劣

- IO 密集（如文件读写、网络传输）：



若并发高，NIO 更优（减少线程阻塞）；若并发低，BIO 更简单。

- CPU 密集（如 IO 后需大量计算，如数据加密、解析）：



无论 NIO 还是 BIO，都需额外线程池处理计算（避免阻塞 IO 线程），此时二者差异不大，BIO 因编程简单反而更易维护。

## 三、关键反例：NIO 不如 BIO 的情况

举一个具体场景，说明 NIO 并非更优：**需求**：开发一个 “本地视频转码工具”，功能是读取一个大视频文件（10GB），转码后写入新文件。

- **BIO 实现**：用一个线程读取文件（`FileInputStream`），一个线程转码，一个线程写入文件（`FileOutputStream`），逻辑清晰，无需处理非阻塞和缓冲切换；
- **NIO 实现**：需用 `FileChannel` 读取数据到 `ByteBuffer`，转码后再写入 `FileChannel`，还需处理 “Buffer 满 / 空”“Channel 读写状态” 等逻辑，代码复杂度高，且因视频文件读写频繁，Selector 轮询开销反而增加了耗时，最终性能与 BIO 持平甚至更低。

## 四、总结：如何选择 NIO 还是 BIO？

1. 看并发量：

    - 低并发（连接数 < 1000）→ 优先选 BIO（简单、低开销）；
    - 高并发（连接数 ≥ 1000）→ 必须选 NIO（节省线程资源，支撑高并发）。

2. 看 IO 稀疏度：

    - IO 频繁（如文件拷贝、高频数据传输）→ 低并发用 BIO，高并发用 NIO；
    - IO 稀疏（如长连接、低频率数据传输）→ 无论并发高低，优先选 NIO。

3. 看开发成本：

    - 小型工具、简单服务 → 选 BIO（降低开发和调试成本）；
    - 企业级高并发服务 → 选 NIO（或基于 NIO 的框架，如 Netty）。

一句话概括：**NIO 的优势体现在 “高并发 + IO 稀疏” 场景，BIO 在 “低并发 + IO 频繁” 场景下更简单高效，二者无绝对优劣，只有 “场景适配”**。
