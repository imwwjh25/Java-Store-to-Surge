我们先明确 ZSet 的核心场景：比如排行榜（按分数排序取 Top N）、延迟队列（按时间戳范围查询）、范围统计（取分数在 [min, max] 之间的元素），这些场景需要同时满足：

1. 插入 / 删除 / 单元素查询：效率接近 O (log n)；
2. 范围查询（最关键）：高效遍历连续区间（如从第 k 名到第 m 名）；
3. 内存开销可控：Redis 是内存数据库，空间利用率不能太低；
4. 实现简单：避免复杂逻辑导致的 bug 或性能损耗。

下面分别对比跳表 vs B+ 树、跳表 vs 红黑树，拆解选择逻辑：

### 一、为什么不选 B+ 树？



B+ 树的核心优势是 **磁盘场景的范围查询**（如数据库索引），但在 Redis 的内存场景下，劣势完全暴露：

#### 1. B+ 树的设计初衷是适配磁盘，而非内存



B+ 树的结构是 “多叉树 + 叶子节点链表”：

- 多叉结构是为了 “降低树高”，减少磁盘 I/O 次数（磁盘 I/O 是数据库的性能瓶颈）；
- 叶子节点用链表串联，是为了方便范围查询（遍历链表即可）。

但 Redis 是 **内存数据库**，内存访问速度比磁盘快几个数量级，“降低树高” 的优势完全没用 —— 反而多叉结构会带来额外开销：

- 每个节点要存储多个关键字和子节点指针，结构比跳表 / 红黑树复杂，内存开销更大；
- 插入 / 删除时，需要维护多叉节点的关键字排序和子节点指针，逻辑比跳表复杂，效率更低。

#### 2. 内存中范围查询，跳表比 B+ 树更高效



B+ 树的范围查询依赖叶子节点的链表，但叶子节点是 “离散存储” 的（非连续内存），遍历链表时仍会有多次内存跳转；而跳表的范围查询是 “分层索引 + 链表”，一旦通过索引定位到范围起点，直接沿着最底层的有序链表遍历即可，无需跳转其他节点，内存访问更连续，遍历效率更高。

#### 3. 动态更新成本高



B+ 树是 “有序多叉树”，插入 / 删除元素时，可能需要拆分 / 合并节点（比如节点关键字满了要拆分，少了要合并），整个过程涉及多个节点的调整，逻辑复杂，时间开销比跳表大。

#### 结论：B+ 树是 “磁盘优化型” 结构，在内存场景下，既没有优势，又有结构复杂、内存开销大的问题，完全不适合 ZSet。



### 二、为什么不选红黑树？



红黑树和跳表的时间复杂度理论上一致（插入 / 删除 / 查询都是 O (log n)），但红黑树的 **范围查询效率极低**，这是 ZSet 放弃它的核心原因：

#### 1. 红黑树的致命短板：范围查询麻烦



红黑树是 “二叉搜索树”，虽然有序，但没有天然的 “连续遍历结构”：

- 要实现 “查询分数在 [min, max] 之间的所有元素”，步骤是：
    1. 先通过二分查找找到 min 对应的节点（O (log n)）；
    2. 再依次查找每个节点的 “中序后继节点”（即下一个有序元素），直到超过 max。

问题在于：**红黑树的中序后继节点查找，不是 O (1) 操作**—— 需要从当前节点向上回溯父节点，或向下查找右子树的最左节点，最坏情况下每次查找后继都要 O (log n)，如果范围包含 k 个元素，总时间就是 O (k log n)。

而跳表的范围查询是 O (log n + k)：

- 先通过分层索引找到范围起点（O (log n)）；
- 再沿着最底层的有序链表，依次取 k 个元素（O (k)），无需额外的查找操作，效率远高于红黑树。

#### 2. 红黑树的实现和维护成本更高



红黑树需要遵守 5 个平衡规则，插入 / 删除时要通过 “旋转” 和 “颜色调整” 来维持平衡，逻辑非常复杂（代码量是跳表的几倍）：

- 容易出现 bug（比如平衡调整逻辑出错，导致树失衡，效率退化为 O (n)）；
- 维护成本高（比如修改红黑树的节点结构，需要联动调整平衡逻辑）。

而跳表的实现极其简单：

- 核心结构是 “分层链表”，插入时通过 “随机数” 决定节点的层数（保证索引的随机性），删除时直接删除对应节点的所有层索引，无需平衡调整；
- 代码简洁易懂，调试和维护成本低，Redis 作为高性能数据库，需要避免复杂逻辑带来的性能损耗或 bug。

#### 3. 并发场景的适配性



Redis 虽然是单线程，但跳表的并发友好性比红黑树好（这是额外优势）：

- 跳表的插入 / 删除操作是 “局部性” 的，仅涉及当前节点和其前后节点的索引调整，不会影响全局结构；
- 红黑树的平衡调整可能涉及多个节点（比如旋转操作会影响父节点、祖父节点），并发修改时需要更大范围的锁，不利于并发扩展（虽然 Redis 单线程用不上，但跳表的设计更灵活）。

#### 4. 空间开销的权衡



红黑树的空间开销是 O (n)（每个节点仅需额外存储 1 bit 的颜色标记），比跳表的 O (n) 略小（跳表需要存储多层索引，通常额外开销是 50%~100%），但这一点优势被范围查询的劣势完全抵消：

- ZSet 的核心场景是范围查询（如排行榜、范围统计），空间开销的微小差距，远不如查询效率重要；
- 跳表的索引开销可以通过 “调整层数概率” 控制（比如 Redis 中跳表的层数上限是 64，默认每层概率是 1/4），实际空间开销完全在可接受范围内。

### 三、跳表适配 ZSet 的核心总结



ZSet 选择跳表，是因为跳表完美匹配了它的核心需求，而 B+ 树、红黑树都存在无法克服的短板：

| 对比维度        | 跳表                    | 红黑树                    | B+ 树                     |
| --------------- | ----------------------- | ------------------------- | ------------------------- |
| 单元素查询      | O(log n)                | O(log n)                  | O(log n)                  |
| 范围查询        | O (log n + k)（高效）   | O (k log n)（低效）       | O (log n + k)（适配磁盘） |
| 插入 / 删除效率 | O (log n)（简单）       | O (log n)（复杂）         | O (log n)（复杂）         |
| 实现维护成本    | 极低                    | 极高                      | 中高                      |
| 空间开销        | 中等（索引）            | 低（仅颜色）              | 高（多叉节点）            |
| 适配场景        | 内存有序结构 + 范围查询 | 内存有序结构 + 单元素操作 | 磁盘有序结构 + 范围查询   |

最终结论：

- B+ 树是 “磁盘优化” 的产物，内存中无优势；
- 红黑树的范围查询效率太差，无法满足 ZSet 的核心场景；
- 跳表在 “单元素操作效率、范围查询效率、实现复杂度” 三者之间达到了最佳平衡，是 ZSet 的最优选择。