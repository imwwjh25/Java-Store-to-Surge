Git 的冲突检测核心是**基于文件内容的行级差异对比**，结合版本树的上下文（提交历史、分支关系），判断多分支 / 多提交对同一文件的修改是否存在 “不可自动合并” 的重叠，其原理可拆解为核心逻辑、对比规则、冲突判定三部分：

### 一、核心前提：找到 “共同祖先”

Git 合并 / 拉取时，首先会找到两个待合并版本（比如分支 A 和分支 B）的**最近共同祖先版本（Base）** —— 这是冲突检测的 “基准线”。

- 例如：你在分支 `feature` 修改了文件 `README.md`，同事在 `main` 也改了同一文件，Git 会先找到 `feature` 和 `main` 从哪个提交（Base）分叉，再以这个 Base 版本为参照，对比两个分支的修改。

### 二、核心逻辑：三路差分对比（3-way diff）

Git 不是直接对比两个待合并版本（比如 A 和 B），而是通过**三路对比**判断修改是否冲突，这是冲突检测的核心：

1. **对比对象**：Base（共同祖先）、Local（本地当前版本）、Remote（待合并的远程 / 其他分支版本）；

2. **对比维度**：以 “行” 为最小单位，逐行分析文件内容的增删改；

3. 对比过程 ：

    - 先找出 Base 和 Local 的差异（你改了哪些行）；
    - 再找出 Base 和 Remote 的差异（对方改了哪些行）；
    - 最后判断这两组差异是否 “重叠” 或 “冲突”。

### 三、冲突判定规则

只有当两组差异（Local vs Base、Remote vs Base）满足以下条件时，Git 才会标记冲突，否则会自动合并：

#### 1. 冲突的核心条件：修改区域重叠 / 冲突

- **行级重叠**：同一行（或连续多行）在 Local 和 Remote 中都被修改，且修改内容不同；例：

    - Base 版本的第 5 行：`price = 100`

    - Local 版本的第 5 行：`price = 150`

    - Remote 版本的第 5 行：```price = 200 ```



    → Git 无法判断该保留 150 还是 200，标记冲突。

- **范围交叉**：修改的行范围有交集（即使不是同一行）；例：

    - Local 删除了第 3-5 行，Remote 修改了第 4 行；



    → 因为 Remote 修改的行被 Local 删除，范围交叉，标记冲突。

- **结构冲突**：比如 Local 给函数加了参数，Remote 调用该函数时未适配参数（但 Git 无法识别语法逻辑，仅能检测行级重叠，这类逻辑冲突需人工判断）。

#### 2. 可自动合并的场景（无冲突）

- 仅一方修改：Local 改了第 5 行，Remote 未改；或反之；
- 修改区域不重叠：Local 改了第 5 行，Remote 改了第 10 行；
- 内容完全一致：Local 和 Remote 对同一行的修改内容相同（比如都把 `price = 100` 改成 `price = 200`）。

### 四、冲突标记的格式

当检测到冲突时，Git 会在文件中插入冲突标记，明确区分不同版本的内容：











```plaintext
<<<<<<< HEAD （Local/当前分支版本）
price = 150
======= （分隔符）
price = 200
>>>>>>> feature （Remote/待合并分支版本）
```

- `<<<<<<< HEAD` 到 `=======` 之间是本地修改；
- `=======` 到 `>>>>>>> [分支名]` 之间是待合并版本的修改；
- 需人工删除标记并调整内容后，重新提交。

### 五、补充：冲突检测的边界

1. **最小单位是 “行”**：Git 不检测字符级差异，只要整行内容一致，即使修改位置在同一行的不同字符（比如 `a=1` 改 `a=2` vs `a=1` 改 `b=1`），也会判定为冲突；
2. **不识别语义 / 逻辑**：Git 仅对比文本内容，无法判断修改的逻辑是否冲突（比如两个分支都给同一变量赋值，语法上无行重叠，但逻辑上冲突，Git 会自动合并，需人工校验）；
3. **文件名 / 路径变更**：如果一个分支重命名文件 `A.txt` 为 `B.txt`，另一个分支修改 `A.txt`，Git 会判定为冲突（文件身份识别冲突）。

### 总结

Git 冲突检测的本质是：以 “共同祖先版本” 为基准，通过三路行级文本对比，判断多版本对同一文件的修改区域是否重叠 / 冲突，仅对文本内容负责，不处理语义逻辑，冲突需人工介入解决。