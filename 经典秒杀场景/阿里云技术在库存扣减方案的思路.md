## 来自



**来自阿里云开发者【公众号】 - 2026/1/4的文章**

### 一、方案背景：传统优化遇瓶颈，热点场景迫需新方案



1. 前置优化基础

   库存团队已完成多轮优化：数据库内核优化 → 应用层优化 → 扣减架构升级，显著提升了常规库存 DB 扣减性能。

2. 核心矛盾

   直播业务催生 高频热点深库存扣减场景 ，传统方案只能通过 限流保护 DB ，但限流会导致用户体验下降，库存扣减成为下单链路瓶颈。

3. 传统 Redis 分桶方案的局限性

   文章调研指出传统 Redis 分桶扣减方案的三大问题，这也是新方案的核心优化目标：

   | 痛点                | 具体表现                                              | 业务影响                                         |
      | ------------------- | ----------------------------------------------------- | ------------------------------------------------ |
   | 无法避免少卖        | Redis 操作超时 / 失败时，应用层默认扣减失败、回补成功 | 实物库存场景不允许数据有损                       |
   | 不支持复杂库存模型  | 仅通过 `incr/decr` 维护单一数值库存                   | 无法适配 `sq(可售)-wq(预扣)-oq(占用)` 的复杂流转 |
   | 强依赖 Redis 稳定性 | Redis 异常则整个扣减链路瘫痪                          | 高可用风险不可控                                 |

### 二、核心设计思路：Redis 做计数屏障，DB 做最终一致性存储



新方案的核心是**分离 Redis 和 DB 的职责**，打破 “Redis 直接存储库存” 的传统模式，实现 “不超卖、不少卖、高性能” 的三重目标：

1. **Redis 角色**：仅作为**扣减计数屏障**，防止超卖，不承担库存存储职责；

2. **DB 角色**：通过**扣减明细**和**库存字段**保证最终一致性，明细是库存流转的唯一依据；

3. 关键链路



   ```
   DB 预锁库存(lq) → Redis 分桶初始化计数 → 下单扣减 Redis → 插入 DB 扣减明细 → 延迟合并提交 DB 库存变更
   ```



### 三、核心模块实现：分模块拆解，各司其职



文章将方案拆分为 **5 个核心模块**，每个模块解决特定问题，逻辑闭环：

#### 1. 锁库存模块：预锁库存，隔离热点流量



这是方案的**基石设计**，核心是将 DB 中的可售库存 `sq` 预锁到 `lq`（预锁库存），实现两大目标：**不影响库存展示** + **为 Redis 分桶提供计数基数**。

- 核心操作

  ① 锁库存不是

  ```sq -= x, lq += x```，而是直接```lq += x```，```sq```保持不变；

② 查询可售库存时无需关心```lq```，展示链路无感知，降低复杂度；

③ 锁定的```lq```数量同步到 Redis 分桶，作为扣减计数的上限。

- 关键约束 DB 最终扣减时通过```where sq - lq - δq > 0```保证可售库存不会被超扣，从底层防止超卖。

#### 2. 下单扣减模块：Redis 快速拦截，DB 明细兜底



核心是**先 Redis 快速扣减，再 DB 明细落地**，保证扣减的高性能和可追溯。

- 核心流程

  ① 下单时优先扣减 Redis 分桶库存，扣减成功 → 插入 DB 扣减明细（明细是幂等、回溯的依据）；

  ② Redis 扣减失败 → 降级走老的 DB 扣减流程，保证链路可用性。

- 分桶设计

  采用 Redis 分桶分散热点压力，多个分桶通过索引管理，避免单 Redis 实例瓶颈。

#### 3. 合并提交模块：延迟合并，批量更新 DB



这是**提升 DB 性能的关键**，通过**延迟 1s 扫描明细、批量扣减**，将高频单次扣减转化为低频批量操作。

- 核心流程

  ① 失效对应 Redis 分桶，防止后续流量继续扣减；

  ② 扫描分桶关联的扣减明细，通过

  覆盖索引 `(invId, lockOrderId, quantity)`快速```sum(quantity)```，计算实际扣减总量；

③ 批量执行 DB 库存变更：```sq = sq - 总扣减量```。

- 性能优化点

  覆盖索引让```sum(quantity)```走索引扫描，避免全表查询，压测验证对 DB 影响极小。

#### 4. 库存回收模块：释放冗余锁库存，避免资源浪费



针对**商家编辑、临界库存**等场景，回收预锁的 `lq` 库存，释放回 `sq`。

- 回收场景

  ① 商家编辑库存为 0 时，需先释放```lq```；

② Redis 分桶库存不足但 DB 仍有库存时，回收 Redis 剩余计数对应的```lq```，继续扣减。

- **实现方式**：直接复用合并提交逻辑，无需额外开发，降低复杂度。

#### 5. 自动锁库存模块：提前识别热点，主动防御



通过**热点识别能力**（感知交易系统的热点品查询），提前对高风险商品锁库存，避免流量峰值时锁库存不及时导致的瓶颈。

- **关键逻辑**：只要触发一次自动锁库存，后续下单会持续触发锁库存，形成闭环。

### 四、防超卖 / 少卖设计：三层保障，数据零有损



这是方案的**核心亮点**，通过**DB 约束、Redis 屏障、并发防护**三层机制，解决分布式场景下的数据一致性问题：

1. DB 层防超卖

   最终扣减 SQL 携带条件```where sq - lq - δq > 0```，确保可售库存永远大于 0，从数据库层面杜绝超卖。

2. Redis 层防超卖

   Redis 分桶扣减时设置下限，确保库存不会减到负数，作为前置屏障。

3. 防止少卖与并发风险

   ① 少卖防护：Redis 数据丢失时，以 DB 扣减明细的```sum(quantity)```为准，重新计算实际扣减量；

② 并发防护：下单扣减与合并提交并发时，可能出现明细扫描遗漏，通过

Redis 扣减屏障

拦截，避免超卖（文章未展开屏障细节，推测是通过 Redis 分布式锁或版本号防止并发冲突）。

### 五、性能效果：TPS 提升 1 倍以上，稳定性显著增强



方案的效果通过**压测**和**线上**两个维度验证，数据支撑充分：

| 指标           | 非合并扣减 | 合并扣减 | 提升效果      |
| -------------- | ---------- | -------- | ------------- |
| 压测 TPS       | 1.4w       | 3.2w     | 提升 128%+    |
| 线上扣减成功率 | 80% 左右   | 100%     | 无失败请求    |
| 线上接口耗时   | 15ms+      | 7ms+     | 耗时降低 50%+ |

### 六、方案优势与适用场景



1. 核心优势
    - **强一致性**：通过 DB 明细和 SQL 约束，杜绝超卖 / 少卖，适配实物库存场景；
    - **高性能**：Redis 分桶分散热点，合并提交降低 DB 压力，TPS 提升 1 倍以上；
    - **高可用**：Redis 异常时降级走 DB 流程，无强依赖；
    - **兼容性强**：支持 `sq-wq-oq` 复杂库存模型，覆盖多业务场景。
2. 适用场景
    - 高并发热点深库存抢购（如直播带货、秒杀）；
    - 对库存一致性要求高的实物商品场景；
    - 需要支持复杂库存流转模型的业务。

### 总结



该方案的**核心创新点**在于**重新定义了 Redis 和 DB 在库存扣减中的角色**：将 Redis 从 “库存存储” 降级为 “计数屏障”，将 DB 明细作为 “最终一致性依据”，通过**预锁库存、延迟合并、明细兜底**三大设计，既解决了传统 Redis 方案的痛点，又实现了性能与一致性的平衡。对于分布式系统中的热点资源扣减场景，具有很强的借鉴意义。