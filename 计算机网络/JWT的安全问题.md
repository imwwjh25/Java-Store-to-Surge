JWT 在网络传输中面临的核心安全风险集中在**数据泄露、篡改、重放攻击**三类，网络层面的防护需围绕 “加密传输”“防篡改验证”“限制滥用” 三个核心目标展开。

### 一、JWT 传输中的核心安全风险

#### 1. 传输过程中的数据泄露风险

JWT 由**Header（头部）、Payload（载荷）、Signature（签名）** 三部分组成，其中 Header 和 Payload 仅用 Base64 编码（非加密），本质是明文转换。

- 风险表现：若通过**HTTP 明文传输**，攻击者可通过抓包（如 Wireshark）直接解码获取 Payload 中的敏感信息（如用户 ID、权限、过期时间），导致身份信息泄露。
- 典型场景：未配置 HTTPS 的网站，用户登录后 JWT 通过 HTTP 头传输，被中间人拦截解码。

#### 2. 签名失效与数据篡改风险

JWT 的安全性依赖于 Signature 的有效性：签名由 Header+Payload + 密钥（Secret 或公钥 / 私钥）生成，用于验证数据未被篡改。

- 风险表现 1：**弱密钥 / 密钥泄露**。若使用简单密钥（如 “123456”）或密钥被泄露，攻击者可伪造 Header 和 Payload，用泄露的密钥重新生成签名，伪造合法 JWT。
- 风险表现 2：**算法降级攻击**。Header 中会指定签名算法（如 HS256、RS256），若服务端未严格校验算法，攻击者可将算法改为 “none”（无签名），直接提交无签名的 JWT，绕过身份验证。

#### 3. 重放攻击风险

JWT 一旦生成，在过期时间（Payload 中的`exp`字段）内均有效，且默认不绑定客户端环境。

- 风险表现：攻击者通过抓包获取合法 JWT 后，可在过期前重复使用该 Token 模拟合法用户请求（如重复提交转账、越权访问），无需重新登录。
- 典型场景：公共 Wi-Fi 环境下，攻击者拦截用户的 JWT，在 Token 过期前用其访问用户的个人中心。

#### 4. Token 过期与刷新机制漏洞

为平衡安全性和用户体验，JWT 通常会设置较短的过期时间，并配合 “刷新 Token”（Refresh Token）机制延长会话。

- 风险表现 1：**刷新 Token 泄露**。若刷新 Token 通过明文传输或存储不当，攻击者可利用其无限获取新的访问 JWT，长期控制账户。
- 风险表现 2：**无过期时间限制**。若 Payload 中未设置`exp`字段，JWT 将永久有效，一旦泄露则风险持续存在。

### 二、网络层面的防护措施

#### 1. 强制使用 HTTPS，加密传输链路

这是最基础也是最关键的防护手段，通过 TLS/SSL 协议对传输层数据加密，防止中间人抓包和解码。

- 具体操作：
    - 服务端配置 HTTPS（部署 SSL 证书，推荐 TLS 1.2+，禁用不安全的 SSLv3、TLS 1.0/1.1）；
    - 客户端请求时强制使用 HTTPS，避免 HTTP 降级（可通过 HSTS 协议实现，告知浏览器仅用 HTTPS 访问）；
    - 确保 JWT 在 HTTPS 的`Authorization`头（如`Bearer <token>`）中传输，而非 URL 参数（URL 可能被日志记录，增加泄露风险）。

#### 2. 增强 JWT 签名安全性，防篡改

通过强化签名机制，确保 JWT 无法被伪造或篡改。

- 具体操作：
    - **使用非对称加密算法**：优先选择 RS256（RSA-SHA256）、ES256（ECC-SHA256）等非对称算法，私钥仅保存在服务端（用于签名），公钥对外公开（用于验证），避免对称算法（HS256）的密钥泄露风险；
    - **严格校验签名算法**：服务端接收 JWT 后，必须校验 Header 中的算法是否与预期一致，拒绝 “none” 算法或未配置的算法；
    - **定期轮换密钥**：即使使用非对称算法，也需定期更新公钥 / 私钥（如每 3 个月），降低密钥泄露后的风险影响范围。

#### 3. 限制 JWT 的使用范围，防重放

通过绑定客户端环境、缩短有效期、记录 Token 状态，减少重放攻击的可能性。

- 具体操作：
    - **设置短有效期**：访问 JWT 的过期时间（`exp`）建议设为 15~30 分钟，降低泄露后的可用窗口；
    - **绑定客户端标识**：在 Payload 中加入客户端唯一标识（如设备 ID、浏览器 User-Agent 哈希值），服务端验证 Token 时需匹配当前客户端标识，防止 Token 在其他设备上复用；
    - **维护 Token 黑名单**：若支持 JWT 主动注销（如用户登出），服务端需维护一个短期黑名单（如 Redis 缓存），记录已注销但未过期的 Token，验证时拦截黑名单中的 Token。

#### 4. 优化刷新 Token 机制，降低长期风险

针对刷新 Token 的安全性做特殊防护，避免其成为漏洞突破口。

- 具体操作：
    - **刷新 Token 单独加密传输**：刷新 Token 的有效期可设为 7~30 天，但必须通过 HTTPS 传输，且存储在客户端的`HttpOnly`+`Secure`Cookie 中（避免前端 JS 读取，防止 XSS 攻击窃取）；
    - **限制刷新次数与频率**：同一刷新 Token 最多允许刷新 5 次（或其他合理次数），超过次数后强制重新登录；同时限制刷新频率（如 1 分钟内最多 1 次），防止暴力刷新；
    - **刷新 Token 一次性有效**：每次用刷新 Token 获取新的访问 JWT 时，同时生成新的刷新 Token，旧刷新 Token 立即失效，避免重复使用。

#### 5. 减少 Payload 中的敏感信息

从源头降低泄露后的风险，避免在 JWT 中存储敏感数据。

- 具体操作：
    - Payload 仅存储非敏感的身份标识（如用户 ID、角色编码），不存储密码、手机号、银行卡号等敏感信息；
    - 若需获取敏感数据，通过 JWT 验证身份后，从服务端数据库 / 缓存中查询，而非直接嵌入 Token。

### 三、补充：非网络层面的辅助防护

除网络传输外，客户端存储 JWT 的安全性也需关注，可配合网络措施形成完整防护：

- 客户端避免将 JWT 存储在`localStorage`/`sessionStorage`（易被 XSS 攻击窃取），优先存储在`HttpOnly`+`Secure`+`SameSite=Strict`的 Cookie 中；
- 服务端开启 CSRF 防护（如验证`Referer`头、使用 CSRF Token），防止攻击者利用用户浏览器中的 Cookie（存储的 JWT）发起跨站请求。
