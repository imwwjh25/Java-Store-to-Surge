### 一、Java 类加载器与类加载机制（含双亲委托）

Java 类加载的核心是「通过类加载器将.class 文件（字节码）加载到 JVM 内存，转化为 Class 对象」，整个过程遵循固定机制，双亲委托是其核心设计原则。

#### 1. 类加载器的分类（JDK8 及之前，最经典）

JVM 默认提供 3 层类加载器，自上而下形成层级关系（非继承关系，是组合依赖）：

| 类加载器                                    | 作用范围                                                     | 加载路径（核心）                                             |
| ------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 启动类加载器（Bootstrap ClassLoader）       | 加载 JVM 核心类库（Java 基础类，如`java.lang.String`、`java.util.ArrayList`） | JAVA_HOME/jre/lib（如 rt.jar、charsets.jar），仅加载文件名符合 JVM 识别规则的 jar 包 |
| 扩展类加载器（Extension ClassLoader）       | 加载 JVM 扩展类库（用户可扩展的基础类，非核心但常用）        | JAVA_HOME/jre/lib/ext（系统扩展目录） + 系统属性`java.ext.dirs`指定的目录 |
| 应用程序类加载器（Application ClassLoader） | 加载用户自定义的类（项目代码、第三方依赖 jar 包）            | 系统属性`java.class.path`指定的路径（即 classpath，含项目编译目录、lib 目录等） |

⚠️ 补充：

- 启动类加载器由 **C/C++ 实现**（非 Java 类），无对应的 Java 对象（`Class.getClassLoader()`返回`null`）；
- 扩展类加载器（`ExtClassLoader`）和应用类加载器（`AppClassLoader`）均继承自`java.lang.ClassLoader`，由 Java 实现。

#### 2. 类加载的完整流程（生命周期）

一个类从加载到卸载，需经历 5 个阶段（核心是前 3 个）：












```plaintext
加载（Loading）→ 验证（Verification）→ 准备（Preparation）→ 解析（Resolution）→ 初始化（Initialization）
```

- **加载（核心第一步）**：类加载器根据类的全限定名（如`com.example.User`），找到对应的.class 文件，读取字节码，在 JVM 内存中创建`Class`对象（存储类的元信息）。

- **验证**：校验字节码的合法性（如是否符合 JVM 规范、是否有安全漏洞），避免恶意字节码攻击。

- **准备**：为类的静态变量分配内存，并设置「默认初始值」（如`static int a = 10` → 初始值 0，`10`在初始化阶段赋值）。

- **解析**：将类中的符号引用（如`String`）转化为直接引用（内存地址）。

- 初始化 ：执行类的静态代码块（```static {}```）和静态变量的显式赋值（如```a = 10```），触发条件包括：

    1. 首次创建类的实例（`new User()`）；
    2. 调用类的静态方法 / 静态变量；
    3. 子类初始化时（会先初始化父类）。

#### 3. 双亲委托机制（核心设计原则）

##### （1）定义

当一个类加载器收到类加载请求时，**不会先自己加载，而是先委托给父加载器尝试加载**；只有父加载器无法加载（找不到对应的.class 文件）时，子加载器才会自己尝试加载。

##### （2）加载流程（以加载`com.example.User`为例）

1. 应用类加载器（子）收到请求，先委托给父加载器 → 扩展类加载器；
2. 扩展类加载器收到请求，再委托给父加载器 → 启动类加载器；
3. 启动类加载器在自己的加载路径（jre/lib）中查找`com.example.User.class`，找不到 → 返回加载失败；
4. 扩展类加载器收到父加载器失败的反馈，在自己的加载路径（jre/lib/ext）中查找，找不到 → 返回加载失败；
5. 应用类加载器收到反馈，在自己的加载路径（classpath）中查找，找到后加载，创建`Class`对象。

##### （3）核心目的（3 个）

1. **避免类重复加载**：同一类（全限定名相同）只能被一个类加载器加载一次。若没有双亲委托，应用类加载器和启动类加载器可能分别加载`java.lang.String`，导致 JVM 中存在多个`String`类，破坏类的唯一性。
2. **保护核心类库安全**：防止用户自定义恶意类覆盖核心类。例如，用户不能自定义`java.lang.String`（启动类加载器会优先加载核心库的`String`，子加载器无法再加载同名类）。
3. **统一类加载优先级**：核心类（如 JDK 基础类）由顶层加载器加载，确保所有应用共享同一套核心类，避免兼容性问题。

### 二、为什么要有「扩展类加载器」这一层？

这是面试的核心考点，核心答案是：**「解耦核心类与扩展类，既保护核心库的稳定性，又提供灵活的扩展能力」**，具体拆解为 3 点：

#### 1. 隔离核心类库与扩展类，避免核心库被污染

- 启动类加载器加载的是 JVM 运行必需的「核心类库」（如`java.lang`、`java.util`），这些类是 JVM 的基础，绝对不能被修改或覆盖；
- 扩展类库（如`javax.swing`、`com.sun.*`相关类）是对核心类的补充，虽常用但非 JVM 运行必需，且可能需要更新 / 扩展（如用户添加自定义扩展类）；
- 若没有扩展类加载器，这些扩展类只能要么放在核心库路径（污染核心库，风险高），要么放在应用 classpath（与用户代码混在一起，管理混乱）。
- 扩展类加载器单独负责扩展类的加载，既隔离了核心类和扩展类，又避免了扩展类对核心库的干扰。

#### 2. 提供「无需修改应用代码」的扩展能力

用户可通过「添加扩展 jar 包到扩展目录」，无需修改应用的 classpath，即可让 JVM 自动加载扩展类，实现功能扩展：

- 示例：若用户需要使用某个自定义的加密扩展类，只需将对应的 jar 包放入`JAVA_HOME/jre/lib/ext`目录，扩展类加载器会自动加载该类，应用程序可直接使用（无需导入依赖、修改配置）；
- 这种机制让 Java 平台具备了灵活的「插件式扩展」能力，适合开发通用工具、中间件等需要全局可用的扩展功能。

#### 3. 简化类加载的层级管理，明确职责边界

类加载器的层级设计遵循「单一职责原则」：

- 启动类加载器：只负责核心类库（最小必要集合），保证 JVM 基础功能；
- 扩展类加载器：只负责扩展类库（补充功能集合），提供灵活扩展；
- 应用类加载器：只负责用户代码（业务功能集合），隔离不同应用；
- 若没有扩展类加载器，扩展类的加载职责会落到应用类加载器上，导致应用类加载器既要处理业务代码，又要处理系统扩展类，职责混乱，且可能出现类加载冲突（如用户代码与扩展类同名）。

### 三、补充：JDK9 及之后的变化（面试加分）

JDK9 引入了「模块系统（Module System）」，对类加载机制做了调整，但扩展类加载器的核心作用仍在：

1. 原扩展类加载器（`ExtClassLoader`）被重命名为「平台类加载器（Platform ClassLoader）」；
2. 加载路径不再局限于`ext`目录，还包括 JDK 的平台模块（如`java.se`、`java.xml`）；
3. 核心目的不变：仍为隔离核心模块与扩展模块，提供灵活的扩展能力，同时适配模块系统的模块化加载需求。

### 四、核心总结

1. 类加载器的核心层级：启动类加载器（核心类）→ 扩展类加载器（扩展类）→ 应用类加载器（用户类）；
2. 双亲委托机制：先委托父加载器加载，失败后自身加载，目的是避免类重复、保护核心类安全；
3. 扩展类加载器的存在意义：隔离核心类与扩展类（防污染）、提供插件式扩展能力（免修改代码）、明确职责边界（简化管理）。

记住一句话：**「扩展类加载器是核心类库的‘保镖’，也是应用扩展的‘桥梁’」**。
