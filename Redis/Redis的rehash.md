Redis 为了减少 rehash（哈希表扩容 / 缩容）的频率和性能影响，核心思路是 **“精准控制触发条件 + 渐进式执行 + 预分配冗余空间”**，通过多层机制避免频繁 rehash，同时平衡内存占用和查询效率。以下是 Redis 保证 “尽量少 rehash” 的核心机制，结合源码设计（Redis 6.x/7.x）详细说明：

## 一、先明确：rehash 为什么要 “尽量少”？

Redis 的底层哈希表（`dict`）是实现 `String`、`Hash` 等结构的核心，rehash 是当哈希表负载因子（`load factor`）超出阈值时，为解决哈希冲突、保证查询效率而进行的 “扩容 / 缩容” 操作 —— 本质是创建新哈希表，将旧表数据迁移到新表。

rehash 的问题在于：

- 若数据量极大（如千万级键值对），一次性迁移会导致 Redis 阻塞（“stop-the-world”），影响服务响应；
- 频繁 rehash 会浪费 CPU 资源，且内存反复分配 / 释放可能产生碎片。

因此 Redis 的设计目标是：**不到万不得已不触发 rehash，且触发后尽量 “低干扰” 执行**。

## 二、Redis 保证少 rehash 的核心机制

### 1. 机制 1：基于 “负载因子” 的精准触发条件（避免不必要 rehash）

rehash 的触发完全由 **负载因子（load factor）** 决定，负载因子 = 哈希表已用节点数（`used`） / 哈希表容量（`size`）。Redis 为 “扩容” 和 “缩容” 设置了严格的阈值，只有满足条件才会触发 rehash，避免 “过早扩容” 或 “过度缩容”。

#### （1）扩容触发条件（默认配置）

只有同时满足以下两个条件，才会触发扩容 rehash：

- 负载因子 ≥ 1（`dict_force_resize_ratio=1`，默认值）；
- 未处于 “正在 rehash 中”（`rehashing` 状态）；
- 未禁止自动扩容（`dict_can_resize=1`，默认允许）。

**例外场景（延迟扩容）**：

- 若 Redis 正在执行```BGSAVE```（后台持久化）或```BGREWRITEAOF```AOF 重写），会将扩容阈值临时提高到
负载因子 ≥ 5 （```dict_force_resize_ratio=5```）。



原因：```BGSAVE```会 fork 子进程，父子进程共享物理内存（写时复制 COW），此时扩容会触发大量数据复制，浪费内存和 CPU。Redis 选择 “延迟扩容”，等持久化完成后再恢复阈值到 1。

#### （2）缩容触发条件

当负载因子 ≤ 0.1（`dict_min_resize_ratio=0.1`）时，触发缩容 rehash，释放空闲内存。缩容的阈值设置得很低，避免 “频繁缩容”（比如偶尔删除几个键就触发缩容，反而浪费资源）。

#### 示例：

- 哈希表容量 `size=4`，已用 `used=3` → 负载因子 = 0.75 < 1 → 不扩容；
- `used=4` → 负载因子 = 1 → 触发扩容（容量变为 8）；
- 若此时正在 `BGSAVE` → 负载因子需达到 5（`used=20`）才扩容 → 大幅减少 rehash 次数。

### 2. 机制 2：渐进式 rehash（减少单次 rehash 的性能冲击）

即使触发了 rehash，Redis 也不会 “一次性迁移所有数据”，而是采用 **渐进式 rehash**，将迁移过程分散到 “每次哈希表操作（增删改查）” 中，避免阻塞。

#### 渐进式 rehash 的核心设计：

- 哈希表结构：`dict` 包含两个哈希表 `ht[0]`（旧表）和 `ht[1]`（新表）；
- 扩容时：`ht[1]` 的容量 = `ht[0]` 容量 × 2（或 2^n 向上取整）；缩容时：`ht[1]` 容量 = 大于 `used` 的最小 2^n；
- 迁移过程：
    1. 触发 rehash 后，仅创建 `ht[1]`，不立即迁移数据；
    2. 每次执行哈希表操作（如 `GET`、`SET`、`DEL`）时，除了执行当前操作，还会 “顺带迁移” 少量数据（默认 1 个桶的所有键值对）从 `ht[0]` 到 `ht[1]`；
    3. 同时，Redis 会在后台线程（Redis 6.0+ 引入 `dictRehashMilliseconds` 后台任务）中，定期迁移数据（默认每次迁移 1ms，避免占用过多 CPU）；
    4. 当 `ht[0]` 所有数据迁移完成后，释放 `ht[0]`，将 `ht[1]` 设为 `ht[0]`，`ht[1]` 清空，rehash 结束。

#### 作用：

- 单次 rehash 的开销极小（迁移少量数据），Redis 不会阻塞；
- 避免 “一次性迁移海量数据” 导致的服务不可用，间接减少了 “因 rehash 影响服务而被迫优化 rehash 频率” 的需求。

### 3. 机制 3：哈希表容量的 “2^n 对齐”（减少冲突，降低 rehash 频率）

Redis 的哈希表容量（`size`）始终是 2 的整数次幂（如 4、8、16、32...），这一设计从根源上减少了哈希冲突，从而减少 rehash 的触发频率：

- 哈希函数计算：`index = hash(key) & (size - 1)`（等价于 `hash(key) % size`，但位运算更快）；
- 2^n 容量的优势：`size-1` 的二进制全为 1（如 size=8 → 0111），哈希值的低位能充分分散，减少冲突；
- 冲突少 → 哈希表的查询 / 插入效率高 → 无需频繁扩容来缓解冲突。

#### 对比：

若容量不是 2^n（如 7），`size-1=6`（0110），哈希值的最低位始终被忽略，冲突概率大幅增加，可能需要更频繁扩容来保证效率。

### 4. 机制 4：禁止主动 rehash（按需关闭，减少不必要操作）

Redis 提供了两个核心配置，允许用户根据场景禁止不必要的 rehash：

- `dict_can_resize=0`：禁止自动扩容（仅在负载因子 ≥5 时才强制扩容）；
- `redis.conf` 中的 `hash-max-ziplist-entries` 和 `hash-max-ziplist-value`：对于 `Hash` 类型，当键值对数量 / 单个值长度小于阈值时，Redis 会用 “压缩列表（ziplist）” 存储（而非哈希表），完全避免 rehash。

#### 适用场景：

- 高并发写入场景，避免 rehash 占用 CPU；
- 小体量 `Hash` 数据，用压缩列表存储，既省内存又无 rehash 开销。

### 5. 机制 5：后台线程辅助迁移（Redis 6.0+，进一步降低 rehash 影响）

Redis 6.0 之前，渐进式 rehash 的数据迁移完全依赖 “用户操作触发”，若一段时间内无用户操作，`ht[0]` 数据无法迁移，`ht[0]` 和 `ht[1]` 会长期共存（浪费内存）。

Redis 6.0 引入 **后台 rehash 线程**：

- 后台线程定期（默认每 100ms）检查是否有正在进行的 rehash；
- 每次迁移 1ms 时长的数据（可通过 `dict_rehash_ratio` 调整），即使无用户操作，也能逐步完成迁移；
- 迁移过程中，若有用户操作，优先执行用户操作，避免后台线程抢占资源。

#### 作用：

- 避免 “长期双哈希表共存” 导致的内存浪费；
- 减少因 “迁移停滞” 而可能触发的二次 rehash（比如 `ht[0]` 未迁移完，`ht[1]` 又达到扩容阈值）。

## 三、总结：Redis 少 rehash 的核心逻辑

Redis 保证 “尽量少 rehash” 的本质是 **“精准控制触发时机 + 分散执行开销 + 优化存储结构”**：

1. 用 “负载因子阈值 + 持久化延迟扩容” 控制 rehash 触发时机，避免不必要的扩容；
2. 用 “渐进式 rehash + 后台线程” 分散迁移开销，避免单次 rehash 阻塞；
3. 用 “2^n 容量对齐” 减少哈希冲突，降低 rehash 频率；
4. 用 “压缩列表替代哈希表” 对小数据场景优化，完全避免 rehash。

这些机制共同作用，让 Redis 在海量数据和高并发场景下，既能保证哈希表的查询效率，又能最大限度减少 rehash 的频率和性能影响，是 Redis 高性能的核心原因之一。