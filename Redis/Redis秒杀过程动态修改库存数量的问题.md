秒杀场景中用 Redis 分布式锁控制库存时，若出现 “修改库存” 需求（如人工调整库存、活动加量等），核心风险是**修改操作与秒杀扣减操作并发冲突**，可能导致库存计数异常（如超卖、库存不同步）。解决需围绕 “保证修改与扣减的互斥性”“确保库存数据一致性”“避免影响秒杀性能” 三个核心目标展开，具体方案如下：

### 一、先明确 “修改库存” 的核心风险

秒杀时，大量请求会通过 Redis 分布式锁竞争，执行 “库存检查→扣减” 的原子操作；若此时有外部修改（如加库存、减库存），可能出现两种问题：

1. **并发冲突**：修改操作与秒杀扣减同时操作 Redis 库存，导致计数覆盖（如秒杀扣减到 100，同时修改加 50，最终可能只存 150 或 100）；
2. **锁阻塞**：若修改操作直接抢分布式锁，可能长时间阻塞大量秒杀请求，导致秒杀响应延迟；
3. **数据不一致**：Redis 库存修改后，若未同步到数据库（或异步订单依赖的库存数据），会导致后续订单处理异常。

### 二、具体解决方案：分场景处理，平衡 “一致性” 与 “性能”

根据 “修改库存的频率” 和 “时效性要求”，可分为两种场景设计方案：

#### 场景 1：低频修改（如活动中临时加库存，1 天几次）

适合用 **“锁隔离 + 原子操作”** 方案，优先保证一致性，允许短暂影响秒杀性能（因低频，影响可控）。

##### 核心步骤：

1. **复用分布式锁，保证互斥**修改库存时，必须先获取与秒杀扣减相同的 Redis 分布式锁（如锁 key 为 `lock:stock:{商品ID}`），确保同一时间只有 “秒杀扣减” 或 “库存修改” 中的一个操作执行。
    - 注意：锁的过期时间需设为 “修改操作的最大耗时 + 冗余时间”（如 10 秒），避免修改过程中锁过期导致冲突。
2. **用 Redis 原子命令执行修改**避免用 “先查后改”（如 `GET stock → 计算 new_stock → SET stock new_stock`），改用原子命令直接修改，防止并发覆盖：
    - 加库存：`INCRBY stock:{商品ID} 100`（如加 100 件库存）；
    - 减库存（如临时减少活动库存）：`DECRBY stock:{商品ID} 50`，并提前判断库存是否足够（可配合 `GET stock` 先检查，再执行 `DECRBY`，因已加锁，“查→改” 是安全的）。
3. **同步数据库库存（可选但推荐）**若 Redis 库存是数据库的 “缓存”，修改后需同步更新数据库（如用 `UPDATE stock SET num = num + 100 WHERE goods_id = {商品ID}`），避免 Redis 重启后数据丢失。可同步执行（因低频，性能影响小），或用消息队列异步同步（需确保最终一致性）。

#### 场景 2：高频修改（如动态调整库存，几分钟一次）

若修改频繁，直接抢锁会频繁阻塞秒杀请求，需用 **“双库存 + 异步同步”** 方案，优先保证秒杀性能，再通过异步机制保证一致性。

##### 核心步骤：

1. **Redis 中维护 “秒杀库存” 和 “备用库存” 两个 key**
    - `stock:seckill:{商品ID}`：专供秒杀扣减，秒杀请求只操作这个 key；
    - `stock:reserve:{商品ID}`：用于库存修改，外部修改只操作这个 key。
2. **秒杀扣减时，优先用 “秒杀库存”，不足时补充**秒杀扣减前，先检查 “秒杀库存” 是否足够：
    - 若足够：直接 `DECR stock:seckill:{商品ID}`，正常扣减；
    - 若不足：先从 “备用库存” 中划拨部分到 “秒杀库存”（如 `DECRBY stock:reserve:{商品ID} 200` + `INCRBY stock:seckill:{商品ID} 200`），再执行扣减（此过程需加锁，避免多线程重复划拨）。
3. **库存修改只操作 “备用库存”，不影响秒杀**
    - 加库存：直接 `INCRBY stock:reserve:{商品ID} 500`；
    - 减库存：先检查 “备用库存” 是否足够，再 `DECRBY`，无需阻塞秒杀请求。
4. **异步同步双库存，保证最终一致**启动定时任务（如每 10 秒），将 “备用库存” 的剩余量同步到 “秒杀库存”（避免备用库存积压），同时将双库存的总和同步到数据库，确保 Redis 与数据库一致。

### 三、关键补充：避免超卖的兜底措施

无论哪种方案，都需搭配以下兜底逻辑，防止极端情况导致超卖：

1. **Redis 扣减前必须检查库存**秒杀扣减时，先执行 `GET stock:{商品ID}` 确认库存 > 0，再执行 `DECR`（即使加了锁，也需避免 “锁内误操作”）；或直接用 `DECR` + 判断结果（如 `DECR` 后返回值 < 0，说明扣减超了，需 `INCR` 回滚，并返回 “库存不足”）。
2. **数据库最终校验**异步下订单时，数据库插入订单前，必须再次检查数据库库存（`SELECT num FROM stock WHERE goods_id = {商品ID}`），若库存不足，直接丢弃订单，避免 Redis 与数据库不一致导致的超卖。
3. **记录库存操作日志**所有 “秒杀扣减”“库存修改” 操作，都记录日志（含操作时间、操作类型、前后库存、操作人 / 系统），便于后续排查异常（如库存对不上时，可回溯日志定位问题）。

### 总结

- 低频修改：用 “分布式锁 + Redis 原子命令”，优先保证一致性，影响可控；
- 高频修改：用 “双库存隔离”，优先保证秒杀性能，异步同步一致性；
- 无论哪种方案，都需加 “Redis 前置检查” 和 “数据库最终校验”，杜绝超卖。