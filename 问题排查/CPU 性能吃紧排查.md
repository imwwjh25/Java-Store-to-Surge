### 一、CPU 吃紧核心排查流程（通用步骤）



1. 先用 `top`（Linux）/ 任务管理器（Windows）查看 CPU 整体使用率（`%us` 用户态、`%sy` 内核态），定位高 CPU 进程（按 `P` 排序进程 CPU 占比）；
2. 若单进程 CPU 占比接近 100%，聚焦该进程；若多进程分散占用，排查是否有资源竞争（如磁盘 IO、网络阻塞导致 CPU 等待）；
3. 结合 `vmstat 1 5`（查看 CPU 上下文切换、等待 IO 的进程数）、`pidstat -u 1 -p <PID>`（精准监控进程 CPU 使用）辅助定位。

### 二、Java 进程吃满 CPU：处理步骤（从定位到解决）



#### 1. 精准定位问题线程与代码



- 步骤 1：获取高 CPU Java 进程 PID（`top` 命令找到 PID，记为 `<PID>`）；
- 步骤 2：查看进程内高 CPU 线程：`top -Hp <PID>`（按 `P` 排序，记线程 ID `<TID>`）；
- 步骤 3：转换线程 ID 为十六进制（Java 线程栈用十六进制）：`printf "%x\n" <TID>`（记为 `<HEX_TID>`）；
- 步骤 4：导出线程栈：`jstack <PID> > jstack.log`，搜索 `<HEX_TID>`（忽略大小写），找到对应线程的运行代码（如死循环、频繁 GC、锁竞争）；
- 步骤 5：辅助验证：用 `jstat -gc <PID> 1000` 查看 GC 频率（若 YGC/FGC 频繁，可能是内存泄漏导致 CPU 高）；用 Arthas 的 `thread -n 5` 直接显示 Top5 高 CPU 线程。

#### 2. 常见原因与解决方案



| 常见原因                            | 解决方案                                                     |
| ----------------------------------- | ------------------------------------------------------------ |
| 死循环 / 无限递归                   | 查看线程栈定位循环代码，修复逻辑（如条件判断错误）           |
| GC 频繁（内存泄漏 / 堆过小）        | 用 `jmap -dump:format=b,file=heap.hprof <PID>` 导出堆 Dump，用 MAT 分析内存泄漏；调大堆内存（`-Xms/-Xmx`） |
| 锁竞争激烈（synchronized / 锁自旋） | 优化锁粒度（如拆分锁）、用无锁结构（ConcurrentHashMap）、替换锁类型（ReentrantLock→StampedLock） |
| 频繁创建销毁线程                    | 改用线程池（ThreadPoolExecutor），控制核心线程数             |
| 代码效率低（如 O (n²) 算法）        | 优化算法（如排序用 Timsort、查询用索引）                     |

### 三、非 Java 进程吃满 CPU：处理步骤



#### 1. 定位高 CPU 进程与子进程



- 用 `top` 找到非 Java 高 CPU 进程（如 `nginx`、`mysql`、`redis` 或自定义进程），记 PID；
- 用 `ps -ef | grep <PID>` 查看进程详情（如进程作用、启动参数）；
- 用 `pidstat -t -u 1 -p <PID>` 查看进程内子线程 CPU 占用，定位具体线程。

#### 2. 常见场景与解决方案



| 进程类型                        | 排查方向                                                     | 解决方案                                                     |                                          |                                                              |
| ------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ---------------------------------------- | ------------------------------------------------------------ |
| Web 服务器（Nginx/Apache）      | 查看并发连接数（`netstat -an                                 | grep :80                                                     | wc -l`）、日志（访问日志是否有高频请求） | 优化 Nginx 配置（如增加 worker_processes=CPU 核心数）、限流高频接口、升级服务器配置 |
| 数据库（MySQL/PostgreSQL）      | 查看慢查询日志（`show slow logs`）、当前运行 SQL（`show processlist`） | 优化慢 SQL（加索引、拆分大表）、调整数据库参数（如连接池大小）、清理无效连接 |                                          |                                                              |
| 缓存（Redis/Memcached）         | 查看命令统计（`redis-cli info stats`）、是否有大 key 操作、持久化策略（RDB/AOF 是否频繁触发） | 拆分大 key、调整持久化策略（如 AOF 改为 everysec）、限制并发命令数 |                                          |                                                              |
| 自定义非 Java 进程（C++/Go 等） | 查看进程日志、用 `gdb` 调试（`gdb -p <PID>` 查看调用栈）     | 修复代码逻辑（如死循环、资源泄漏）、优化 CPU 密集型任务（如并行计算改为分批处理） |                                          |                                                              |
| 系统进程（如 kswapd0、syslogd） | 排查是否磁盘 IO 高（`iostat -x 1`）、内存不足（`free -m`）   | 清理磁盘空间、增加物理内存、关闭无用系统服务                 |                                          |                                                              |
