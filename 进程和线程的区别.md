### 一、进程内线程**共享的资源**（进程级资源）



这些资源由进程创建并维护，同一进程内的所有线程均可访问，无需额外复制，体现了线程 “轻量级” 的特点（减少资源开销）。

1. **代码段（Text Segment）**存储进程运行的二进制指令（如程序的函数、逻辑代码），所有线程共享同一份代码，因为执行的是同一个程序。

2. 数据段（Data Segment）

    

   和

    

   堆（Heap）

   - 数据段：存储全局变量、静态变量（如 `static int a;`），所有线程可直接读写，需同步机制（如锁）保证安全。
   - 堆：动态分配的内存（如 `malloc()`、`new` 申请的内存），属于进程全局资源，线程通过指针访问，同样需要同步。

3. **文件描述符表（File Descriptors）**进程打开的文件、网络连接（如 socket）、管道等 I/O 资源，由内核统一管理，线程通过共享的文件描述符访问，关闭一个线程的描述符会影响其他线程。

4. **信号处理函数**进程注册的信号处理方式（如 `SIGINT` 信号的处理函数），所有线程共享同一套信号处理逻辑，信号到达时由内核决定哪个线程处理。

5. **进程 ID（PID）和组 ID（PGID）**整个进程只有一个 PID，所有线程共享该标识，操作系统通过 PID 识别进程。

6. **环境变量（Environment Variables）**如 `PATH`、`HOME` 等全局配置，所有线程可见且可修改（修改会影响整个进程）。

7. **内存映射（Memory Mapping）**通过 `mmap()` 映射的文件或共享内存，属于进程级资源，线程共享映射区域。

### 二、线程**独有的资源**（线程级资源）



这些资源是线程独立运行的基础，确保线程的执行状态不被其他线程干扰，实现并发调度。

1. **线程 ID（TID）**每个线程有唯一的 TID，用于操作系统识别和调度线程（类似进程的 PID）。
2. **程序计数器（PC，Program Counter）**记录线程当前执行的指令地址，线程切换时会保存 / 恢复 PC 值，确保下次运行能从断点继续。
3. **栈（Stack）**存储线程的局部变量、函数参数、返回地址等，每个线程有独立的栈空间（默认大小如 Linux 为 8MB），避免栈数据相互污染。
   - 例：线程 A 的局部变量 `int x=1` 和线程 B 的 `int x=2` 存储在各自栈中，互不影响。
4. **寄存器集合（Registers）**包括通用寄存器（如 eax、ebx）、栈指针（SP）、基址指针（BP）等，用于暂存线程执行时的中间数据，线程切换时需保存 / 恢复这些寄存器的值。
5. **线程私有数据（Thread-Local Storage, TLS）**通过 `pthread_key_create()`（POSIX 线程）或 `__thread`（GCC 扩展）定义的变量，每个线程有独立的副本，如日志线程的私有缓冲区。
6. **调度优先级和状态**线程有自己的调度优先级（如实时线程、普通线程）和执行状态（运行、就绪、阻塞），操作系统根据线程状态单独调度。
7. **信号掩码（Signal Mask）**线程可设置自己的信号掩码（屏蔽某些信号），不影响其他线程的信号处理（如线程 A 屏蔽 `SIGUSR1`，线程 B 仍可接收）。

### 三、总结：核心区别



| 资源类型     | 共享（进程级）                   | 独有（线程级）                   |
| ------------ | -------------------------------- | -------------------------------- |
| **资源目的** | 进程全局可见，支持线程协作       | 线程独立执行，避免相互干扰       |
| **典型资源** | 代码段、堆、文件描述符、全局变量 | 栈、寄存器、程序计数器、TID、TLS |
| **同步需求** | 需同步（如锁、信号量）防止冲突   | 无需同步（仅线程自身访问）       |

理解这一划分的关键是：**线程共享进程的 “资源所有权”，但拥有自己的 “执行状态”**。这种设计既减少了线程创建 / 切换的开销（无需复制大量资源），又保证了并发执行的独立性。
