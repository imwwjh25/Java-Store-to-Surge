要实现几亿用户规模的实时积分榜单（每 10 分钟刷新一次 TOP 100），需要结合 Redis 的特性和大规模数据场景的优化策略，核心思路是**分层存储 + 异步计算 + 高效查询**，具体设计如下：

### 一、核心数据结构选择

Redis 的`Sorted Set`（有序集合）是实现榜单的首选，因为它天然支持按分数（积分）排序，且提供了范围查询（如`ZREVRANGE`获取 TOP N）和分数更新（`ZADD`）的高效操作。但几亿用户直接存入单个 Sorted Set 会存在性能瓶颈（内存占用过高、操作延迟增加），因此需要拆分设计。

### 二、分层存储与分片策略

#### 1. 分片拆分（解决单实例内存 / 性能瓶颈）

- 按用户 ID 哈希分片 ：将几亿用户按用户 ID 哈希到多个 Redis 实例（或多个 Sorted Set 键）中，例如分成 100 个分片（```rank:shard:0```到```rank:shard:99```）。



每个分片存储约几百万用户（几亿 / 100 = 几百万），单个 Sorted Set 的规模可控，避免单实例内存溢出和操作阻塞。

- **分片路由**：通过`hash(userId) % 100`确定用户所属分片，更新积分时仅操作对应分片。

#### 2. 冷热数据分离（可选优化）

- 若大部分用户积分长期不变（冷数据），可将活跃用户（近期有积分变动）存入 Redis Sorted Set，冷数据存入数据库（如 MySQL/ClickHouse）。
- 刷新榜单时，先合并 Redis 中的活跃用户数据，再补充少量冷数据中的高积分用户（通过预计算筛选），减少 Redis 存储压力。

### 三、实时性与刷新策略

#### 1. 积分更新（实时写入）

- 用户积分变动时，通过```ZADD```（或```ZINCRBY```）实时更新对应分片的 Sorted Set，确保数据实时性。



示例：
```ZINCRBY rank:shard:12 user_12345 10```（用户```user_12345```在分片 12 中增加 10 积分）。

#### 2. TOP 100 定时刷新（每 10 分钟）

由于分片存储，无法直接通过单个命令获取全局 TOP 100，需要**分片聚合**：

- **步骤 1：分片内取 TOP N**对每个分片，通过`ZREVRANGE rank:shard:i 0 199 WITHSCORES`获取分片内前 200 名（取多于 100 名，避免分片间重复或低排名用户进入全局 TOP）。（100 个分片，每个取 200 条，共 2 万条数据，计算量可控）
- **步骤 2：全局聚合排序**将所有分片的 TOP 200 数据汇总到一个临时 Sorted Set（或内存中用堆排序），再取全局前 100 名，作为最终榜单。
    - 若用 Redis 临时存储：创建`rank:global:temp`，将 2 万条数据通过`ZADD`写入，再用`ZREVRANGE`取前 100。
    - 若用内存计算：在应用层用优先队列（如 Java 的`PriorityQueue`）聚合，效率更高（2 万条数据排序耗时毫秒级）。
- **步骤 3：缓存全局 TOP 100**将最终的全局 TOP 100 存入 Redis（如`rank:global:top100`），供查询接口直接读取，避免重复计算。

### 四、性能优化关键点

1. **分片数量合理设计**分片太少（如 10 个）会导致单个分片用户过多（上亿 / 10=1 亿），`ZREVRANGE`操作变慢；分片太多（如 1000 个）会增加聚合时的网络交互次数。建议根据单 Redis 实例能承载的 Sorted Set 规模（通常百万级用户 / 分片较优）调整，100~200 个分片较合适。
2. **异步刷新避免阻塞**用定时任务（如 XXL-Job、Celery）每 10 分钟触发刷新流程，任务在后台异步执行，不影响用户积分更新和榜单查询（查询时读缓存的`rank:global:top100`）。
3. **内存优化**
    - Sorted Set 的`member`（用户 ID）尽量缩短（如用整数 ID 代替长字符串，减少内存占用）。
    - 开启 Redis 的`ziplist`编码（小数据时更省内存）：通过`zset-max-ziplist-entries`和`zset-max-ziplist-value`配置，当分片内用户数较少时自动启用。
    - 定期清理无效用户（如长期无积分的用户），避免僵尸数据占用内存。
4. **查询接口优化**
    - 前端查询 TOP 100 时，直接返回缓存的`rank:global:top100`，响应时间可做到毫秒级。
    - 若需要查询 “某个用户的排名”，可在更新积分时同步记录用户的分片内排名（通过`ZREVRANK`），但全局排名需估算（或仅展示分片内排名 + 提示 “接近 TOP 100”），避免实时计算全局排名的高成本。

### 五、容错与扩展

- **分片故障处理**：若某个 Redis 分片故障，刷新榜单时可跳过该分片（或使用备用实例），确保 TOP 100 仍能生成（可能略有偏差，故障恢复后补全）。
- **水平扩展**：当用户量增长时，增加分片数量（需做数据迁移，可通过`ZUNIONSTORE`合并旧分片到新分片）。

### 总结

通过 “分片存储 + 定时聚合 + 缓存结果” 的方案，既能支撑几亿用户的实时积分更新，又能每 10 分钟高效生成 TOP 100 榜单，同时控制 Redis 的内存和性能开销。核心是利用 Sorted Set 的排序特性，通过分片拆分降低单实例压力，再通过异步聚合实现全局排名。