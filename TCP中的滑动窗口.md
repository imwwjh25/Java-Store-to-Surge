## 一、实现的核心基础：TCP 头部字段与窗口定义

滑动窗口的实现首先依赖 TCP 协议头的关键字段（用于双方协商窗口大小），以及 “发送窗口”“接收窗口” 的核心定义：

### 1. 关键 TCP 头部字段（窗口协商的 “通信工具”）

| 字段名称                        | 作用描述                                                     |
| ------------------------------- | ------------------------------------------------------------ |
| 窗口大小（Window Size）         | 16 位字段，接收方在报文（如 SYN、ACK）中携带，通告 “当前接收缓冲区剩余可容纳的字节数”（即接收窗口大小）。 |
| 确认号（Acknowledgment Number） | 32 位字段，发送方回复 ACK 时携带，表示 “已成功接收的最后一个字节的下一位”（用于同步双方数据接收进度）。 |
| 窗口缩放选项（Window Scale）    | 可选字段（RFC 1323），三次握手时双方协商 “缩放因子”（0~14），解决 16 位窗口字段最大仅 65535 字节的限制，实际窗口 = 头部窗口值 × 2^ 缩放因子。 |
| PSH（Push）标志                 | 发送方触发 “立即推送”，接收方收到后立即将数据交给应用层，避免缓冲区堆积（辅助窗口动态调整）。 |
| RST（Reset）标志                | 接收方缓冲区溢出时，发送 RST 重置连接（极端情况下的流量控制兜底）。 |

### 2. 核心窗口定义（双方各自维护的 “状态窗口”）

TCP 滑动窗口是 **字节级的窗口管理**（而非报文段级），双方需维护两个核心窗口：

- **接收窗口（rwnd，Receiver Window）**：接收方维护，大小 = 接收缓冲区总大小 - 已接收未交付应用层的字节数（即 “剩余可用缓冲区大小”），是流量控制的 “核心依据”—— 接收方通过 `Window Size` 字段将其通告给发送方。
- **发送窗口（swnd，Sender Window）**：发送方维护，大小由 “接收方通告的 rwnd” 和 “网络拥塞窗口（cwnd）” 共同决定（`swnd = min(rwnd, cwnd)`），表示 “发送方当前可连续发送的字节数”（无需等待每字节的 ACK）。

> 补充：拥塞窗口（cwnd）是 “拥塞控制” 的核心，用于避免网络拥堵（如慢启动、拥塞避免），滑动窗口的 “流量控制” 与 “拥塞控制” 协同工作 —— 本文聚焦滑动窗口的实现，拥塞控制仅作为发送窗口的约束条件提及。

## 二、滑动窗口的核心实现逻辑：发送方与接收方的协同

滑动窗口的实现是 “接收方动态调整窗口、发送方根据窗口滑动发送” 的循环，以下分角色拆解执行流程：

### 1. 接收方的实现逻辑（主导窗口调整）

接收方的核心职责：**实时计算接收窗口大小，通过 ACK 报文通告给发送方**，并处理接收的数据。

#### 关键步骤：

1. **初始化接收窗口**：
   - 连接建立时（三次握手），接收方分配固定大小的接收缓冲区（如 Linux 默认 4096 字节），初始接收窗口 `rwnd = 接收缓冲区总大小`（如 4096 字节）；
   - 若启用窗口缩放，`rwnd = 初始窗口值 × 2^缩放因子`（如缩放因子 2，实际 rwnd = 4096 × 4 = 16384 字节）；
   - 接收方在 `SYN` 或 `SYN+ACK` 报文中，通过 `Window Size` 字段将初始 rwnd 通告给发送方。
2. **接收数据时的窗口调整**：
   - 接收方收到发送方的数据后，先存入接收缓冲区，再判断 “是否有连续数据可交付应用层”（TCP 是字节流，需按序接收）；
   - 若数据连续且应用层已读取，则释放对应缓冲区空间，更新 `rwnd = 接收缓冲区总大小 - 未交付应用层的字节数`；
   - 接收方在回复 ACK 报文时，同步更新 `Window Size` 字段（携带最新 rwnd），让发送方感知接收能力变化。
3. **特殊场景处理**：
   - 接收缓冲区已满（rwnd = 0）：接收方会发送 “rwnd = 0” 的 ACK 报文，发送方收到后停止发送数据（进入 “零窗口探测” 状态）；
   - 应用层读取数据后释放缓冲区：接收方需主动发送 “rwnd> 0” 的 ACK 报文（或等待下一次数据接收后回复），通知发送方恢复发送；
   - 数据乱序到达：乱序数据存入接收缓冲区的 “无序队列”，此时 rwnd 仍会扣除乱序数据占用的缓冲区空间（避免发送方继续发送导致溢出），直到缺失的前序数据到达、拼接成连续字节流后，再交付应用层并释放缓冲区。

#### 示例：接收方窗口调整流程

- 接收缓冲区总大小 = 4096 字节，初始 rwnd = 4096；
- 收到发送方 1024 字节数据（存入缓冲区），未交付应用层 → rwnd = 4096 - 1024 = 3072；
- 应用层读取 1024 字节 → 缓冲区释放 → rwnd = 4096 - 0 = 4096；
- 回复 ACK 时，`Window Size = 4096`，通告发送方 “可继续发送 4096 字节”。

### 2. 发送方的实现逻辑（根据窗口滑动发送）

发送方的核心职责：**根据接收方通告的 rwnd 和网络拥塞窗口 cwnd，确定发送窗口 swnd，按 “滑动规则” 连续发送数据，并根据 ACK 更新窗口**。

#### 关键概念：发送方的 “字节分区”

发送方将待发送的字节流分为 4 个区域（按字节序号排序），滑动窗口的 “滑动” 本质是这 4 个区域的边界移动：

| 区域名称         | 含义                                                         |
| ---------------- | ------------------------------------------------------------ |
| 已发送且已确认   | 字节序号 ≤ 确认号 - 1（接收方已成功接收并回复 ACK）          |
| 已发送但未确认   | 确认号 ≤ 字节序号 < 发送指针（已发送但未收到 ACK，需等待超时重传） |
| 未发送但可发送   | 发送指针 ≤ 字节序号 < 发送窗口右边界（swnd 范围内，可立即发送） |
| 未发送且不可发送 | 字节序号 ≥ 发送窗口右边界（超出 swnd，需等待窗口更新后才能发送） |

#### 关键步骤：

1. **初始化发送窗口**：
   - 三次握手后，发送方根据接收方通告的 rwnd，结合 cwnd（初始通常为 MSS 大小，如 1460 字节），设置 `swnd = min(rwnd, cwnd)`；
   - 发送窗口左边界 = 0（初始未发送数据），右边界 = swnd（如 rwnd=4096、cwnd=1460 → swnd=1460，右边界 = 1460）。
2. **发送数据**：
   - 发送方在 “未发送但可发送” 区域内，连续发送数据（最多发送 swnd 字节，或按 MSS 拆分多个报文段）；
   - 发送后，数据进入 “已发送但未确认” 区域，同时记录每个字节的发送时间（用于超时重传）。
3. **接收 ACK 后滑动窗口**：
   - 收到接收方的 ACK 报文后，解析 “确认号” 和 “最新 rwnd”：
     - 窗口左边界 = 确认号（已确认的字节不再占用窗口空间）；
     - 新 swnd = min (接收方通告的 rwnd, 最新 cwnd)；
     - 窗口右边界 = 窗口左边界 + swnd；
   - 窗口滑动后，“未发送但可发送” 区域扩大，发送方继续发送新数据。
4. **特殊场景处理**：
   - 零窗口探测（rwnd=0）：发送方收到 “rwnd=0” 后停止发送，每隔一段时间（如 1 秒）发送一个 “零窗口探测报文”（携带 1 字节数据），接收方回复时会携带最新 rwnd，若 rwnd>0 则恢复发送；
   - 超时重传：“已发送但未确认” 区域的字节若超时未收到 ACK，发送方会重传该字节（或按选择性重传机制重传缺失的报文段）；
   - 快速重传：若收到 3 个重复 ACK（表示接收方缺失中间字节），发送方无需等待超时，直接重传缺失的字节。

#### 示例：发送方窗口滑动流程

- 初始状态：确认号 = 0，swnd=1460（min (rwnd=4096, cwnd=1460)），窗口左边界 = 0，右边界 = 1460；
- 发送 1460 字节数据（已发送但未确认），发送指针 = 1460；
- 收到接收方 ACK：确认号 = 1460（已确认 0~1459 字节），通告 rwnd=4096；
- 窗口滑动：左边界 = 1460，swnd=min (4096, cwnd=2920)（cwnd 已通过慢启动增长），右边界 = 1460+2920=4380；
- 发送方继续发送 2920 字节数据，循环上述流程。

## 三、实现的关键细节：确保可靠性与效率

### 1. 窗口的 “字节级” 而非 “报文段级” 管理

TCP 滑动窗口是按 “字节序号” 管理的，而非按 “报文段数量”—— 这是因为 TCP 是字节流协议，需保证数据的有序性和完整性。例如：接收方的 rwnd=4096 表示 “可接收 4096 字节”，而非 “4 个 MSS=1460 的报文段”（实际可能是 3 个完整报文段 + 部分字节）。

### 2. 接收缓冲区的设计（影响窗口调整效率）

接收缓冲区的大小由操作系统配置（如 Linux 的 `net.core.wmem_default`/`net.core.rmem_default`），或应用层通过 `setsockopt` 函数设置（`SO_SNDBUF`/`SO_RCVBUF`）。缓冲区过大会导致数据堆积（应用层读取不及时），过小会导致 rwnd 频繁变为 0（发送方频繁暂停），需根据业务场景调整。

### 3. 窗口缩放的实现（支持大窗口）

16 位的 `Window Size` 字段最大仅能表示 65535 字节（64KB），无法满足大带宽场景（如千兆网卡需更大窗口来填满带宽）。窗口缩放的实现逻辑：

- 三次握手时，双方在 `SYN` 报文中携带 `Window Scale` 选项，协商缩放因子（如发送方通告缩放因子 = 3，接收方也通告 = 3）；
- 连接建立后，所有报文中的 `Window Size` 字段都需乘以 2^ 缩放因子，才是实际的 rwnd（如头部窗口值 = 4096，缩放因子 = 3 → 实际 rwnd=4096×8=32768 字节）；
- 缩放因子仅在三次握手时协商，连接期间不可修改。

### 4. 与拥塞控制的协同（避免网络拥堵）

滑动窗口的发送窗口 `swnd = min(rwnd, cwnd)`：

- rwnd 限制 “发送方不能超过接收方的接收能力”（流量控制）；
- cwnd 限制 “发送方不能超过网络的承载能力”（拥塞控制）；
- 例如：接收方 rwnd=10000 字节，但网络 cwnd=5000 字节，发送方最多只能发送 5000 字节，避免因发送过快导致网络拥堵。

## 四、总结：滑动窗口实现的核心逻辑

TCP 滑动窗口的实现本质是 **“接收方通过窗口通告反馈接收能力，发送方通过窗口滑动控制发送速率” 的闭环机制**，核心要点：

1. 基础依赖：TCP 头部的 `Window Size`、确认号、窗口缩放选项，以及双方的接收 / 发送缓冲区；
2. 接收方逻辑：实时计算 rwnd，通过 ACK 通告给发送方，主导流量控制；
3. 发送方逻辑：根据 rwnd 和 cwnd 确定 swnd，按字节分区管理数据，收到 ACK 后滑动窗口；
4. 关键目标：在 “不丢失数据”（避免接收方缓冲区溢出）和 “最大化带宽利用率”（连续发送数据）之间达到平衡。

简单说：滑动窗口的实现让 TCP 从 “停 - 等协议”（一次发 1 字节等 ACK）升级为 “流水线协议”（连续发送多个字节），是 TCP 可靠传输和高效传输的核心基础。
