Redis 和 Memcached 都是常用的内存数据库（缓存），但在数据结构、功能支持、性能特性等方面有显著差异，核心区别体现在 “功能丰富度” 与 “专注度” 的权衡上。

### 一、核心区别对比表

| **对比维度**       | **Redis**                                                    | **Memcached**                                                |
| ------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **数据结构支持**   | 丰富：String（字符串）、Hash（哈希）、List（列表）、Set（集合）、Sorted Set（有序集合）、BitMap、GeoHash 等 | 单一：仅支持 **Key-Value 键值对**（Value 仅限字符串，需手动序列化复杂数据） |
| **Value 大小限制** | 默认最大 512MB（可通过配置修改），支持存储大对象（如序列化后的图片、视频元数据） | 最大 1MB，仅适合存储小数据（如会话 ID、计数器）              |
| **持久化机制**     | 支持两种持久化：1. RDB（定时快照，适合备份）2. AOF（日志追加，适合数据恢复） | **不支持持久化**：数据仅存于内存，服务重启后数据丢失         |
| **高可用方案**     | 原生支持：1. 主从复制（Master-Slave）2. 哨兵（Sentinel）：自动故障转移3. 集群（Redis Cluster）：分片存储，支持水平扩展 | 无原生高可用方案：需依赖第三方工具（如 Keepalived、Codis）实现主从、分片，配置复杂 |
| **并发性能**       | 单线程模型（基于 IO 多路复用），避免线程切换开销，**万级 QPS**（适合 CPU 密集型操作少的场景） | 多线程模型（基于 Libevent），**十万级 QPS**（适合纯内存读写、无复杂计算的场景） |
| **原子操作支持**   | 支持丰富的原子操作：如 Hash 增减字段、Set 交集 / 并集、Sorted Set 排序等，可直接实现分布式锁、计数器等功能 | 仅支持简单原子操作（如 incr/decr 计数器），复杂逻辑需客户端实现 |
| **过期策略**       | 支持多种过期策略：1. 惰性删除（访问时检查）2. 定期删除（定时扫描）3. 内存淘汰（内存满时按策略删除过期 / 不常用数据） | 仅支持 **惰性删除**（访问时检查过期），无内存淘汰机制，内存满时无法写入新数据 |
| **适用场景**       | 1. 复杂数据结构需求（如排行榜、购物车、消息队列）2. 需要持久化（如缓存 + 数据库双写）3. 分布式锁、计数器等业务4. 大规模集群（分片存储） | 1. 简单 Key-Value 缓存（如会话缓存、页面静态数据）2. 纯内存临时存储（无需持久化）3. 高并发读写、无复杂计算的场景 |

### 二、关键差异深度解析

#### 1. 数据结构：Redis 更灵活，Memcached 更简单

- Redis ：通过内置多种数据结构，减少客户端序列化 / 反序列化的工作量。例如：

    - 用 `Hash` 存储用户信息（`user:100 {name:"张三", age:20}`），无需将整个对象序列化为字符串；
    - 用 `Sorted Set` 实现排行榜（按分数排序，支持实时更新）。

- **Memcached**：所有数据都需转为字符串（如用 JSON、Protobuf 序列化对象），读取时再反序列化，增加客户端开销，且无法直接操作对象内部字段。

#### 2. 持久化：Redis 可保数据，Memcached 纯内存

- Redis ：通过 RDB 或 AOF 确保数据不丢失。例如：

    - 电商场景中，缓存的商品库存可通过 AOF 持久化，避免服务重启后库存数据归零；
    - 定期用 RDB 做数据备份，便于回滚到历史版本。

- **Memcached**：数据完全存于内存，适合 “丢了也不影响” 的场景（如缓存 1 分钟过期的热点新闻列表），但无法用于需要数据可靠性的业务。

#### 3. 高可用与扩展：Redis 原生支持，Memcached 依赖第三方

- **Redis**：集群方案成熟，例如 Redis Cluster 可将数据分片到多个节点，支持 1000+ 节点的大规模部署，且自动实现故障转移（某个节点宕机，从节点自动升为主节点）。
- **Memcached**：无原生集群，需通过 Codis 等中间件实现分片，或用 Keepalived 做主从切换，配置复杂且维护成本高，仅适合小规模部署。

#### 4. 性能：Memcached 多线程更快，Redis 单线程更稳

- **Memcached**：多线程模型能充分利用多核 CPU，纯内存读写时性能略高于 Redis（尤其在十万级 QPS 场景），但不支持复杂操作。
- **Redis**：单线程模型避免了线程上下文切换的开销，且 IO 多路复用（epoll/kqueue）能高效处理并发连接，虽然单线程，但复杂操作（如 Sorted Set 排序）仍能保持稳定性能，不会因线程竞争导致卡顿。

### 三、总结：如何选择？

- **选 Redis**：如果需要复杂数据结构（如排行榜、购物车）、数据持久化、高可用集群，或业务依赖分布式锁、计数器等功能，优先用 Redis。
- **选 Memcached**：如果仅需简单的 Key-Value 缓存（如会话 ID、临时计数器），且数据无需持久化、追求极致的读写性能（十万级 QPS），可考虑 Memcached。

实际生产中，Redis 因功能全面、生态成熟，应用范围远广于 Memcached，大部分场景下 Redis 是更优选择。
