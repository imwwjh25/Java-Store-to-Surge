### 一、为什么需要责任链模式？

先看痛点场景：

- 你开发一个订单退款审批系统，退款金额不同，审批人不同：

    - ≤1000 元：组长审批；

    - 1000~5000 元：部门经理审批；

    - 5000~10000 元：总监审批；

    - 10000 元：老板审批；


- 若用`if-else`实现：在一个方法中判断金额范围，调用对应审批逻辑，新增审批层级（如区域经理）或调整金额阈值时，必须修改该方法，耦合度高且代码臃肿。

责任链模式的解决思路：将每个审批人封装为独立的处理者类，按层级连成链，退款请求从链头（组长）开始传递，每个处理者判断是否能处理，能则处理，不能则传递给下一个，新增审批人只需添加新处理者并调整链结构，无需修改原有代码。

### 二、责任链模式的核心结构

责任链模式包含 3 个核心角色：

1. **抽象处理者（Handler）**：定义处理请求的接口（如`handleRequest()`），并持有下一个处理者的引用（形成链）；
2. **具体处理者（Concrete Handler）**：实现抽象处理者接口，判断是否能处理当前请求 —— 能则处理，不能则传递给下一个处理者；
3. **客户端（Client）**：创建处理者链，发起请求（只需将请求交给链头，无需关注后续处理者）。

### 三、完整代码实现（退款审批场景）

#### 1. 抽象处理者（Handler）








```
// 退款审批抽象处理者
public abstract class Approver {
    // 下一个处理者（链的核心：持有后续节点引用）
    protected Approver nextApprover;
    // 处理者名称
    protected String name;

    public Approver(String name) {
        this.name = name;
    }

    // 设置下一个处理者（构建链）
    public void setNextApprover(Approver nextApprover) {
        this.nextApprover = nextApprover;
    }

    /**
     * 处理退款请求
     * @param amount 退款金额
     * @return 审批结果
     */
    public abstract String handleRequest(double amount);
}
```

#### 2. 具体处理者（Concrete Handler）









```
// 具体处理者1：组长（≤1000元）
public class GroupLeader extends Approver {
    public GroupLeader(String name) {
        super(name);
    }

    @Override
    public String handleRequest(double amount) {
        if (amount <= 1000) {
            // 能处理：直接返回结果
            return "【" + name + "】审批通过，退款金额：" + amount + "元";
        } else {
            // 不能处理：传递给下一个处理者
            if (nextApprover != null) {
                return nextApprover.handleRequest(amount);
            } else {
                return "【" + name + "】无后续审批人，退款金额：" + amount + "元，审批失败";
            }
        }
    }
}

// 具体处理者2：部门经理（1000~5000元）
public class DepartmentManager extends Approver {
    public DepartmentManager(String name) {
        super(name);
    }

    @Override
    public String handleRequest(double amount) {
        if (amount > 1000 && amount <= 5000) {
            return "【" + name + "】审批通过，退款金额：" + amount + "元";
        } else {
            if (nextApprover != null) {
                return nextApprover.handleRequest(amount);
            } else {
                return "【" + name + "】无后续审批人，退款金额：" + amount + "元，审批失败";
            }
        }
    }
}

// 具体处理者3：总监（5000~10000元）
public class Director extends Approver {
    public Director(String name) {
        super(name);
    }

    @Override
    public String handleRequest(double amount) {
        if (amount > 5000 && amount <= 10000) {
            return "【" + name + "】审批通过，退款金额：" + amount + "元";
        } else {
            if (nextApprover != null) {
                return nextApprover.handleRequest(amount);
            } else {
                return "【" + name + "】无后续审批人，退款金额：" + amount + "元，审批失败";
            }
        }
    }
}

// 具体处理者4：老板（>10000元）
public class Boss extends Approver {
    public Boss(String name) {
        super(name);
    }

    @Override
    public String handleRequest(double amount) {
        if (amount > 10000) {
            return "【" + name + "】审批通过，退款金额：" + amount + "元";
        } else {
            if (nextApprover != null) {
                return nextApprover.handleRequest(amount);
            } else {
                return "【" + name + "】无后续审批人，退款金额：" + amount + "元，审批失败";
            }
        }
    }
}
```

#### 3. 客户端使用（构建链 + 发起请求）








```
public class ChainOfResponsibilityDemo {
    public static void main(String[] args) {
        // 1. 创建各个处理者
        Approver groupLeader = new GroupLeader("张组长");
        Approver deptManager = new DepartmentManager("李经理");
        Approver director = new Director("王总监");
        Approver boss = new Boss("赵老板");

        // 2. 构建责任链：组长 → 部门经理 → 总监 → 老板
        groupLeader.setNextApprover(deptManager);
        deptManager.setNextApprover(director);
        director.setNextApprover(boss);

        // 3. 发起请求（只需交给链头：组长）
        System.out.println("===== 退款800元 =====");
        System.out.println(groupLeader.handleRequest(800));

        System.out.println("\n===== 退款3000元 =====");
        System.out.println(groupLeader.handleRequest(3000));

        System.out.println("\n===== 退款8000元 =====");
        System.out.println(groupLeader.handleRequest(8000));

        System.out.println("\n===== 退款15000元 =====");
        System.out.println(groupLeader.handleRequest(15000));

        System.out.println("\n===== 退款20000元（老板无后续，仍可处理） =====");
        System.out.println(groupLeader.handleRequest(20000));
    }
}
```

**输出结果**：












```
===== 退款800元 =====
【张组长】审批通过，退款金额：800.0元

===== 退款3000元 =====
【李经理】审批通过，退款金额：3000.0元

===== 退款8000元 =====
【王总监】审批通过，退款金额：8000.0元

===== 退款15000元 =====
【赵老板】审批通过，退款金额：15000.0元

===== 退款20000元（老板无后续，仍可处理） =====
【赵老板】审批通过，退款金额：20000.0元
```

### 四、责任链模式的扩展：灵活调整链结构

责任链的核心优势是**动态调整链**，比如新增 “区域经理” 处理 5000~8000 元，只需新增处理者并调整链：









```
// 新增具体处理者：区域经理
public class RegionalManager extends Approver {
    public RegionalManager(String name) {
        super(name);
    }

    @Override
    public String handleRequest(double amount) {
        if (amount > 5000 && amount <= 8000) {
            return "【" + name + "】审批通过，退款金额：" + amount + "元";
        } else {
            if (nextApprover != null) {
                return nextApprover.handleRequest(amount);
            } else {
                return "审批失败";
            }
        }
    }
}

// 客户端调整链
public class ChainAdjustDemo {
    public static void main(String[] args) {
        // 创建处理者
        Approver groupLeader = new GroupLeader("张组长");
        Approver deptManager = new DepartmentManager("李经理");
        Approver regionalManager = new RegionalManager("陈区域经理");
        Approver director = new Director("王总监");
        Approver boss = new Boss("赵老板");

        // 重构链：组长→经理→区域经理→总监→老板
        groupLeader.setNextApprover(deptManager);
        deptManager.setNextApprover(regionalManager);
        regionalManager.setNextApprover(director);
        director.setNextApprover(boss);

        // 测试7000元退款（由区域经理处理）
        System.out.println(groupLeader.handleRequest(7000));
        // 输出：【陈区域经理】审批通过，退款金额：7000.0元
    }
}
```

### 五、责任链模式的两种典型实现方式




|    实现方式    |                             特点                             |                 示例场景                  |
| :------------: | :----------------------------------------------------------: | :---------------------------------------: |
|  **纯责任链**  | 每个处理者要么完全处理请求，要么完全传递，请求最终必有一个处理者处理 |            审批流程、权限校验             |
| **不纯责任链** | 处理者可部分处理请求后传递（如日志记录→参数校验→业务处理），请求可被多个处理者处理 | 过滤器链（如 Servlet Filter）、请求拦截器 |

### 六、责任链模式 vs 其他模式（易混区分）

#### 1. 责任链 vs 策略模式



|   维度   |               责任链模式               |                策略模式                |
| :------: | :------------------------------------: | :------------------------------------: |
| 核心目标 | 请求沿链传递，由第一个匹配的处理者处理 | 客户端选择一个策略执行，仅一个策略生效 |
| 处理逻辑 |         处理者自主判断是否处理         |           客户端指定具体策略           |
|   关系   |           处理者形成链式依赖           |             策略之间无依赖             |
|   示例   |        审批流程、Filter 过滤器         |           支付方式、排序算法           |

#### 2. 责任链 vs 状态模式




|   维度   |          责任链模式          |          状态模式          |
| :------: | :--------------------------: | :------------------------: |
| 核心目标 |  多个处理者竞争处理一个请求  | 不同状态下对象表现不同行为 |
| 触发方式 |         请求主动传递         |      状态变化触发行为      |
| 依赖关系 | 处理者之间单向依赖（下一个） |     状态持有上下文引用     |

### 七、责任链模式的核心特点

#### 优点：

1. **解耦请求与处理**：发送者无需知道处理者是谁、有多少，只需交给链头；
2. **动态调整链**：可灵活增减处理者、调整链顺序，符合 “开闭原则”；
3. **单一职责**：每个处理者只需关注自己的职责范围，代码清晰；
4. **避免 if-else**：替代大量条件判断，降低代码复杂度。

#### 缺点：

1. **请求可能无人处理**：若链中无处理者匹配，请求会 “落空”（需做好兜底）；
2. **性能损耗**：请求可能遍历多个处理者才被处理，链过长时性能下降；
3. **调试难度增加**：请求传递路径不直观，排查问题需跟踪整个链。

### 总结

1. **核心思想**：责任链模式将处理者连成链，请求沿链传递，由匹配的处理者处理，核心是 “请求分发、职责隔离”；

2. 适用场景 ：

    - 有多个对象可处理同一请求，且处理者无需预先确定（如审批、权限校验）；
    - 需动态调整处理者的顺序或增减处理者（如过滤器、拦截器）；
    - 希望避免用`if-else`判断请求的处理者；



3. 实现关键 ：

    - 抽象处理者持有下一个处理者的引用，提供设置方法；
    - 具体处理者实现 “判断 - 处理 / 传递” 逻辑；
    - 客户端负责构建链，只需将请求交给链头；



4. 优化建议 ：

    - 链过长时，可限制链的长度或用工厂模式管理链的构建；
    - 为请求添加 “兜底处理者”，避免请求无人处理；
    - 不纯责任链中，处理者需明确 “部分处理后是否传递”，避免逻辑混乱。



### 经典应用案例

- **Java Servlet Filter**：请求过滤器链，每个 Filter 处理后传递给下一个；
- **Spring Interceptor**：Spring MVC 的请求拦截器链；
- **MyBatis Plugin**：MyBatis 的插件链（如分页插件、拦截 SQL）；
- **Netty Pipeline**：Netty 的处理器链，处理网络请求。