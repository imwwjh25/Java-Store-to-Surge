当 Java 进程频繁触发 Full GC 时，定位核心是 **“先确认 Full GC 原因（内存泄漏 / 内存溢出 / 参数不合理）→ 找到泄漏 / 大对象 → 追溯对象的创建位置与生命周期”**，全程需结合 JVM 工具、日志分析和代码排查，以下是 step-by-step 落地方案：

### 一、第一步：先确认 Full GC 基本情况（是否真的有问题）

频繁 Full GC 的判断标准：Full GC 间隔 < 10 分钟，且每次 Full GC 后老年代内存释放极少（内存泄漏），或 Full GC 后内存快速回升（大对象频繁创建）。

#### 1. 开启 JVM 日志（关键：获取 GC 详细信息）

在 Java 进程启动参数中添加以下参数，输出 GC 日志（建议线上环境默认开启）：

bash











```bash
# 基础 GC 日志（包含 Full GC 时间、内存变化）
-XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintHeapAtGC -Xloggc:/path/to/gc.log
# JDK 9+ 用统一日志格式（推荐）
-Xlog:gc*:file=/path/to/gc.log:time,level,tags:filecount=5,filesize=100m
```

- 核心关注日志中的：`Full GC (Allocation Failure)`（老年代无空间分配）、`Full GC (System.gc())`（手动触发，需警惕）、老年代（Old Gen）的 `used` 变化（若 Full GC 后 `used` 仍 > 80%，大概率是内存泄漏）。

#### 2. 用工具实时监控 GC 状态

- jstat

  （JDK 自带，轻量级）：实时查看 GC 统计信息








  ```bash
  # 每 1 秒输出 10 次 GC 情况（PID 是 Java 进程 ID）
  jstat -gcutil PID 1000 10
  ```



输出结果中关注```O```（老年代使用率）和```FGC```（Full GC 次数）、```FGCT```（Full GC 总时间）：

- 若 `O` 持续 > 90%，且 `FGC` 每秒多次，说明老年代已溢出或泄漏；

- VisualVM/JProfiler/Arthas

  （可视化工具）：

    - VisualVM（JDK 自带，`jvisualvm` 命令启动）：连接进程后，查看「内存」→「老年代」趋势图，若曲线持续上升且 Full GC 后不回落，确定内存泄漏；
    - Arthas（阿里开源，线上无侵入）：执行 `jmap -histo PID` 查看对象分布，或 `dashboard` 实时监控堆内存。

### 二、第二步：找到导致 Full GC 的 “罪魁祸首”（泄漏 / 大对象）

通过工具导出堆快照，分析哪些对象在老年代持续累积，未被回收。

#### 1. 导出堆快照（Heap Dump）

- 方法 1：```jmap```（JDK 自带，适合线下 / 轻量线上）






  ```bash
  # 导出整个堆快照（可能触发 Full GC，线上高峰慎用）
  jmap -dump:format=b,file=/path/to/heap.hprof PID
  # 仅导出存活对象（减少快照体积，推荐）
  jmap -dump:live,format=b,file=/path/to/heap_live.hprof PID
  ```



- 方法 2：Arthas（线上无侵入导出）





  ```bash
  # 执行后按提示选择导出存活对象/全部对象
  heapdump /path/to/heap.hprof
  ```



- 方法 3：JVM 参数自动导出（OOM 时触发）











  ```bash
  # 当发生 OOM 时，自动导出堆快照（提前配置，避免故障后无数据）
  -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/path/to/oom.hprof
  ```



#### 2. 分析堆快照（定位泄漏对象）

用 **MAT（Memory Analyzer Tool，推荐）** 或 VisualVM 打开堆快照（`.hprof` 文件），核心操作：

- Step 1：查看 “Dominator Tree”（支配树） ：

    - 支配树展示 “占用内存最多的对象”，优先看「Retained Size」（对象及其引用对象占用的总内存）最大的对象；
    - 例如：若 `HashMap`/`ArrayList` 的 Retained Size 占老年代 50% 以上，且持续存在，大概率是该集合未清理，导致内存泄漏；

- Step 2：查看 “Leak Suspects”（泄漏怀疑） ：

    - MAT 会自动分析并生成泄漏报告，例如 “1 个 `com.example.UserCache` 对象占用 400MB 内存，引用链为 `Main -> UserCache -> HashMap -> Entry`”，直接指向可疑对象；

- Step 3：过滤关键对象 ：

    - 关注自定义业务对象（如 `User`、`Order`）、缓存对象（如 `RedisCache`、本地缓存）、集合对象（`HashMap`、`LinkedList`），排除 JDK 系统对象（如 `String`、`Thread`）。

### 三、第三步：追溯对象的 “诞生地”（创建位置）与生命周期

找到泄漏 / 大对象后，核心是搞清楚：**对象在代码中哪里创建？被谁引用导致无法回收？是频繁创建还是创建后一直不释放？**

#### 1. 方法 1：通过堆快照的 “引用链” 定位引用者

- 在 MAT/VisualVM 中，选中泄漏对象（如```UserCache```），查看「Incoming References」（入引用）：

- 引用链示例：`UserCache@0x1234 -> ApplicationContext@0x5678 -> Main@0x9abc`
- 解读：`UserCache` 被 Spring 容器 `ApplicationContext` 引用，而 Spring 容器是单例（生命周期与进程一致），导致 `UserCache` 无法被回收；

- 关键：若引用链中存在「长生命周期对象持有短生命周期对象」（如单例缓存持有大量临时 `User` 对象），就是泄漏根源。

#### 2. 方法 2：通过 “对象创建栈” 定位代码位置（关键！）

堆快照默认不包含对象的创建栈，需提前开启 JVM 参数记录创建位置，再导出快照：








```bash
# 开启对象创建栈跟踪（JDK 8+，会轻微影响性能，线上可临时开启）
-XX:+UnlockCommercialFeatures -XX:+FlightRecorder
# 或用 async-profiler（无侵入，推荐线上）
# 先下载 async-profiler：https://github.com/jvm-profiling-tools/async-profiler
./profiler.sh start -e alloc -f /path/to/alloc.svg PID
```

- 用 MAT 分析带创建栈的快照：
    1. 选中泄漏对象，右键 →「List Objects」→「With Inbound References」；
    2. 选中某个对象实例，右键 →「Show Nearest GC Root」→「With Stack Trace」；
    3. 此时会显示对象的 **创建栈**（如 `com.example.UserService.createUser(UserService.java:45)`），直接定位到代码中创建对象的行号；

#### 3. 方法 3：用 Arthas 动态追踪对象创建（线上无侵入）

若无法重启进程开启创建栈参数，用 Arthas 实时追踪对象的创建和引用：








```bash
# 1. 追踪某个类的对象创建（如 com.example.User）
trace -j com.example.User <init>  # 追踪构造函数调用栈
# 2. 查看对象的引用链（找到谁在持有该对象）
heapdump --live --include com.example.User  # 导出该类的存活对象
# 3. 分析引用链（Arthas 支持交互式查看）
jad com.example.UserService  # 反编译可疑类，查看是否有缓存未清理
```

#### 4. 区分：对象是 “频繁创建” 还是 “创建后不释放”

- 若对象创建频繁

（如每秒创建 thousands 个```User```对象）：

- 看创建栈对应的代码：是否在循环中创建临时对象（如 `for` 循环内 `new String()`）、是否未复用对象（如频繁创建 `HashMap` 而非复用线程池中的对象）；
- 看对象生命周期：是否是短生命周期对象，但因被长生命周期对象引用（如单例缓存）而进入老年代；

- 若对象创建次数少，但一直不释放
（如```UserCache```仅创建一次，但内部```HashMap```持续添加元素）：

- 查看对象的内部结构：集合类（`HashMap`/`List`）的 `size` 是否持续增长，是否有 `put` 无 `remove`（如缓存未设置过期时间、事件监听器未移除）；
- 验证：在代码中打印集合大小，或用 Arthas 执行 `ognl '#obj=@com.example.UserCache@instance.getMap().size()'` 查看实时大小。

### 四、第四步：代码层面验证与修复（落地关键）

根据前面的定位结果，针对性排查代码，核心关注以下场景：

#### 1. 常见内存泄漏场景与代码排查

| 泄漏场景                 | 代码排查点                                                   |
| ------------------------ | ------------------------------------------------------------ |
| 单例缓存未清理           | 单例类中的集合（如 `static HashMap`）是否有 `remove`/`clear` 逻辑？是否设置缓存过期时间？ |
| 事件监听器未移除         | 如 `addListener` 后未 `removeListener`，导致被监听者持有引用（如 Spring 事件、GUI 监听） |
| 线程池 / 线程泄漏        | 线程池是否被正确关闭？线程内是否持有大对象（如 `ThreadLocal` 未清理）？ |
| 数据库连接 / 资源未关闭  | JDBC 连接、Redis 连接是否用 `try-with-resources` 关闭？连接池配置是否合理？ |
| 长生命周期对象持有短对象 | 如 `ServletContext` 持有大量临时 `User` 对象、`Session` 未超时清理？ |

#### 2. 验证方法（避免盲目修复）

- 本地复现：根据创建栈和引用链，在本地模拟场景（如循环调用 `createUser` 方法，观察老年代内存变化）；
- 日志埋点：在可疑代码处添加日志（如缓存 `put`/`remove` 次数、集合大小），线上验证是否存在 “只增不减”；
- 灰度发布：修复后先灰度部署，通过 GC 日志和监控工具确认 Full GC 频率是否下降，老年代内存是否回落。

### 五、关键工具总结（按优先级排序）

| 工具           | 核心作用                             | 适用场景                   |
| -------------- | ------------------------------------ | -------------------------- |
| jstat + gc.log | 快速确认 Full GC 频率和内存趋势      | 线上初步排查（无侵入）     |
| Arthas         | 动态追踪对象创建、引用链、反编译代码 | 线上无侵入排查（推荐）     |
| MAT            | 深度分析堆快照，定位泄漏对象和引用链 | 线下详细分析（堆快照）     |
| VisualVM       | 可视化监控 GC、堆内存，简单堆分析    | 本地 / 测试环境排查        |
| async-profiler | 无侵入记录对象创建栈、CPU / 内存采样 | 线上无法重启时追踪创建位置 |

### 总结：定位流程口诀

1. 开日志 + 用 jstat，确认 Full GC 真因；
2. 导快照 + 用 MAT，找到泄漏大对象；
3. 查引用 + 追创建，定位代码关键点；
4. 本地复现 + 线上埋点，验证修复效果。

核心原则：**先定位 “是什么对象”，再找 “被谁引用”，最后查 “代码哪里创建 / 未释放”**，避免盲目优化 JVM 参数（如扩大老年代），掩盖内存泄漏问题。
