#### 核心区别与联系

| 日志类型 | 核心作用                                             | 存储层级                     | 生命周期                   | 联系                                                         |
| -------- | ---------------------------------------------------- | ---------------------------- | -------------------------- | ------------------------------------------------------------ |
| redo log | 保证事务持久性（ACID 的 D），崩溃后恢复未刷盘的数据  | 存储引擎层（InnoDB 特有）    | 循环写（固定大小）         | 三者配合实现「事务一致性 + 数据恢复 + 主从同步」：1. 事务提交时，redo log 先写（WAL 机制），binlog 后写；2. 崩溃恢复时，redo log 恢复未刷盘数据，undo log 回滚未提交事务；3. 主从同步时，binlog 作为数据同步的数据源。 |
| undo log | 保证事务原子性（ACID 的 A），实现事务回滚；支持 MVCC | 存储引擎层（InnoDB 特有）    | 事务提交后可删除（或归档） |                                                              |
| binlog   | 记录所有数据修改操作，用于主从同步、数据备份         | 服务器层（所有存储引擎通用） | 追加写（文件轮转）         |                                                              |

#### 追问应答

1. **三者的写入时机**：

   - redo log：事务执行过程中「实时写入」（但先写内存 buffer，定期刷盘），事务提交时调用 `fsync` 刷盘（WAL 机制，Write-Ahead Logging）；
   - undo log：事务执行过程中「实时写入」（与 redo log 类似，先写 buffer），每个修改操作都会生成对应的 undo 记录；
   - binlog：事务提交时「一次性写入」（先写内存，再刷盘），只有事务提交成功才会记录 binlog。

2. **崩溃恢复时的执行顺序**：

   1. 先执行「redo log 恢复」：将 redo log 中已提交但未刷盘的数据刷到磁盘，保证持久性；
   2. 再执行「undo log 回滚」：将未提交的事务通过 undo log 回滚，保证原子性；
   3. 最后通过 binlog 校验数据一致性（避免 redo log 和 binlog 不一致）。

3. **binlog 的两种格式区别及适用场景**：

   - statement 格式

     ：记录 SQL 语句（如```update t set a=1 where id=1``` ）；

     - 优势：日志量小，性能好；
     - 劣势：部分 SQL 函数（如 `now()`、`rand()`）会导致主从数据不一致；
     - 适用场景：简单 SQL 场景，主从数据一致性要求不高。

   - row 格式

     ：记录数据行的「修改前后状态」（如```id=1 的行，a 从 0 改为 1```）；

     - 优势：主从数据一致性强，支持所有 SQL 场景；
     - 劣势：日志量大，性能略差；
     - 适用场景：复杂 SQL 场景（如关联查询、函数调用），主从同步要求严格（生产环境首选）。
