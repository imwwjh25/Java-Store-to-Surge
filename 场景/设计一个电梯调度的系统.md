设计电梯调度系统需要兼顾**实用性、高效性和用户体验**，核心解决**请求处理、电梯调度算法、状态管理**三大问题。以下从需求分析、系统架构、核心模块设计、调度算法、运行流程等方面展开：

### 一、需求分析

#### 1. 核心功能需求

- 处理两种请求：**外部请求**（楼层外的上 / 下按钮）、**内部请求**（电梯内的目标楼层按钮）；
- 支持单 / 多部电梯协同工作；
- 实时反馈电梯状态（当前楼层、运行方向、门状态、任务队列）；
- 高效调度，减少用户等待时间和电梯能耗。

#### 2. 非功能需求

- 低延迟：请求响应时间≤100ms；
- 可扩展：支持动态增减电梯数量；
- 容错性：处理电梯故障（如卡层）时自动分配请求到其他电梯。

### 二、系统架构设计

电梯调度系统分为**四层结构**，自上而下职责清晰：

plaintext











```plaintext
┌─────────────────┐
│ 用户交互层      │ 接收外部/内部请求，展示电梯状态
├─────────────────┤
│ 请求管理层      │ 统一存储、去重、分发请求
├─────────────────┤
│ 核心调度层      │ 实现调度算法，分配请求到电梯，规划运行路线
├─────────────────┤
│ 电梯执行层      │ 单个电梯的状态管理和物理操作（开门、运行、停止）
└─────────────────┘
```

### 三、核心模块设计

#### 1. 数据模型：Request（请求类）

封装请求的核心属性，区分请求类型：

java



运行









```java
public class Request {
    // 请求类型：外部(OUTER)/内部(INNER)
    public enum RequestType { OUTER, INNER }
    // 运行方向：上(UP)/下(DOWN)/无(NONE)（内部请求无方向）
    public enum Direction { UP, DOWN, NONE }

    private RequestType type;    // 请求类型
    private int floor;           // 请求楼层
    private Direction direction; // 运行方向（仅外部请求）
    private long timestamp;      // 请求时间戳（用于优先级）
    private boolean isProcessed; // 是否已处理

    // 构造器、getter/setter
}
```

#### 2. 电梯执行层：Elevator（电梯实例类）

管理单个电梯的状态和操作，是调度算法的执行单元：

java



运行









```java
public class Elevator {
    // 电梯状态：空闲(IDLE)/运行(RUNNING)/开门(OPEN)/故障(FAULT)
    public enum Status { IDLE, RUNNING, OPEN, FAULT }
    // 运行方向：上(UP)/下(DOWN)/停(STOP)
    public enum Direction { UP, DOWN, STOP }

    private int id;                 // 电梯ID
    private int currentFloor;       // 当前楼层
    private Direction direction;    // 运行方向
    private Status status;          // 电梯状态
    private Queue<Request> taskQueue; // 待处理任务队列（按调度顺序排序）
    private final int minFloor = 1; // 最低楼层
    private final int maxFloor = 20;// 最高楼层

    // 核心方法
    // 1. 运行到目标楼层（模拟物理移动，含楼层切换延迟）
    public void moveTo(int targetFloor) {
        if (status == Status.FAULT) return;
        status = Status.RUNNING;
        // 模拟楼层移动：每楼层耗时500ms
        while (currentFloor != targetFloor) {
            currentFloor += (direction == Direction.UP) ? 1 : -1;
            try { Thread.sleep(500); } catch (InterruptedException e) {}
        }
        stop(); // 到达目标楼层后停止
    }

    // 2. 开门/关门（含停留时间）
    public void openDoor() {
        status = Status.OPEN;
        try { Thread.sleep(2000); } // 开门停留2秒
        catch (InterruptedException e) {}
        closeDoor();
    }
    public void closeDoor() { status = Status.IDLE; }

    // 3. 添加任务到队列
    public void addTask(Request request) { taskQueue.add(request); }

    // 4. 处理当前任务（执行开门、运行等操作）
    public void processCurrentTask() { /* 见运行流程 */ }
}
```

#### 3. 请求管理层：RequestManager

统一接收请求，去重后转发给调度器，避免重复处理：

java



运行









```java
public class RequestManager {
    private final Scheduler scheduler;
    // 存储未处理的请求（去重：同一楼层+方向的外部请求仅保留一个）
    private final Set<Request> pendingRequests = new HashSet<>();

    public RequestManager(Scheduler scheduler) { this.scheduler = scheduler; }

    // 接收请求并去重
    public void receiveRequest(Request request) {
        // 外部请求去重：相同楼层+方向视为同一请求
        if (request.getType() == Request.RequestType.OUTER) {
            boolean isDuplicate = pendingRequests.stream()
                .anyMatch(r -> r.getFloor() == request.getFloor() 
                            && r.getDirection() == request.getDirection());
            if (isDuplicate) return;
        }
        pendingRequests.add(request);
        // 转发给调度器
        scheduler.dispatchRequest(request);
    }

    // 标记请求为已处理
    public void markProcessed(Request request) {
        request.setProcessed(true);
        pendingRequests.remove(request);
    }
}
```

#### 4. 核心调度层：Scheduler（调度器）

实现调度算法，是系统的核心。支持**单电梯 LOOK 算法**和**多电梯负载均衡**：

java



运行









```java
public class Scheduler {
    private final List<Elevator> elevators; // 管理所有电梯实例

    public Scheduler(List<Elevator> elevators) { this.elevators = elevators; }

    // 分发请求到最优电梯（多电梯场景）
    public void dispatchRequest(Request request) {
        Elevator bestElevator = selectBestElevator(request);
        bestElevator.addTask(request);
        // 触发电梯处理任务
        bestElevator.processCurrentTask();
    }

    // 选择最优电梯：优先选“同方向且最近”的电梯
    private Elevator selectBestElevator(Request request) {
        Elevator best = null;
        int minDistance = Integer.MAX_VALUE;

        for (Elevator elevator : elevators) {
            if (elevator.getStatus() == Elevator.Status.FAULT) continue;

            // 计算电梯到请求楼层的距离
            int distance = Math.abs(elevator.getCurrentFloor() - request.getFloor());
            // 判断方向是否匹配：电梯运行方向与请求方向一致，且请求楼层在电梯前进路径上
            boolean isSameDirection = isDirectionMatch(elevator, request);

            // 优先选择同方向且距离最近的电梯
            if (isSameDirection && distance < minDistance) {
                minDistance = distance;
                best = elevator;
            }
        }

        // 若无同方向电梯，选距离最近的空闲电梯
        if (best == null) {
            for (Elevator elevator : elevators) {
                if (elevator.getStatus() == Elevator.Status.IDLE) {
                    int distance = Math.abs(elevator.getCurrentFloor() - request.getFloor());
                    if (distance < minDistance) {
                        minDistance = distance;
                        best = elevator;
                    }
                }
            }
        }

        // 若仍无最优解，选第一个非故障电梯
        return best != null ? best : elevators.get(0);
    }

    // 判断电梯与请求的方向是否匹配
    private boolean isDirectionMatch(Elevator elevator, Request request) {
        Elevator.Direction elevatorDir = elevator.getDirection();
        Request.Direction reqDir = request.getDirection();

        if (elevatorDir == Elevator.Direction.STOP) return true; // 电梯空闲
        if (reqDir == Request.Direction.NONE) return true; // 内部请求

        // 外部请求：电梯向上且请求楼层≥当前楼层，或向下且请求楼层≤当前楼层
        return (elevatorDir == Elevator.Direction.UP && request.getFloor() >= elevator.getCurrentFloor() && reqDir == Request.Direction.UP)
            || (elevatorDir == Elevator.Direction.DOWN && request.getFloor() <= elevator.getCurrentFloor() && reqDir == Request.Direction.DOWN);
    }

    // 单电梯LOOK算法：规划任务队列顺序
    public void optimizeTaskQueue(Elevator elevator) {
        List<Request> tasks = new ArrayList<>(elevator.getTaskQueue());
        int currentFloor = elevator.getCurrentFloor();
        Elevator.Direction dir = elevator.getDirection();

        // 按方向分组：先处理当前方向的请求，再处理反向请求
        List<Request> sameDirTasks = new ArrayList<>();
        List<Request> oppositeDirTasks = new ArrayList<>();

        for (Request task : tasks) {
            if (dir == Elevator.Direction.UP && task.getFloor() >= currentFloor) {
                sameDirTasks.add(task);
            } else if (dir == Elevator.Direction.DOWN && task.getFloor() <= currentFloor) {
                sameDirTasks.add(task);
            } else {
                oppositeDirTasks.add(task);
            }
        }

        // 同方向任务按楼层排序（向上升序，向下降序）
        if (dir == Elevator.Direction.UP) {
            sameDirTasks.sort(Comparator.comparingInt(Request::getFloor));
        } else {
            sameDirTasks.sort((a, b) -> Integer.compare(b.getFloor(), a.getFloor()));
        }

        // 合并队列：同方向任务优先，再反向任务
        Queue<Request> optimizedQueue = new LinkedList<>();
        optimizedQueue.addAll(sameDirTasks);
        optimizedQueue.addAll(oppositeDirTasks);

        // 更新电梯任务队列
        elevator.setTaskQueue(optimizedQueue);
    }
}
```

#### 5. 系统入口：ElevatorSystem

协调各模块，提供系统启动和请求入口：

java



运行









```java
public class ElevatorSystem {
    public static void main(String[] args) {
        // 初始化电梯（3部电梯）
        List<Elevator> elevators = Arrays.asList(new Elevator(1), new Elevator(2), new Elevator(3));
        // 初始化调度器
        Scheduler scheduler = new Scheduler(elevators);
        // 初始化请求管理器
        RequestManager requestManager = new RequestManager(scheduler);

        // 模拟外部请求：1楼向上
        requestManager.receiveRequest(new Request(Request.RequestType.OUTER, 1, Request.Direction.UP, System.currentTimeMillis()));
        // 模拟内部请求：电梯1到5楼
        requestManager.receiveRequest(new Request(Request.RequestType.INNER, 5, Request.Direction.NONE, System.currentTimeMillis()));
    }
}
```

### 四、核心调度算法：LOOK 算法（电梯算法改进版）

LOOK 算法是电梯调度的主流选择，相比传统 SCAN 算法更节能（不会运行到楼层尽头），核心逻辑：

1. 电梯按当前方向（上 / 下）运行，依次处理路径上的请求；
2. 当当前方向无未处理请求时，反向运行，处理反向请求；
3. 若无任何请求，电梯停在当前楼层（或返回 1 楼，可配置）。

#### 算法优势

- 减少无效运行（避免到楼层尽头）；
- 用户等待时间更均匀（相比 FCFS）；
- 能耗更低（相比 SSTF，无 “饥饿” 问题）。

### 五、电梯运行流程（单个电梯）

以 “外部请求：3 楼向上 → 内部请求：5 楼” 为例：

1. 电梯当前在 1 楼，状态**空闲**，方向**停**；
2. 接收 3 楼向上请求，调度器分配任务，电梯设置方向**上**；
3. 电梯从 1 楼运行到 3 楼（`moveTo(3)`），到达后停止，开门（`openDoor()`），处理外部请求；
4. 接收内部请求 5 楼，添加到任务队列，LOOK 算法优化队列（3 楼→5 楼）；
5. 电梯关门，运行到 5 楼，开门，处理内部请求；
6. 任务队列为空，电梯状态变为**空闲**，方向**停**。

### 六、扩展与优化

1. **优先级调度**：为紧急请求（如消防模式）设置最高优先级；
2. **负载均衡**：多电梯场景下，避免某部电梯任务过多（如通过任务数阈值分配）；
3. **预测调度**：根据历史请求数据预测高峰楼层，提前调度电梯；
4. **故障处理**：检测到电梯故障时，自动将其任务迁移到其他电梯，并通知维保。

### 七、总结

电梯调度系统的核心是**状态管理 + 高效调度算法**：通过 Request 封装请求，Elevator 管理单电梯状态，Scheduler 实现 LOOK 算法和负载均衡，RequestManager 统一处理请求。系统兼顾了用户体验（低等待时间）和资源效率（低能耗），可通过扩展算法适配不同场景（如商场、写字楼）。