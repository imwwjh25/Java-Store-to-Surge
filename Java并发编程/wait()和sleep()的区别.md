要理解 `wait()` 和 `sleep()` 调用后操作系统的行为，以及 `sleep()` 的唤醒机制，需要从**线程状态转换、操作系统内核调度、资源管理**三个维度拆解，以下是核心原理：

### 一、先明确核心概念

- **用户态 / 内核态**：Java 线程最终映射为操作系统的内核线程（Linux 下为 `pthread`），`wait()`/`sleep()` 都会触发线程从用户态切换到内核态执行；

- 线程状态 ：

    - Java 层面：`WAITING`（wait()）、`TIMED_WAITING`（sleep(long)）；
    - 操作系统层面（Linux）：`TASK_INTERRUPTIBLE`（可中断睡眠），区别于 `TASK_UNINTERRUPTIBLE`（不可中断）。

------

### 二、wait () 调用后，操作系统做了什么？

`wait()` 是 Object 类的方法，**必须在同步块（synchronized）中调用**，核心是 “释放锁 + 线程阻塞 + 加入等待队列”，操作系统层面的执行流程：

#### 1. 核心步骤（Linux 为例）

| 阶段        | Java 层面行为                                                | 操作系统内核行为                                             |
| ----------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 1. 前置检查 | 检查当前线程是否持有对象的 monitor 锁（无则抛 IllegalMonitorStateException） | 无（JVM 层面校验）                                           |
| 2. 释放锁   | JVM 释放 monitor 锁，唤醒该锁等待队列中的其他线程            | 内核将当前线程的锁资源标记为 “释放”，更新锁的等待队列（wake up 队列中的线程） |
| 3. 线程阻塞 | 当前线程进入对象的 “等待队列”（wait set），状态变为 WAITING/TIMED_WAITING | 内核将该线程从「运行队列」移除，状态设为 `TASK_INTERRUPTIBLE`（可中断睡眠），并将 CPU 调度给其他就绪线程；线程的 CPU 上下文（寄存器、程序计数器等）被保存到内核栈，便于唤醒后恢复 |
| 4. 等待唤醒 | 线程等待 `notify()`/`notifyAll()` 或超时（wait (long)）      | 内核监听该线程的唤醒事件（信号量 / 条件变量），此时线程不占用 CPU 资源 |
| 5. 被唤醒后 | 线程从等待队列移到锁的竞争队列，重新竞争 monitor 锁；竞争成功后恢复执行，状态回到 RUNNABLE | 内核将线程状态从 `TASK_INTERRUPTIBLE` 改为 `TASK_RUNNABLE`，加入 CPU 就绪队列，等待调度器分配时间片；恢复线程的 CPU 上下文，继续执行 |

#### 2. 关键特性

- `wait()` 必须释放锁：内核层面会释放 monitor 对应的互斥量（mutex），让其他线程能竞争锁；
- 阻塞是 “可中断的”：若线程被 `interrupt()`，内核会唤醒线程并抛出 `InterruptedException`；
- 依赖条件变量：Linux 下 JVM 用 `pthread_cond_wait()` 实现 `wait()`，底层是内核的条件变量（condition variable）。

------

### 三、sleep () 调用后，操作系统做了什么？

`sleep()` 是 Thread 类的静态方法，**不释放任何锁**，核心是 “线程阻塞 + 定时唤醒”，操作系统层面的执行流程：

#### 1. 核心步骤（Linux 为例）

| 阶段                    | Java 层面行为                                 | 操作系统内核行为                                             |
| ----------------------- | --------------------------------------------- | ------------------------------------------------------------ |
| 1. 调用 sleep (long ms) | 线程状态变为 TIMED_WAITING                    | JVM 调用内核的 `nanosleep()` 系统调用（替代老旧的 `sleep()`） |
| 2. 线程阻塞             | 放弃 CPU 执行权                               | 内核将线程从「运行队列」移除，状态设为 `TASK_INTERRUPTIBLE`；保存线程上下文，CPU 调度给其他就绪线程；内核会记录该线程的 “唤醒时间”（当前时间 + 睡眠时长） |
| 3. 睡眠期间             | 线程不执行任何代码，持有锁（若有）不释放      | 线程不占用 CPU 资源，但仍持有内核锁 / 用户态锁（如 synchronized 锁）；内核的时钟中断（timer interrupt）会周期性检查唤醒时间 |
| 4. 唤醒 / 中断          | 要么到时间自动唤醒，要么被 `interrupt()` 中断 | 见下文「sleep () 的唤醒机制」                                |
| 5. 恢复执行             | 线程状态回到 RUNNABLE                         | 内核将线程加入就绪队列，等待 CPU 调度；恢复上下文，从 `sleep()` 下一行代码继续执行 |

#### 2. 关键特性

- 不释放锁：即使持有 synchronized 锁，sleep 期间其他线程也无法获取该锁；
- 精准度依赖内核时钟：`nanosleep()` 基于系统时钟，精度受时钟中断频率影响（Linux 默认 10ms 一次）；
- 可中断：与 wait () 一样，`interrupt()` 会触发 `InterruptedException`，提前唤醒线程。

------

### 四、sleep () 是怎样唤醒的？

`sleep()` 的唤醒分为**主动唤醒（超时）** 和**被动唤醒（中断）** 两种，底层均由操作系统内核驱动：

#### 1. 主动唤醒（超时唤醒，核心）

- 原理：依赖内核的**定时器（timer）** 和**时钟中断**；
- 执行流程：
    1. 调用 `sleep(ms)` 时，JVM 向内核注册一个 “一次性定时器”，设置超时时间（ms 转换为纳秒）；
    2. 内核的时钟中断处理程序（每 10ms 左右触发一次）会遍历所有睡眠线程的定时器，检查是否到达唤醒时间；
    3. 当定时器到期，内核将线程状态从 `TASK_INTERRUPTIBLE` 改为 `TASK_RUNNABLE`，加入 CPU 就绪队列；
    4. 调度器分配时间片后，线程恢复执行，`sleep()` 方法返回。

#### 2. 被动唤醒（中断唤醒）

- 原理：依赖线程的**中断标志位**和内核的信号机制；
- 执行流程：
    1. 其他线程调用 `sleepThread.interrupt()` 时，JVM 向内核发送 `SIGINT` 信号（中断信号）；
    2. 内核检测到该信号，将睡眠线程从 `TASK_INTERRUPTIBLE` 唤醒，设置线程的 “中断标志位”；
    3. 线程恢复执行后，JVM 检查到中断标志位，抛出 `InterruptedException`，并清除中断标志位；
    4. `sleep()` 方法提前返回，线程处理异常（若未捕获则终止）。

#### 3. 特殊情况：虚假唤醒

理论上 `sleep()` 不会出现 “虚假唤醒”（区别于 `wait()`），因为 `nanosleep()` 是基于绝对时间的定时器，除非被中断，否则只会在超时后唤醒；而 `wait()` 依赖条件变量，可能因内核信号、伪唤醒等提前唤醒（需循环检查条件）。

------

### 五、wait () vs sleep () 操作系统行为核心差异

| 维度                  | wait()                             | sleep()               |
| --------------------- | ---------------------------------- | --------------------- |
| 锁处理                | 释放 monitor 锁（内核级互斥量）    | 不释放任何锁          |
| 阻塞触发              | 主动调用 + 依赖条件变量            | 主动调用 + 依赖定时器 |
| 唤醒条件              | notify ()/notifyAll ()、超时、中断 | 超时、中断            |
| 内核状态              | TASK_INTERRUPTIBLE                 | TASK_INTERRUPTIBLE    |
| 底层系统调用（Linux） | pthread_cond_wait()                | nanosleep()           |

### 总结

- `wait()`：内核层面释放锁 → 线程进入条件等待队列 → 被 notify / 超时 / 中断唤醒 → 重新竞争锁；
- `sleep()`：内核层面注册定时器 → 线程睡眠（持锁）→ 超时（时钟中断）或中断（信号）唤醒 → 直接恢复执行；
- `sleep()` 的唤醒核心是内核定时器（超时）和信号机制（中断），无虚假唤醒，而 `wait()` 需防范虚假唤醒。