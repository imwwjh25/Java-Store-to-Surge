# ArrayList 和 LinkedList 核心使用场景（从底层到实践）



核心结论：**ArrayList 适合「随机访问、少量插入删除」，LinkedList 适合「频繁在首尾 / 中间插入删除」**—— 两者的场景差异，本质是由底层数据结构决定的（数组 vs 双向链表）。

要精准选择，需先明确两者的底层特性差异，再结合业务操作的核心诉求（查询多 / 插入多、操作位置、数据量）决策。

## 一、先理清：底层结构决定核心特性



| 对比维度                    | ArrayList（底层是动态数组）                             | LinkedList（底层是双向链表）                             |
| --------------------------- | ------------------------------------------------------- | -------------------------------------------------------- |
| 随机访问（get/set (index)） | 高效（O (1)）：直接通过数组下标定位元素                 | 低效（O (n)）：需从表头 / 表尾遍历到目标索引             |
| 插入 / 删除（中间位置）     | 低效（O (n)）：需移动目标位置后的所有元素               | 高效（O (1)）：仅需修改前后节点的指针（找到节点后）      |
| 插入 / 删除（首尾位置）     | 尾部插入高效（O (1)，无扩容时）；头部插入低效（O (n)）  | 首尾插入 / 删除均高效（O (1)，双向链表有首尾指针）       |
| 内存开销                    | 连续内存块，空间利用率高（仅存元素 + 数组扩容预留空间） | 离散内存块，空间开销大（每个元素需额外存储前后节点指针） |
| 遍历效率                    | 高（数组缓存命中率高，CPU 预读优化）                    | 低（节点离散，缓存命中率低，频繁换页）                   |
| 扩容机制                    | 容量不足时扩容（默认 1.5 倍），需拷贝原数组             | 无扩容机制，按需创建节点（内存动态分配）                 |

## 二、ArrayList 核心使用场景（优先选它的情况）



ArrayList 的核心优势是「随机访问快、遍历快」，适合业务中「查询操作远多于插入删除」的场景，也是日常开发中**更常用**的列表（覆盖 80%+ 场景）。

### 1. 典型场景



#### （1）数据查询频繁，插入删除少



- 示例：系统配置列表、字典数据、用户详情列表（加载后主要用于展示 / 查询，极少修改）；
- 理由：`get(index)` 直接通过下标访问，比 LinkedList 遍历快一个数量级，遍历（for-i 循环）时数组缓存命中率高，性能更优。

#### （2）已知数据量，可提前初始化容量



- 示例：批量处理固定数量的数据（如解析 1000 条日志、查询 500 条订单记录）；
- 理由：ArrayList 可通过 `new ArrayList(1000)` 指定初始容量，避免扩容时的数组拷贝开销，空间利用率也更高。

#### （3）仅在尾部插入 / 删除数据



- 示例：日志收集、数据采集（持续往列表尾部添加数据，偶尔删除最后一条）；
- 理由：ArrayList 尾部插入无需移动元素（无扩容时 O (1)），性能与 LinkedList 相当，但遍历和查询更高效。

#### （4）需要频繁排序、查找（依赖索引）



- 示例：成绩排名列表（需排序后按索引取前 N 名）、商品列表（需按价格 / 销量排序后分页查询）；
- 理由：排序操作依赖随机访问和遍历，ArrayList 的数组结构更适配 `Collections.sort()`（底层是 Timsort，依赖连续内存的高效比较）。

### 2. 避坑提醒（ArrayList 不适合的场景）



- 不要用 ArrayList 做「频繁头部插入」（如队列的 `add(0, element)`）：每次插入需移动所有元素，1000 条数据插入头部需 50 万次移动操作，性能极差；
- 不要在大数据量下（如 10 万条）频繁在中间插入删除：移动元素的开销会导致性能骤降，此时应换 LinkedList。

## 三、LinkedList 核心使用场景（仅在这些情况选它）



LinkedList 的核心优势是「插入删除灵活」，但短板很明显（随机访问慢、遍历慢），仅适合「插入删除操作远多于查询」的特殊场景。

### 1. 典型场景



#### （1）频繁在列表中间插入 / 删除元素



- 示例：链表结构的数据处理（如链表反转、节点交换）、文本编辑器的光标插入删除（在任意位置添加 / 删除字符）；
- 理由：找到目标节点后（若已拿到节点引用，O (1)；若需通过索引找，仍需 O (n)），仅需修改前后节点的指针，无需移动其他元素，比 ArrayList 高效。

#### （2）实现队列 / 双端队列（Deque）



- 示例：任务队列（先进先出 FIFO）、消息队列（首尾添加 / 删除消息）、LRU 缓存的底层队列（需频繁首尾操作）；
- 理由：LinkedList 实现了 `Deque` 接口，提供 `addFirst()`、`removeFirst()`、`addLast()`、`removeLast()` 等方法，均为 O (1) 操作，比 ArrayList 做队列（头部操作 O (n)）高效得多。
- 注意：优先用 `LinkedList` 实现双端队列，而非手动用 ArrayList 模拟（避免头部操作的性能问题）。

#### （3）数据量不确定，频繁动态增减（且查询少）



- 示例：临时存储需要频繁添加 / 删除的中间数据（如算法中的临时节点列表、批量处理中的中间结果）；
- 理由：LinkedList 无扩容机制，添加元素时直接创建节点，删除时释放节点，无需像 ArrayList 那样预留扩容空间，也避免了数组拷贝的开销。

### 2. 避坑提醒（LinkedList 不适合的场景）



- 不要用 LinkedList 做「随机访问」（如 `get(1000)`）：需从表头遍历 1000 次，数据量越大越慢；
- 不要用 LinkedList 做「大数据量遍历」（如 for-i 循环遍历 10 万条数据）：节点离散导致缓存命中率低，遍历速度比 ArrayList 慢 5~10 倍（推荐用迭代器 `Iterator` 遍历，比 for-i 快，但仍不如 ArrayList）；
- 不要在「查询多、插入少」的场景用 LinkedList：完全浪费其插入优势，反而被查询短板拖累。

## 三、边界场景：如何精准决策？



### 1. 场景：需要「栈 / 队列」功能



- 栈（LIFO）：优先用 `ArrayDeque`（底层是循环数组，性能比 ArrayList、LinkedList 都好），次选 ArrayList（`addLast()`/`removeLast()`）；
- 队列（FIFO）：优先用 `ArrayDeque`，次选 LinkedList（`addLast()`/`removeFirst()`），坚决不用 ArrayList（头部删除 O (n)）。

### 2. 场景：数据量极小（如 <100 个元素）



- 若插入删除频繁：用 LinkedList（性能差异可忽略，代码更灵活）；
- 若查询频繁：用 ArrayList（遍历和访问仍更高效）；
- 结论：数据量小时，两者性能差异不大，可按代码习惯选择，但 ArrayList 更通用。

### 3. 场景：需要并发操作



- 两者均为线程不安全！若需并发，需用 `Collections.synchronizedList(list)` 包装，或直接用 `CopyOnWriteArrayList`（适合读多写少）；
- 注意：LinkedList 即使包装后，中间插入删除的线程安全开销仍比 ArrayList 大，并发场景下优先选 `CopyOnWriteArrayList`（底层是数组，线程安全实现更高效）。

## 四、实践选择决策树（快速判断）



plaintext

```plaintext
业务场景
├─ 核心操作是「查询（get/set）、遍历」→ ArrayList
├─ 核心操作是「插入删除」
│  ├─ 插入删除在「首尾」→ LinkedList / ArrayDeque（优先）
│  └─ 插入删除在「中间」→ LinkedList
├─ 数据量极小（<100）→ 按代码习惯，优先 ArrayList
└─ 并发场景 → CopyOnWriteArrayList（替代两者）
```



## 五、核心总结



1. 日常开发**优先选 ArrayList**：除非明确需要「频繁在中间插入删除」，否则 ArrayList 的通用性、查询效率、遍历性能都更优；
2. LinkedList 仅适合「特殊场景」：如双端队列、频繁中间插入删除，且需接受其随机访问慢、内存开销大的短板；
3. 避坑关键：不要用 LinkedList 做随机访问（get (index)），不要用 ArrayList 做频繁头部插入删除；
4. 替代方案：实现栈 / 队列时，`ArrayDeque` 性能优于 LinkedList，优先考虑。

简单说：「查多用 ArrayList，插删多用 LinkedList」，但需精准区分「插删的位置和频率」，避免盲目选择。
