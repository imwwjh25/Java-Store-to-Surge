
### 1. 读取输入并初步处理

- 终端（Terminal）会捕获你输入的字符，当按下回车时，终端会将输入的命令字符串传递给当前的 **Shell 进程**（比如 Bash、Zsh 等，默认是 Bash）。

- Shell 首先会对输入进行

  预处理：

    - **去除首尾空格**：忽略命令前后的空白字符。
    - **处理转义字符**：识别 `\` 转义符，比如 `echo "hello\ world"` 会解析为 `hello world`。
    - **处理通配符**：解析 `*`、`?`、`[]` 等通配符，匹配对应的文件（比如 `ls *.txt` 会匹配所有 `.txt` 文件）。
    - **处理变量替换**：识别 `$` 开头的变量，比如 `echo $PATH` 会替换为环境变量 `PATH` 的值。
    - **处理管道与重定向**：识别 `|`（管道）、`>`（输出重定向）、`<`（输入重定向）、`>>`（追加重定向）等符号，规划命令的执行流向。

### 2. 解析命令：拆分命令与参数

Shell 将预处理后的字符串**按空格拆分为 “命令名” 和 “参数列表”**。

- 例如输入```ls -l /home```，Shell 会拆分为：

- 命令名：`ls`
- 参数列表：`-l`、`/home`

- 特殊情况处理：

    - 如果包含管道（如 `ps aux | grep java`），Shell 会拆分为多个命令，为每个命令创建独立的子进程，并建立管道通信。
    - 如果包含重定向（如 `echo hello > test.txt`），Shell 会先打开目标文件，将命令的输出流重定向到该文件。

### 3. 查找命令的可执行文件

Shell 需要确定命令对应的**可执行程序的位置**，查找顺序如下：

1. **判断是否为内置命令**Shell 内置了一批常用命令（比如 `cd`、`echo`、`pwd`、`export` 等），这些命令无需调用外部程序，直接由 Shell 自身执行。
    - 可以用 `type 命令` 查看是否为内置命令，例如 `type cd` 会输出 `cd is a shell builtin`。
2. **判断是否为别名（Alias）**用户可以通过 `alias` 定义命令别名（比如 `alias ll='ls -l'`），Shell 会优先检查输入的命令是否为已定义的别名，如果是，则替换为对应的原始命令。
    - 用 `alias` 命令可以查看所有已定义的别名。
3. **通过 `PATH` 环境变量查找外部命令**如果是外部命令（比如 `ls`、`cp`、`java` 等），Shell 会遍历 `PATH` 环境变量中定义的目录，查找与命令名匹配的可执行文件。
    - `PATH` 是一个以冒号分隔的目录列表，例如：`/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin`。
    - 可以用 `echo $PATH` 查看当前的 `PATH` 配置，用 `which 命令` 查看命令的具体路径（比如 `which ls` 会输出 `/usr/bin/ls`）。
4. **查找失败的处理**如果遍历完 `PATH` 所有目录都没有找到对应的可执行文件，Shell 会输出错误信息：`command not found`。

### 4. 创建子进程执行命令（Fork & Exec）

对于**外部命令**，Shell 会通过 **`fork()` + `exec()`** 系统调用创建子进程执行命令：

1. **`fork()` 系统调用**Shell 进程调用 `fork()` 复制一个**子进程**，子进程与父进程（Shell）拥有完全相同的内存空间、环境变量。此时子进程的代码和数据与父进程一致。
2. **`exec()` 系统调用**子进程调用 `exec()` 系列函数（比如 `execve()`），**替换自身的代码段和数据段**为目标命令的可执行程序。
    - `exec()` 会加载可执行文件（ELF 格式）到内存，初始化程序的堆栈、环境变量，然后跳转到程序的入口点（`main` 函数）开始执行。
    - 注意：`exec()` 执行成功后，子进程的原代码会被覆盖，不会返回；只有执行失败时才会返回错误。
3. **内置命令的特殊处理**内置命令**不会创建子进程**，直接在 Shell 进程中执行。这也是为什么 `cd` 命令必须是内置命令 —— 如果创建子进程执行 `cd`，只会改变子进程的工作目录，父进程（Shell）的工作目录不会受到影响。

### 5. 处理命令的输入输出

命令执行过程中，Shell 会根据重定向 / 管道规则处理输入输出流：

- **标准输入（stdin，fd=0）**：默认来自终端键盘输入。
- **标准输出（stdout，fd=1）**：默认输出到终端屏幕。
- **标准错误（stderr，fd=2）**：默认输出到终端屏幕。
- **重定向**：比如 `ls > test.txt` 会将 `stdout` 重定向到 `test.txt`；`ls 2> error.log` 会将 `stderr` 重定向到 `error.log`。
- **管道**：比如 `ps aux | grep java` 会将前一个命令的 `stdout` 作为后一个命令的 `stdin`，两个命令的子进程通过管道文件（内核中的缓冲区）通信。

### 6. 等待命令执行完成并返回状态码

1. **父进程等待子进程**Shell 进程（父进程）会调用 `waitpid()` 系统调用，**阻塞等待子进程执行完成**。
    - 如果命令是后台执行（比如 `sleep 10 &`，末尾加 `&`），Shell 不会阻塞，而是直接返回，子进程在后台运行。
2. **获取退出状态码**子进程执行完成后会退出，并返回一个 **退出状态码（Exit Code）**：
    - 状态码 `0` 表示命令执行成功。
    - 非 `0` 状态码表示执行失败（不同的非 0 值对应不同的错误原因）。
    - 可以通过 `echo $?` 查看上一个命令的退出状态码。
3. **清理子进程（避免僵尸进程）**子进程退出后，父进程（Shell）通过 `waitpid()` 获取其退出状态，内核会释放子进程的资源。如果父进程没有及时等待，子进程会变成**僵尸进程**。

### 7. Shell 回到等待输入状态

命令执行完成后，Shell 会清空当前行的输出，然后打印**命令提示符**（比如 `user@hostname:~$`），等待用户输入下一条命令。

### 举个例子：执行 `ls -l /home` 的完整流程

1. 终端将 `ls -l /home` 传递给 Bash。
2. Bash 预处理：无转义 / 变量，拆分为命令 `ls`，参数 `-l`、`/home`。
3. Bash 检查：`ls` 不是内置命令，遍历 `PATH` 找到 `/usr/bin/ls`。
4. Bash 调用 `fork()` 创建子进程。
5. 子进程调用 `execve("/usr/bin/ls", ["ls", "-l", "/home"], env)`，加载 `ls` 程序执行。
6. `ls` 程序读取 `/home` 目录，按长格式输出，默认输出到终端。
7. 子进程执行完成，退出状态码 `0`。
8. Bash 调用 `waitpid()` 获取状态码，打印提示符等待下一次输入。
