Redis 本身的单条命令（如 `SET NX EX`）虽能实现分布式锁的 “加锁” 逻辑，但**释放锁、锁续约、复杂校验等核心操作需要多步命令协同**，而 Redis 单条命令的原子性无法覆盖多步逻辑。Lua 脚本的核心价值是**将多步命令打包为一个原子操作**，彻底解决 “多步操作中因网络中断、并发竞争导致的逻辑混乱”，这是纯 Redis 命令组合无法实现的。

## 一、先明确：Redis 命令的原子性边界

Redis 的原子性是 “**单条命令的原子性**”—— 即一条命令要么完全执行，要么完全不执行，不会被其他命令打断。但如果操作需要**多条命令连续执行**（如 “校验锁持有者 → 删除锁”），这些命令之间会存在 “间隙”，无法保证原子性：

- 例：释放锁需两步：`GET lock_key`（校验持有者）→ `DEL lock_key`（删除锁）；
- 风险：两步之间若发生网络中断、锁过期被他人获取，会导致 “误删他人锁”（如客户端 A 校验通过后，锁过期被 B 获取，A 仍执行 `DEL` 删除 B 的锁）。

而 Lua 脚本在 Redis 中是 “**整体原子执行**” 的 —— 脚本中的所有命令会被当作一个整体，执行过程中不会被其他客户端的命令打断，相当于把 “多步操作” 封装成了 “一条自定义原子命令”。

## 二、核心场景：纯 Redis 命令无法解决的问题，Lua 脚本能解决

以下是分布式锁的 3 个核心场景，纯 Redis 命令组合存在致命缺陷，而 Lua 脚本能完美解决：

### 场景 1：释放锁的 “校验 + 删除” 原子性（最核心需求）

释放锁是分布式锁最容易出问题的环节，纯 Redis 命令无法保证 “校验持有者” 和 “删除锁” 的原子性，而 Lua 脚本可以。

#### 纯 Redis 命令的缺陷（释放锁）：






```bash
# 步骤1：客户端 A 校验锁持有者（GET 命令）
127.0.0.1:6379> GET lock_key
"client_A_id"  # 校验通过，准备删除

# 【风险间隙】：此时锁过期，客户端 B 加锁成功，lock_key 变为 "client_B_id"

# 步骤2：客户端 A 执行删除（DEL 命令）
127.0.0.1:6379> DEL lock_key
(integer) 1  # 误删了客户端 B 的锁！
```

- 原因：两步命令之间存在 “时间间隙”，可能发生锁过期、网络延迟等，导致误删。

#### Lua 脚本的解决方案（释放锁）：

将 “校验 + 删除” 打包成一个 Lua 脚本，Redis 会原子执行：








```lua
-- 释放锁的 Lua 脚本：仅当锁持有者是当前客户端时，才删除锁
if redis.call("GET", KEYS[1]) == ARGV[1] then
    return redis.call("DEL", KEYS[1])  -- 校验通过，删除锁
else
    return 0  -- 校验失败，不删除
end
```

- 执行命令：`EVAL "脚本内容" 1 lock_key client_A_id`
- 效果：脚本执行过程中不会被其他命令打断，要么 “校验通过并删除”，要么 “校验失败不删除”，彻底避免误删。

### 场景 2：锁续约的 “判断 + 续期” 原子性（防锁过期）

分布式锁需要 “锁续约”（如业务执行超时，需延长锁过期时间），但续约前需先判断 “锁是否仍被当前客户端持有”，纯 Redis 命令无法保证这两步的原子性。

#### 纯 Redis 命令的缺陷（锁续约）：









```bash
# 步骤1：客户端 A 判断锁是否还在自己手里
127.0.0.1:6379> GET lock_key
"client_A_id"  # 判断通过，准备续期

# 【风险间隙】：锁突然过期，客户端 B 加锁成功，lock_key 变为 "client_B_id"

# 步骤2：客户端 A 续期
127.0.0.1:6379> EXPIRE lock_key 30
(integer) 1  # 误将客户端 B 的锁续期了！
```

- 后果：B 的锁被 A 延长过期时间，导致 B 的业务执行完后，锁无法释放，其他客户端无法加锁。

#### Lua 脚本的解决方案（锁续约）：

将 “判断 + 续期” 打包成 Lua 脚本，原子执行：




```lua
-- 锁续约的 Lua 脚本：仅当锁持有者是当前客户端时，才续期
if redis.call("GET", KEYS[1]) == ARGV[1] then
    return redis.call("EXPIRE", KEYS[1], ARGV[2])  -- 续期为 ARGV[2] 秒
else
    return 0  -- 不是自己的锁，不续期
end
```

- 执行命令：`EVAL "脚本内容" 1 lock_key client_A_id 30`
- 效果：只有锁仍属于 A 时才续期，避免误续他人锁。

### 场景 3：复杂锁逻辑的原子性（如 “加锁 + 记录业务信息”）

有时分布式锁需要附加业务逻辑（如加锁时同时记录 “锁持有者 + 业务 ID”，释放时同时清理业务信息），纯 Redis 命令需要多步操作，存在原子性风险。

#### 纯 Redis 命令的缺陷（复杂加锁）：






```bash
# 步骤1：加锁（SET NX EX）
127.0.0.1:6379> SET lock_key client_A_id NX EX 30
OK  # 加锁成功

# 【风险间隙】：客户端 A 突然崩溃，未记录业务信息

# 步骤2：记录业务信息（HSET）
127.0.0.1:6379> HSET lock_biz_info lock_key "order_123"
# 未执行，导致锁存在但业务信息缺失，后续无法清理
```

- 后果：锁无法关联业务信息，后续运维无法判断锁的用途，只能等锁过期，浪费资源。

#### Lua 脚本的解决方案（复杂加锁）：

将 “加锁 + 记录业务信息” 打包成 Lua 脚本，原子执行：


```lua
-- 复杂加锁的 Lua 脚本：加锁成功后，同步记录业务信息
if redis.call("SET", KEYS[1], ARGV[1], "NX", "EX", ARGV[2]) == "OK" then
    redis.call("HSET", KEYS[2], KEYS[1], ARGV[3])  -- 记录锁与业务 ID 的关联
    return 1  -- 加锁成功
else
    return 0  -- 加锁失败
end
```

- 执行命令：`EVAL "脚本内容" 2 lock_key lock_biz_info client_A_id 30 order_123`
- 效果：要么 “加锁 + 记录业务信息” 都成功，要么都失败，避免数据不一致。

## 三、Lua 脚本的额外优势：减少网络交互

除了原子性，Lua 脚本还能**减少客户端与 Redis 之间的网络交互次数**，提升性能：

- 纯 Redis 命令：释放锁需 2 次网络请求（`GET` → `DEL`）；
- Lua 脚本：释放锁只需 1 次网络请求（`EVAL` 脚本）。

在高并发场景下（如每秒 10 万次释放锁），网络交互次数减少一半，能显著降低网络延迟和 Redis 服务器的请求压力。

## 四、总结：为什么必须用 Lua 脚本？

纯 Redis 命令的原子性只能覆盖 “单步操作”（如加锁），但分布式锁的完整逻辑（释放、续约、复杂校验）需要 “多步操作”，这些操作之间的间隙会导致 **误删锁、误续期、数据不一致** 等致命问题。

Lua 脚本的核心价值是：

1. **保证多步操作的原子性**：将多步命令打包为一个整体，执行过程不被打断，解决纯命令的核心缺陷；
2. **减少网络交互**：一次请求完成多步操作，提升高并发场景下的性能；
3. **简化逻辑**：复杂锁逻辑（如校验、续期、业务记录）可在脚本中集中实现，避免客户端代码繁琐且易出错。

简单说：**纯 Redis 命令能实现分布式锁的 “半成品”，而 Lua 脚本能实现 “完整、安全、高效的分布式锁”**—— 这就是为什么工业级分布式锁（如 Redisson）都依赖 Lua 脚本的根本原因。