在AQS（AbstractQueuedSynchronizer）中使用的是基于 **CLH（Craig, Landin, and Hagersten）锁队列** 的双向链表，而不是普通的无锁链表，主要原因包括以下几点：

------

### 1. **公平性和顺序保证**



AQS的目的是构建同步组件（如锁、信号量等），需要保证线程按 **FIFO顺序** 获取锁，避免线程“插队”或“饥饿”。

- CLH队列是一种**基于前驱节点状态检查**的自旋锁队列，能够保证线程按照入队顺序有序等待。
- 结构上是一个链表，保证了先进先出（FIFO）队列的特性。

------

### 2. **避免竞争和自旋效率**



- CLH是一种**自旋锁队列**，每个线程只需要检查自己前驱节点的状态来判断是否可获取锁，减少了对 Head 节点的竞争。
- AQS改造的CLH队列是阻塞式的，但借鉴了CLH的思想，即线程关心的是**自己前驱状态**，在释放锁时只需通知后继节点，这样减少了跨节点的无谓竞争。

------

### 3. **线程阻塞与唤醒方便**



- 与传统的自旋CLH不同，AQS采用`LockSupport.park()`/`unpark()`机制阻塞和唤醒线程，只有队首线程会被唤醒尝试获取锁，后面的线程一直阻塞，这样提升了资源利用率，减少CPU占用。
- 这种设计需要一个链表结构来维护线程的等待顺序，而普通链表（无头尾指针，单向，无前驱引用）不利于高效定位和管理等待节点。

------

### 4. **双向链表结构的优势**



- AQS中的队列是基于 CLH 队列进行了改进，实际上是一个**双向链表**，每个节点有前驱（prev）和后继（next）指针。
- 双向链表便于：
    - 在节点取消等待（timeout、interrupt）时快速移除节点。
    - 从队尾快速入队，从队头快速出队。
    - 避免遍历全链表提升效率。

普通的单向链表就不具备这些便利，尤其节点移除时可能导致遍历操作，效率低下。

------

### 5. **线程安全和并发性**



- AQS队列的节点插入和移除在多线程高并发下，需要原子操作（CAS）保证，CLH队列设计方便无锁（或低锁）操作，节点状态和指针状态局部更新，降低竞争。
- 普通链表如果没有设计良好的并发控制，容易产生竞争条件，导致状态不一致。

------

### 总结



| 特点     | CLH队列（AQS队列改进版）  | 普通链表                   |
| -------- | ------------------------- | -------------------------- |
| 结构     | 双向链表，有头尾指针      | 单向链表或无头链表         |
| 顺序保证 | FIFO且每节点关注前驱状态  | 仅单向遍历，顺序保证差     |
| 线程阻塞 | 利用前驱节点状态减少竞争  | 不方便高效管理阻塞线程     |
| 节点移除 | 可快速移除 中途退出的节点 | 可能需遍历，效率低         |
| 并发安全 | 支持CAS原子操作改进性能   | 缺少原子操作支持，容易竞争 |

------

因此，AQS使用基于CLH的双向链表队列来管理线程等待队列，既保证了公平性、顺序性，也提高了并发性能和资源利用率，而普通链表无法满足这些需求。