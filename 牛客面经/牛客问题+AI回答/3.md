## [虾皮一面 10.19](https://www.nowcoder.com/discuss/677198528015310848?sourceSSR=users)


### 一、JVM 相关



#### 1. JVM 内存结构（基于 Java 8）



JVM 内存结构分为 **线程私有区** 和 **线程共享区**，核心结构如下：

| 区域                       | 归属     | 作用                                     | 垃圾回收             | 异常场景                  |
| -------------------------- | -------- | ---------------------------------------- | -------------------- | ------------------------- |
| 程序计数器（PC）           | 线程私有 | 记录当前线程执行的字节码指令地址         | 不回收               | 无（唯一不会 OOM 的区域） |
| 虚拟机栈（Stack）          | 线程私有 | 存储方法调用栈帧（局部变量、操作数栈等） | 不回收               | StackOverflowError/OOM    |
| 本地方法栈（Native Stack） | 线程私有 | 支持 Native 方法执行（如 JNI 调用）      | 不回收               | StackOverflowError/OOM    |
| 方法区（Metaspace）        | 线程共享 | 存储类元信息（类名、方法、注解）、常量池 | 部分回收（如无用类） | OOM（Metaspace 溢出）     |
| 堆（Heap）                 | 线程共享 | 存储对象实例和数组                       | 主要回收区           | OOM（堆内存不足）         |

**关键补充**：Java 8 取消永久代（PermGen），用 Metaspace 替代，Metaspace 物理内存基于本地内存（而非 JVM 堆），默认无上限（可通过 `-XX:MaxMetaspaceSize` 限制）。

#### 2. 堆的垃圾回收（核心流程）



堆是 GC 核心区域，按分代模型分为 **年轻代（Young Gen）** 和 **老年代（Old Gen）**（Java 8 无永久代），垃圾回收流程如下：

1. **标记阶段**：通过「可达性分析」（以 GC Roots 为起点，遍历对象引用链）标记存活对象（未被标记的为垃圾）；
2. **清除阶段**：回收垃圾对象占用的内存（不同算法实现不同）；
3. **整理阶段**：解决内存碎片（部分算法无需此步骤）。

**GC Roots 包括**：虚拟机栈局部变量、本地方法栈引用对象、方法区类静态变量、常量池引用、活跃线程等。

#### 3. 年轻代用复制算法的原因



年轻代特性：**对象存活率极低（90%+ 新对象很快成为垃圾）、空间小**，复制算法完美适配这些特性：

- 复制算法原理：将年轻代分为「Eden 区」和两个大小相等的「Survivor 区（From/To）」，默认比例 8:1:1。新对象先分配到 Eden 区，Minor GC 时：
    1. 标记 Eden 和 From 区的存活对象；
    2. 将存活对象复制到 To 区（按顺序排列，无内存碎片）；
    3. 清空 Eden 和 From 区，交换 From 和 To 区角色。
- 选择原因：
    1. 效率高：存活对象少，复制成本低（比标记 - 清除 / 标记 - 整理快）；
    2. 无内存碎片：复制后对象连续存储，便于后续分配；
    3. 空间开销可接受：年轻代空间小，10% 的 Survivor 开销影响不大。

#### 4. 常用垃圾回收器（生产环境选型）



生产中主流选择 **G1 GC**（Java 9+ 默认），部分场景用 **ZGC/Shenandoah**（低延迟），传统回收器（CMS、Parallel Scavenge）逐步淘汰：

- **G1 GC**：面向大堆（4GB+），兼顾吞吐量和延迟，基于「区域化分代」模型，核心特点是可预测停顿时间；
- **ZGC**：低延迟回收器（停顿时间 < 10ms），支持 TB 级堆，适合高并发、低延迟场景（如金融、电商）；
- 选择依据：堆大小（大堆用 G1/ZGC）、延迟要求（低延迟用 ZGC）、JDK 版本（Java 8 可选 G1，Java 11+ 优先 ZGC）。

#### 5. G1 的大致流程



G1 将堆划分为多个大小相等的「Region」（默认 1MB~32MB），每个 Region 可动态扮演 Eden、Survivor、Old 角色，核心流程分 4 步：

1. **初始标记（Initial Mark）**：标记 GC Roots 直接引用的对象，STW（停顿时间极短）；
2. **并发标记（Concurrent Mark）**：遍历对象引用链，标记存活对象，与应用线程并发执行（无 STW）；
3. **最终标记（Final Mark）**：处理并发标记阶段的漏标对象（如写屏障记录的引用变化），STW（停顿短）；
4. **筛选回收（Live Data Counting & Evacuation）**：计算每个 Region 的垃圾占比，优先回收垃圾多的 Region（「Garbage First」由来），通过复制算法将存活对象复制到新 Region，STW（可通过 `-XX:MaxGCPauseMillis` 控制停顿时间）。

### 二、MySQL 相关



#### 1. MySQL 死锁排查（实战步骤）



死锁是两个及以上事务互相持有对方需要的锁，导致循环等待，排查流程如下：

1. **开启死锁监控**：默认 MySQL 会记录死锁日志，可通过 `show variables like 'innodb_print_all_deadlocks';` 确认（值为 ON 表示开启，OFF 则执行 `set global innodb_print_all_deadlocks = ON;` 开启）；

2. 查看死锁日志

   ：

    - 实时查看：`show engine innodb status;`（输出中找到「LATEST DETECTED DEADLOCK」部分，包含死锁事务、持有锁、等待锁信息）；
    - 日志文件：死锁日志默认写入 MySQL 错误日志（可通过 `show variables like 'log_error';` 查看日志路径）；

3. 分析死锁原因

   ：从日志中提取关键信息：

    - 事务 1/2 的 SQL 语句；
    - 事务持有锁类型（如 X 锁、S 锁）、等待锁类型；
    - 涉及的表和索引（死锁多因索引设计不合理或 SQL 执行顺序不一致）；

4. 解决措施

   ：

    - 统一事务执行顺序（如都按「先更新表 A，再更新表 B」）；
    - 优化索引（避免全表扫描导致的表锁）；
    - 减小事务粒度（拆分长事务，减少锁持有时间）；
    - 避免手动加锁（依赖 InnoDB 行锁机制）。

#### 2. 死锁日志关键信息解读



死锁日志核心字段：

- `TRANSACTION`：两个死锁事务的 ID 和状态；

- `HOLDS THE LOCK`：事务当前持有的锁；

- `WAITING FOR THIS LOCK`：事务等待的锁；

- `SQL STATEMENT`：导致死锁的 SQL 语句；

- 示例片段：

  plaintext

  ```plaintext
  TRANSACTION 12345: ACTIVE 0 sec inserting
  mysql tables in use 1, locked 1
  LOCK WAIT 2 lock struct(s), heap size 1136, 1 row lock(s)
  MySQL thread id 10, OS thread handle 1406, query id 1234 localhost root inserting
  insert into t_order (user_id, goods_id) values (1, 2)
  WAITING FOR THIS LOCK TO BE GRANTED:
  RECORD LOCKS space id 10 page no 3 n bits 72 index idx_user_id of table `test`.`t_order` trx id 12345 lock_mode X locks gap before rec insert intention waiting
  
  TRANSACTION 67890: ACTIVE 0 sec inserting
  mysql tables in use 1, locked 1
  2 lock struct(s), heap size 1136, 1 row lock(s)
  MySQL thread id 11, OS thread handle 1407, query id 1235 localhost root inserting
  insert into t_order (user_id, goods_id) values (1, 3)
  HOLDS THE LOCK(S):
  RECORD LOCKS space id 10 page no 3 n bits 72 index idx_user_id of table `test`.`t_order` trx id 67890 lock_mode X locks gap before rec
  ```



解读：事务 12345 插入时等待「X 锁（插入意向锁）」，事务 67890 持有该锁，导致死锁。

#### 3. MySQL 三种核心日志



| 日志类型             | 作用                              | 核心特点                                                     |
| -------------------- | --------------------------------- | ------------------------------------------------------------ |
| 重做日志（redo log） | 保证事务持久性（ACID 中的 D）     | 物理日志（记录「数据页修改」），循环写，崩溃恢复时重放未刷盘的修改 |
| 回滚日志（undo log） | 保证事务原子性（ACID 中的 A）     | 逻辑日志（记录「SQL 逆操作」），事务回滚时撤销修改，MVCC 依赖 undo log 实现多版本 |
| 二进制日志（binlog） | 记录所有 DDL/DML 操作（不含查询） | 逻辑日志（记录 SQL 语句或行数据），追加写，用于主从复制、数据恢复 |

#### 4. binlog 和 redo log 一致性保证（两阶段提交）



MySQL 通过「两阶段提交（2PC）」确保 binlog 和 redo log 一致，避免崩溃后数据不一致：

1. 阶段 1：准备阶段（Prepare）

   ：

    - 事务执行完所有 SQL，InnoDB 写入 redo log（标记为「准备状态」）；
    - 此时 redo log 已持久化到磁盘（确保崩溃后可恢复）；

2. 阶段 2：提交阶段（Commit）

   ：

    - MySQL 写入 binlog（持久化到磁盘）；
    - InnoDB 将 redo log 标记为「提交状态」，事务完成；

3. 崩溃恢复逻辑

   ：

    - 若崩溃在「准备阶段后，binlog 写入前」：重启后 InnoDB 发现 redo log 是「准备状态」，但无对应 binlog，回滚事务；

    - 若崩溃在「binlog 写入后，redo log 提交前」：重启后 InnoDB 发现 redo log 是「准备状态」，且有对应 binlog，提交事务；

      → 最终保证：binlog 和 redo log 要么都成功，要么都失败。

#### 5. MVCC 原理（多版本并发控制）



MVCC 是 InnoDB 实现隔离级别的核心，通过「数据多版本 + 隐藏列 + undo log + ReadView」实现并发读不加锁（快照读）：

- 核心机制

  ：

    1. 每行数据隐藏 3 列：`DB_TRX_ID`（修改事务 ID）、`DB_ROLL_PTR`（指向 undo log 的指针）、`DB_ROW_ID`（行唯一 ID）；
    2. 事务修改数据时，不直接覆盖原数据，而是生成新数据版本，记录 undo log（存储旧版本数据）；
    3. 读操作（快照读）通过 ReadView 选择可见的数据版本，避免加锁。

#### 6. 读已提交（RC）和可重复读（RR）的 ReadView 区别



ReadView 是「可见性判断规则」，核心区别在于 **ReadView 创建时机**：

| 隔离级别       | ReadView 创建时机                     | 核心效果                                   | 举例（事务 A 修改数据，事务 B 读取）                         |
| -------------- | ------------------------------------- | ------------------------------------------ | ------------------------------------------------------------ |
| 读已提交（RC） | 每次执行 SELECT 时创建新的 ReadView   | 只能看到「已提交」的事务修改，不可重复读   | 事务 B 两次 SELECT 可能读到不同结果（事务 A 中途提交）       |
| 可重复读（RR） | 事务第一次执行 SELECT 时创建 ReadView | 事务期间多次 SELECT 看到同一版本，可重复读 | 事务 B 两次 SELECT 结果一致（即使事务 A 中途提交，也看不到新版本） |

**关键补充**：RR 级别通过「ReadView 复用」避免不可重复读，RC 级别通过「每次创建 ReadView」保证读到已提交数据。

### 三、缓存相关



#### 解决缓存雪崩的方案（核心：避免缓存集中失效）



缓存雪崩是指大量缓存 key 同时过期，或缓存服务宕机，导致所有请求穿透到数据库，引发数据库雪崩。解决方案分 4 类：

1. 避免缓存集中失效

   ：

    - 过期时间加随机值：给每个 key 的过期时间加 1~300 秒随机值（如 `expire key 3600 + rand()*300`），避免同时过期；
    - 热点 key 永不过期：对核心热点 key（如首页商品）设置永不过期，通过后台异步更新缓存；

2. 提高缓存可用性

   ：

    - 缓存集群化：用 Redis Cluster 或哨兵模式，避免单点故障；
    - 降级熔断：缓存服务宕机时，通过熔断组件（如 Sentinel）直接返回默认值或错误，不穿透到数据库；

3. 数据库兜底

   ：

    - 数据库限流：用 Redis 限流或数据库连接池限制并发数，避免数据库被打垮；
    - 降级非核心接口：缓存雪崩时，暂停非核心接口（如统计接口），优先保障核心接口（如下单、支付）；

4. 缓存预热

   ：

    - 系统启动时，通过后台任务批量加载热点数据到缓存，避免启动后大量请求穿透数据库。

### 四、Spring 相关



#### 1. Spring IOC 原理



IOC（Inversion of Control，控制反转）是 Spring 核心思想，核心是「将对象的创建、依赖注入交给 Spring 容器管理，而非手动 new 对象」：

- **核心目标**：解耦组件间依赖，提高代码可维护性和可测试性；

- 核心概念

  ：

    - Bean：被 Spring 管理的对象；
    - IOC 容器：负责 Bean 的创建、依赖注入、生命周期管理（如 `ApplicationContext`、`BeanFactory`）；
    - 依赖注入（DI）：IOC 的具体实现，Spring 自动将依赖的 Bean 注入到目标 Bean 中（如 `@Autowired`、`@Resource`）；

- 实现流程

  ：

    1. 加载配置（XML / 注解 / Java Config）；
    2. 解析配置，生成 BeanDefinition（Bean 的元信息，如类名、依赖、作用域）；
    3. 实例化 Bean（根据 BeanDefinition 创建对象）；
    4. 依赖注入（将依赖的 Bean 注入到当前 Bean）；
    5. 初始化 Bean（执行 `init-method`、`BeanPostProcessor` 等）；
    6. Bean 就绪，供应用调用；
    7. 容器关闭时销毁 Bean（执行 `destroy-method`）。

#### 2. Spring 启动流程（简化版）



Spring 启动核心是「初始化 IOC 容器 + 加载 Bean + 初始化环境」，流程如下：

1. **环境准备**：创建 `ApplicationContext` 实例，加载系统环境变量、配置文件（如 `application.yml`）；

2. BeanDefinition 扫描与注册

   ：

    - 扫描指定包（如 `@ComponentScan` 标注的包），解析 `@Component`、`@Service`、`@Controller` 等注解；
    - 将解析结果封装为 BeanDefinition，注册到 BeanDefinitionRegistry；

3. Bean 实例化与依赖注入

   ：

    - 遍历 BeanDefinitionRegistry 中的 BeanDefinition，按作用域（单例 / 多例）实例化 Bean；
    - 处理依赖注入（`@Autowired` 等），解决循环依赖；

4. Bean 初始化

   ：

    - 执行 `BeanPostProcessor` 前置处理；
    - 执行 `InitializingBean` 的 `afterPropertiesSet` 方法或 `init-method`；
    - 执行 `BeanPostProcessor` 后置处理（如 AOP 动态代理）；

5. **容器就绪**：ApplicationContext 初始化完成，Bean 可通过 `getBean()` 获取或自动注入；

6. **启动后续组件**：若集成 Spring MVC、MyBatis 等，初始化对应的组件（如 DispatchServlet、SqlSessionFactory）。

#### 3. 创建非单例 Bean 的方法



Spring 默认 Bean 作用域是「单例（singleton）」，创建非单例 Bean 需指定作用域：

1. 注解方式（推荐）

   ：用

   ```
   @Scope
   ```



注解指定作用域：

java

运行

   ```
   @Component
   @Scope("prototype") // 多例：每次获取 Bean 时创建新实例
   public class UserService {
       // ...
   }
   ```



- 常用作用域：
    - `prototype`：多例，每次 `getBean()` 或注入时创建新实例；
    - `request`：Web 环境，每个 HTTP 请求创建一个实例；
    - `session`：Web 环境，每个 HTTP Session 创建一个实例；

2. XML 方式

   ：在 XML 配置中指定

   ```
   scope
   ```



属性：

xml

   ```
   <bean id="userService" class="com.example.UserService" scope="prototype"/>
   ```



#### 4. Bean 循环依赖问题（如 A 依赖 B，B 依赖 A）



Spring 仅解决「单例 Bean 的构造器之外的循环依赖」，核心依赖「三级缓存」，流程如下：

- **循环依赖场景**：`A -> B -> A`（A 依赖 B，B 依赖 A）；

- 三级缓存定义

  ：

    - 一级缓存（singletonObjects）：存储完全初始化完成的单例 Bean；
    - 二级缓存（earlySingletonObjects）：存储提前暴露的「未完全初始化」的单例 Bean（已实例化，未注入依赖）；
    - 三级缓存（singletonFactories）：存储 Bean 的工厂方法（`ObjectFactory`），用于延迟创建 Bean 的代理对象；

- 解决流程

  ：

    1. A 实例化（未注入依赖），将 A 的工厂方法存入三级缓存；
    2. A 依赖 B，Spring 尝试获取 B；
    3. B 实例化（未注入依赖），将 B 的工厂方法存入三级缓存；
    4. B 依赖 A，Spring 从一级缓存查 A（无）→ 二级缓存（无）→ 三级缓存（有）；
    5. 执行 A 的工厂方法，获取 A 的早期对象（若 A 需 AOP 代理，此时生成代理对象），存入二级缓存，删除三级缓存；
    6. B 注入 A 的早期对象，B 初始化完成，存入一级缓存；
    7. A 注入 B 的完整对象，A 初始化完成，存入一级缓存，删除二级缓存；

#### 5. 为什么是三级缓存不是二级缓存？



核心原因：**支持 AOP 动态代理，保证循环依赖时 Bean 是代理对象而非原始对象**：

- 若只有二级缓存（singletonObjects + earlySingletonObjects）：

    - A 实例化后，需提前暴露到二级缓存，但此时 A 可能需要 AOP 代理（如 `@Transactional`）；
    - 若直接暴露原始对象到二级缓存，B 注入的是 A 的原始对象，后续 A 初始化时生成代理对象，导致 B 持有原始对象、其他组件持有代理对象，出现不一致；

- 三级缓存的作用：

    - 三级缓存存储的是「工厂方法」，而非直接暴露对象；

    - 当 B 依赖 A 时，执行工厂方法，若 A 需要代理，此时生成代理对象并暴露到二级缓存，保证 B 注入的是代理对象；

    - 若 A 不需要代理，工厂方法直接返回原始对象，不影响逻辑；

      → 三级缓存通过「延迟生成代理对象」解决了 AOP 与循环依赖的兼容性问题，二级缓存无法实现这一点。

### 五、TCP 相关



#### 1. TCP 三次握手（建立连接流程）



TCP 三次握手的核心是「确认双方的发送和接收能力」，流程如下（客户端 C → 服务端 S）：

1. **第一次握手（SYN）**：C 向 S 发送连接请求报文，报文中 `SYN=1`（同步位，表示请求建立连接），`seq=x`（客户端初始序列号）；C 进入 `SYN_SENT` 状态；
2. **第二次握手（SYN+ACK）**：S 收到请求后，回复报文，`SYN=1`（同意建立连接），`ACK=1`（确认位），`ack=x+1`（确认客户端序列号，期望下次收到 x+1），`seq=y`（服务端初始序列号）；S 进入 `SYN_RCVD` 状态；
3. **第三次握手（ACK）**：C 收到回复后，发送确认报文，`ACK=1`，`ack=y+1`（确认服务端序列号），`seq=x+1`；C 进入 `ESTABLISHED` 状态；S 收到后也进入 `ESTABLISHED` 状态，连接建立。

**核心目的**：避免「失效的连接请求报文」被服务端接收，导致服务端误建立连接（如 C 发送的请求报文延迟到达 S，S 建立连接后发送数据，C 已无对应连接，造成资源浪费）。

#### 2. 服务端的 ACK 报文客户端不回应（第二次握手后客户端无响应）



服务端会触发「SYN 超时重传」机制，流程如下：

1. **服务端状态**：服务端发送 SYN+ACK 后，处于 `SYN_RCVD` 状态，等待客户端的第三次握手 ACK；

2. 超时重传

   ：

    - 服务端设置「SYN 超时时间」（默认约 1 秒，可通过 `net.ipv4.tcp_synack_retries` 配置重传次数）；
    - 若超时未收到 ACK，服务端重传 SYN+ACK 报文，每次超时时间翻倍（1s → 2s → 4s → ...）；
    - 重传达到最大次数（默认 5 次）后，服务端放弃重传，释放连接资源，进入 `CLOSED` 状态；

3. 客户端未回应的可能原因

   ：

    - 客户端崩溃或网络故障（如报文丢失）；
    - 客户端端口耗尽，无法建立新连接；

4. 服务端优化

   ：

    - 减少 `tcp_synack_retries` 次数（如设为 3 次），避免资源长时间占用；
    - 开启 SYN Cookie（防御 SYN 洪水攻击，避免半连接队列溢出）。