### 一、为什么需要模板方法模式？

先看痛点场景：

- 你开发一个报表导出系统，支持 Excel、PDF、CSV 三种导出格式，所有导出流程的核心步骤一致：

    1. 校验数据；
    2. 组装数据；
    3. 生成文件；
    4. 保存文件；



- 其中 “校验数据”“保存文件” 是固定逻辑，“组装数据”“生成文件” 因格式不同而变化；

- 若每个导出类都重写完整流程，会重复大量固定代码，且流程结构易不一致（如某类漏写 “校验数据”）。

模板方法模式的解决思路：父类定义导出流程的骨架（模板方法），将固定步骤实现为父类方法，可变步骤定义为抽象方法，子类只需实现可变步骤，无需重复固定逻辑。

### 二、模板方法模式的核心结构

模板方法模式包含 2 个核心角色：

1. 抽象模板（Abstract Class）

   ：

    - 定义算法骨架的**模板方法**（通常是`final`，防止子类修改流程）；
    - 实现算法中的**固定步骤**（具体方法）；
    - 声明算法中的**可变步骤**（抽象方法，由子类实现）；
    - 可选：定义 “钩子方法”（Hook Method），子类可选择是否覆盖，用于扩展流程。



2. **具体模板（Concrete Class）**：实现抽象模板中的抽象方法，完成算法的可变步骤。

### 三、完整代码实现（报表导出场景）

#### 1. 抽象模板（Abstract Class）





```
// 报表导出抽象模板：定义导出流程的骨架
public abstract class ReportExporter {
    /**
     * 模板方法：导出报表的核心流程（final防止子类修改流程）
     * @param data 报表数据
     * @param filePath 保存路径
     * @return 导出结果
     */
    public final String export(Object[][] data, String filePath) {
        try {
            // 步骤1：校验数据（固定步骤）
            validateData(data);
            
            // 步骤2：组装数据（可变步骤，子类实现）
            Object assembledData = assembleData(data);
            
            // 步骤3：生成文件（可变步骤，子类实现）
            boolean generateResult = generateFile(assembledData, filePath);
            
            // 步骤4：保存文件（固定步骤）
            saveFile(filePath);
            
            // 钩子方法：导出后回调（子类可选覆盖）
            afterExport(filePath);
            
            return "导出成功，文件路径：" + filePath;
        } catch (Exception e) {
            return "导出失败：" + e.getMessage();
        }
    }

    // 固定步骤1：校验数据
    private void validateData(Object[][] data) {
        if (data == null || data.length == 0) {
            throw new IllegalArgumentException("报表数据不能为空");
        }
        System.out.println("校验报表数据：数据格式合法");
    }

    // 固定步骤4：保存文件（模拟）
    private void saveFile(String filePath) {
        System.out.println("保存文件到：" + filePath);
    }

    // 可变步骤2：组装数据（抽象方法，子类实现）
    protected abstract Object assembleData(Object[][] data);

    // 可变步骤3：生成文件（抽象方法，子类实现）
    protected abstract boolean generateFile(Object assembledData, String filePath);

    // 钩子方法：导出后回调（默认空实现，子类可选覆盖）
    protected void afterExport(String filePath) {}
}
```

#### 2. 具体模板（Concrete Class）




```
// 具体模板1：Excel导出
public class ExcelExporter extends ReportExporter {
    @Override
    protected Object assembleData(Object[][] data) {
        System.out.println("组装Excel格式数据：转换为单元格格式");
        // 模拟组装后的数据
        return "ExcelData-" + data.length;
    }

    @Override
    protected boolean generateFile(Object assembledData, String filePath) {
        System.out.println("生成Excel文件：" + filePath + "（数据：" + assembledData + "）");
        return true;
    }

    // 覆盖钩子方法：Excel导出后发送邮件
    @Override
    protected void afterExport(String filePath) {
        System.out.println("Excel文件导出完成，发送通知邮件至：admin@xxx.com");
    }
}

// 具体模板2：PDF导出
public class PdfExporter extends ReportExporter {
    @Override
    protected Object assembleData(Object[][] data) {
        System.out.println("组装PDF格式数据：转换为PDF段落格式");
        return "PDFData-" + data.length;
    }

    @Override
    protected boolean generateFile(Object assembledData, String filePath) {
        System.out.println("生成PDF文件：" + filePath + "（数据：" + assembledData + "）");
        return true;
    }

    // 不覆盖钩子方法：使用默认空实现
}

// 具体模板3：CSV导出
public class CsvExporter extends ReportExporter {
    @Override
    protected Object assembleData(Object[][] data) {
        System.out.println("组装CSV格式数据：转换为逗号分隔格式");
        return "CSVData-" + data.length;
    }

    @Override
    protected boolean generateFile(Object assembledData, String filePath) {
        System.out.println("生成CSV文件：" + filePath + "（数据：" + assembledData + "）");
        return true;
    }
}
```

#### 3. 客户端使用示例









```
public class TemplateMethodDemo {
    public static void main(String[] args) {
        // 模拟报表数据
        Object[][] reportData = {{"日期", "销售额"}, {"2026-02-23", 10000}, {"2026-02-24", 12000}};

        // 1. 导出Excel
        ReportExporter excelExporter = new ExcelExporter();
        System.out.println("===== 导出Excel报表 =====");
        String excelResult = excelExporter.export(reportData, "/reports/sales.xlsx");
        System.out.println(excelResult);

        // 2. 导出PDF
        ReportExporter pdfExporter = new PdfExporter();
        System.out.println("\n===== 导出PDF报表 =====");
        String pdfResult = pdfExporter.export(reportData, "/reports/sales.pdf");
        System.out.println(pdfResult);

        // 3. 导出CSV
        ReportExporter csvExporter = new CsvExporter();
        System.out.println("\n===== 导出CSV报表 =====");
        String csvResult = csvExporter.export(reportData, "/reports/sales.csv");
        System.out.println(csvResult);
    }
}
```

**输出结果**：









```
===== 导出Excel报表 =====
校验报表数据：数据格式合法
组装Excel格式数据：转换为单元格格式
生成Excel文件：/reports/sales.xlsx（数据：ExcelData-3）
保存文件到：/reports/sales.xlsx
Excel文件导出完成，发送通知邮件至：admin@xxx.com
导出成功，文件路径：/reports/sales.xlsx

===== 导出PDF报表 =====
校验报表数据：数据格式合法
组装PDF格式数据：转换为PDF段落格式
生成PDF文件：/reports/sales.pdf（数据：PDFData-3）
保存文件到：/reports/sales.pdf
导出成功，文件路径：/reports/sales.pdf

===== 导出CSV报表 =====
校验报表数据：数据格式合法
组装CSV格式数据：转换为逗号分隔格式
生成CSV文件：/reports/sales.csv（数据：CSVData-3）
保存文件到：/reports/sales.csv
导出成功，文件路径：/reports/sales.csv
```

### 四、模板方法模式的核心特性：钩子方法（Hook）

钩子方法是模板方法模式的灵活扩展点，分为两种：

1. **空实现钩子**：父类提供空方法，子类可选覆盖（如示例中的`afterExport`）；
2. **条件钩子**：父类提供返回布尔值的方法，子类覆盖后可改变模板方法的流程（如下例）。










```
// 扩展抽象模板：添加条件钩子
public abstract class EnhancedReportExporter extends ReportExporter {
    // 条件钩子：是否压缩文件（默认不压缩）
    protected boolean needCompress() {
        return false;
    }

    // 重写模板方法：增加压缩步骤
    @Override
    public final String export(Object[][] data, String filePath) {
        String result = super.export(data, filePath);
        // 根据钩子方法决定是否压缩
        if (needCompress()) {
            compressFile(filePath);
            System.out.println("文件已压缩：" + filePath + ".zip");
        }
        return result;
    }

    // 新增固定步骤：压缩文件
    private void compressFile(String filePath) {
        System.out.println("压缩文件：" + filePath);
    }
}

// 具体模板：带压缩的Excel导出
public class CompressedExcelExporter extends EnhancedReportExporter {
    @Override
    protected Object assembleData(Object[][] data) {
        return super.assembleData(data); // 复用父类逻辑
    }

    @Override
    protected boolean generateFile(Object assembledData, String filePath) {
        return super.generateFile(assembledData, filePath);
    }

    // 覆盖条件钩子：需要压缩
    @Override
    protected boolean needCompress() {
        return true;
    }
}
```

### 五、模板方法模式 vs 策略模式（核心区别）

两者都能封装可变逻辑，但核心目标和结构完全不同：






|   维度   |              模板方法模式              |              策略模式              |
| :------: | :------------------------------------: | :--------------------------------: |
| 核心目标 |   固定算法**骨架**，定制可变**步骤**   |   封装可替换的**算法**，灵活切换   |
| 实现方式 |      继承（子类实现父类抽象方法）      |     组合（环境类持有策略对象）     |
| 算法结构 |       算法结构固定，步骤细节可变       |     整个算法可替换，结构可不同     |
| 扩展方式 |           新增子类实现新步骤           |        新增策略类实现新算法        |
|  耦合度  |         高（子类依赖父类流程）         |      低（策略与环境类松耦合）      |
| 适用场景 | 流程固定、步骤可变（如导出、流程审批） | 算法可选、灵活切换（如支付、排序） |

### 六、模板方法模式的核心特点

#### 优点：

1. **代码复用**：固定流程的代码集中在父类，子类无需重复实现，减少冗余；
2. **流程统一**：模板方法为`final`，保证所有子类遵循相同的算法结构，避免流程混乱；
3. **扩展灵活**：可变步骤延迟到子类实现，新增场景只需新增子类（符合 “开闭原则”）；
4. **钩子方法**：提供灵活的扩展点，子类可按需定制流程细节。

#### 缺点：

1. **继承耦合**：子类与父类强耦合，父类修改流程会影响所有子类；
2. **类数量增加**：每种可变流程对应一个子类，场景过多时会导致类爆炸；
3. **流程修改受限**：模板方法固定后，修改整体流程需修改父类（违反开闭原则）。

### 总结

1. **核心思想**：模板方法模式将算法的 “骨架” 固定在父类，“细节” 延迟到子类，核心是 “流程复用、细节定制”；

2. 适用场景 ：

    - 多个场景有相同的流程骨架，仅步骤细节不同（如导出、导入、流程审批）；
    - 希望保证算法结构的一致性，同时允许子类定制可变步骤；
    - 需要控制子类的行为，只开放特定扩展点（通过钩子方法）；



3. 实现关键 ：
    - 模板方法用`final`修饰，防止子类修改流程；
    - 固定步骤实现为父类私有方法，可变步骤声明为抽象方法；
    - 钩子方法提供默认实现，子类可选覆盖，增强灵活性；



4. 优化建议 ：

    - 流程过于复杂时，可拆分多个模板类（如基础模板 + 扩展模板）；
    - 减少父类与子类的耦合，父类仅暴露必要的方法给子类；
    - 结合工厂模式创建具体模板对象，简化客户端调用。

   