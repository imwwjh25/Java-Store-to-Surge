### 6. Kafka 怎么实现精准一次（Exactly-Once）



“精准一次” 是流处理系统中的一个重要概念，意味着消息被**恰好处理一次**，既不重复也不丢失。Kafka 在 0.11.0.0 版本中正式引入了对 Exactly-Once 语义的支持。

**实现精准一次的核心挑战**：如何在消息的**生产**和**消费**两个环节都保证 “不多不少”。

**Kafka 的解决方案**：

Kafka 的 Exactly-Once 语义是基于以下几个核心机制协同工作实现的：

1. **幂等性生产者（Idempotent Producer）**

   - **问题**：生产者重试可能导致消息重复发送。

   - **解决**：生产者在初始化时可以开启幂等性（`enable.idempotence = true`）。开启后，Kafka 会为每个生产者分配一个唯一的`Producer ID (PID)`，并且为每个消息批次分配一个**序列号（Sequence Number）**。

   - 原理

     ：Broker 端会记录每个 PID 在每个分区上已经提交的最大序列号。当生产者发送一个消息时，Broker 会检查：

     - 如果序列号比 Broker 记录的大 1，则正常接收。
     - 如果序列号小于或等于 Broker 记录的，则说明是重复消息，Broker 会直接丢弃它，而不会写入日志。

   - **局限**：只能保证单个生产者会话内、单个分区的消息幂等。无法解决跨会话、跨分区的重复问题。

2. **事务（Transactions）**

   - **问题**：需要将多个消息的生产或消费作为一个原子操作，要么全部成功，要么全部失败。例如，在流处理中，“从主题 A 消费消息 -> 处理 -> 生产到主题 B” 这一整个流程需要是原子的。

   - **解决**：Kafka 引入了事务协调器（Transaction Coordinator）和事务日志（Transaction Log）。

   - 原理

     ：

     - **生产者**：可以将一系列生产请求（可能发往多个主题和分区）和消费偏移量提交请求包装在一个事务中。
     - **事务协调器**：负责管理事务的生命周期（开始、提交、中止）。它使用一个内部主题（`__transaction_state`）来记录事务的状态。
     - **两阶段提交（2PC）**：事务提交过程采用两阶段提交。首先，生产者向协调器发送 “准备提交” 请求，协调器记录事务状态为`PREPARED`。然后，协调器指示所有涉及的 Broker 将事务内的消息标记为`COMMITTED`（或`ABORTED`）。
     - **消费者**：消费者在读取消息时，只会读取那些已经成功提交（`COMMITTED`）的事务消息。对于未完成的事务消息，消费者会忽略它们，直到事务最终提交或中止。

3. **消费者端的偏移量管理**

   - 为了实现端到端的 Exactly-Once，消费者必须将**消费偏移量的提交**也纳入事务中。
   - 当使用`KafkaConsumer`的`commitSync()`或`commitAsync()`时，如果配合事务，偏移量的提交会和消息的生产在同一个事务中完成。只有当整个事务成功提交后，偏移量才会被真正更新。如果事务中止，偏移量的提交也会被撤销，从而保证了消费和生产的原子性。

**总结**：Kafka 的 Exactly-Once 语义是通过**幂等性生产者**解决单会话、单分区的重复问题，再通过**事务**机制将多个生产和消费偏移量提交操作原子化，从而实现了跨分区、跨会话的端到端精准一次处理。

**面试回答总结**：“Kafka 实现精准一次（Exactly-Once）语义主要依赖于两个核心机制：幂等性生产者和事务。首先，开启幂等性的生产者会被分配一个唯一的 PID，并且每条消息都会带有序列号。Kafka Broker 会记录每个 PID 在每个分区上的最大序列号，从而自动过滤掉重复的消息，这解决了生产者重试导致的重复问题。其次，Kafka 通过事务协调器和事务日志，支持将一系列生产和消费偏移量提交操作包装在一个原子事务中。只有当事务内的所有操作都成功时，事务才会提交；任何一个环节失败，整个事务都会中止并回滚。这确保了消息的生产和消费偏移量的更新是原子的，从而实现了端到端的 Exactly-Once。”
