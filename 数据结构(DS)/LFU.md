### 12. LFU（Least Frequently Used）的特点 / 核心思路

LFU 是一种**基于访问频率**的缓存淘汰算法，核心思想是：**“如果一个 key 被访问的频率越低，那么它在未来被访问的概率也越低，当缓存满时，优先淘汰访问频率最低的 key”**。

#### 核心特点：

1. **以 “访问频率” 为核心依据**：淘汰决策完全依赖 key 的访问次数（频率），而非访问时间（如 LRU 的 “最近”）；
2. **频率公平性**：长期高频访问的 key 会被持续保留，适合 “热点数据长期稳定” 的场景（如电商高频商品、系统配置）；
3. **冷启动问题**：新加入的 key 访问频率低，容易被淘汰（即 “缓存穿透” 的潜在诱因）；
4. **频率衰减机制（部分实现）**：为避免 “老高频 key 长期占用缓存”，部分 LFU 变体支持频率随时间衰减（如定时降低所有 key 的访问次数）；
5. **实现复杂度中等**：需维护 key 的访问频率，以及频率到 key 的映射，典型实现依赖「哈希表 + 双向链表」。

#### 核心思路（经典实现流程）：

1. 数据结构设计 ：

    - 哈希表 `keyToNode`：存储 key 到缓存节点的映射（O (1) 查找 key 对应的节点）；
    - 哈希表 `freqToNodes`：存储频率到 “该频率下的 key 链表” 的映射（O (1) 找到频率最低的链表）；
    - 缓存节点 `Node`：包含 key、value、访问频率 `freq`，以及链表指针（前驱 / 后继）；
    - 最小频率 `minFreq`：记录当前缓存中最低的访问频率（O (1) 定位待淘汰的链表）。

2. 核心操作逻辑 ：

    - 访问 key（get） ：

        1. 若 key 不存在，返回 null；
        2. 若 key 存在，将对应节点的 `freq` +1；
        3. 从原 `freq` 对应的链表中移除该节点，加入 `freq+1` 对应的链表；
        4. 若原 `freq` 是 `minFreq` 且对应链表为空，更新 `minFreq` 为 `freq+1`。

    - 插入 key（put） ：

        1. 若 key 已存在，更新 value 并执行 “访问 key” 的逻辑（freq +1）；
        2. 若 key 不存在：
            - 若缓存已满，删除 `minFreq` 对应链表的尾部节点（最久未访问的低频 key），并从 `keyToNode` 中移除；
            - 创建新节点（freq=1），加入 `freq=1` 对应的链表，同时更新 `keyToNode`；
            - 重置 `minFreq=1`（新节点频率最低）。

### 13. LFU 优化：解决 “老高频 key 占坑，新 key 频繁被淘汰” 的问题

你描述的场景是 LFU 的经典缺陷 ——**“频率粘性”**：长期高频访问的 key 即使后续不再访问，其高频率依然会让它长期占用缓存，而新加入的低频率 key （可能是未来的热点）会被频繁淘汰。

核心优化思路是：**在 “访问频率” 的基础上，引入 “时间衰减” 或 “访问时效性” 权重**，让 “老高频但长期未访问的 key” 频率降低，给新 key 留存机会。以下是 3 种实用优化方案（从简单到复杂）：

#### 方案 1：频率衰减（TTL 衰减 / 定时衰减）

给每个 key 的访问频率增加 “时效性”，让长期未访问的高频 key 频率逐步降低，避免 “频率固化”。

##### 实现逻辑：

1. 为每个缓存节点 `Node` 增加 `lastAccessTime`（最后访问时间戳）；
2. 新增 “衰减机制”：
    - **定时衰减**：启动一个后台线程（如每小时），遍历所有 key，若 key 的 `lastAccessTime` 距当前时间超过阈值（如 24 小时），则将其 `freq` 减半（或减 1，避免频率骤降）；
    - **访问时衰减**：当 key 被访问时，先检查 `lastAccessTime` 与当前时间的间隔，若超过阈值，按时间间隔比例降低 `freq`（如间隔 12 小时，freq 减 1；间隔 24 小时，freq 减半），再执行 `freq+1` 操作；
3. 衰减后若 `freq <=0`，直接淘汰该 key；若原 `minFreq` 对应的链表为空，更新 `minFreq`。

##### 优势：

- 实现简单，无需修改核心 LFU 结构，仅新增时间字段和衰减逻辑；
- 有效解决 “老高频 key 占坑” 问题，让长期未访问的 key 频率自然下降。

##### 注意：

- 定时衰减需控制频率（如每小时一次），避免遍历缓存带来的性能开销；
- 衰减幅度需合理（如减半而非清零），避免误淘汰 “偶尔访问的老热点 key”。

#### 方案 2：LFU + LRU 混合策略（FIFO 级联 / 频率相同按时间淘汰）

核心是：**“频率优先，同频率下按时间淘汰（LRU）”**，同时给新 key 额外的 “保护期”，避免刚加入就被淘汰。

##### 实现逻辑：

1. 保留 LFU 的核心结构（`keyToNode`、`freqToNodes`、`minFreq`）；
2. 每个 `freq` 对应的链表改为「双向有序链表」，按 `lastAccessTime` 排序（最新访问的节点在链表头部，最久未访问的在尾部）；
3. 新增 “新 key 保护机制”：
    - 新 key 加入时，除了 `freq=1`，还标记 `isNew=true`，并设置保护期（如 5 分钟）；
    - 保护期内，即使缓存满，新 key 不会被淘汰（除非缓存溢出严重，需淘汰时优先淘汰非保护期的低频 key）；
    - 保护期结束后，`isNew=false`，按正常 LFU 规则参与淘汰；
4. 淘汰逻辑优化：
    - 缓存满时，先找 `minFreq` 对应的链表；
    - 若链表中有多个节点，淘汰链表尾部（同频率下最久未访问）的节点；
    - 若 `minFreq` 链表中全是新 key（保护期内），则暂时扩容缓存（或淘汰保护期最早结束的新 key）。

##### 优势：

- 解决 “同频率下淘汰顺序模糊” 的问题，兼顾频率和时间；
- 新 key 保护期避免 “冷启动淘汰”，给新 key 积累访问频率的机会；
- 兼容 LFU 核心优势，同时提升对新热点的适应性。

##### 典型应用：

- Redis 6.0+ 中的 LFU 实现（默认开启 “同频率按 LRU 淘汰”，通过 `lfu-decay-time` 配置频率衰减）。

#### 方案 3：分段频率 + 新 key 初始频率优化

核心是：**“打破频率的绝对优先级”**，将频率分段（如低、中、高），新 key 赋予中等初始频率，避免因初始频率 1 直接被淘汰。

##### 实现逻辑：

1. 频率分段：将访问频率划分为 3 段（低：freq ≤3；中：4≤freq≤10；高：freq≥11）；
2. 新 key 初始频率：新 key 加入时，初始频率设为 “中”（如 freq=4），而非 1，给予 “初始权重”；
3. 频率升级 / 降级规则：
    - 低段频率：访问一次 freq+1，连续 3 次未访问 freq-1；
    - 中段频率：访问一次 freq+1，连续 12 小时未访问 freq-2；
    - 高段频率：访问一次 freq+1，连续 24 小时未访问 freq-3（避免高频 key 过快降级）；
4. 淘汰优先级：
    - 优先淘汰低段频率的 key（同段内按 LRU 淘汰）；
    - 低段为空时，淘汰中段中频率最低、最久未访问的 key；
    - 高段 key 除非长期未访问降至低段，否则不淘汰。

##### 优势：

- 新 key 初始中段频率，避免直接被低频淘汰，有更多机会被访问；
- 分段频率降低 “老高频 key 占坑” 的影响（高段频率需长期未访问才会降级）；
- 灵活调整各段的升级 / 降级规则，适配不同业务场景（如电商、社交）。

##### 适用场景：

- 新 key 成为热点的概率较高的场景（如促销活动、新品上线）；
- 缓存中既有长期稳定热点，又有周期性新热点的业务（如新闻、短视频）。

### 优化方案对比与选型建议

| 优化方案                          | 核心优势                    | 实现复杂度 | 适用场景                                     |
| --------------------------------- | --------------------------- | ---------- | -------------------------------------------- |
| 频率衰减（方案 1）                | 简单易实现，无侵入性        | 低         | 现有 LFU 系统快速优化，老热点占坑问题突出    |
| LFU + LRU 混合（方案 2）          | 兼顾频率与时间，新 key 保护 | 中         | 大多数业务场景（推荐首选），需平衡新老热点   |
| 分段频率 + 初始频率优化（方案 3） | 新 key 友好，灵活适配业务   | 高         | 新热点频繁出现的场景（如电商促销、内容平台） |

### 生产环境落地建议（以 Redis 为例）

Redis 已内置优化后的 LFU 实现，直接配置即可解决问题：

1. 启用 LFU 缓存策略：






   ```bash
   # redis.conf 配置
   maxmemory-policy allkeys-lfu # 所有 key 按 LFU 淘汰
   ```



2. 配置频率衰减（解决老高频 key 占坑）：





   ```bash
   lfu-decay-time 1 # 单位：分钟，1 分钟内未访问的 key，频率衰减 1
   ```



3. 配置新 key 初始频率（避免冷启动淘汰）：






   ```bash
   lfu-log-factor 10 # 初始频率因子，值越大，新 key 初始频率越高（默认 10，对应初始 freq≈4）
   ```



### 总结

LFU 的核心缺陷是 “频率粘性” 和 “冷启动淘汰”，优化的关键是**在 “访问频率” 的基础上，引入 “时间维度” 和 “新 key 权重”**：

1. 简单场景：用 “频率衰减” 快速解决老高频 key 占坑；
2. 通用场景：用 “LFU + LRU 混合” 兼顾频率和时间，适配大多数业务；
3. 特殊场景：用 “分段频率 + 初始频率优化” 适配新热点频繁的场景；
4. 优先使用成熟实现（如 Redis LFU），避免重复造轮子，通过配置调整即可满足需求。