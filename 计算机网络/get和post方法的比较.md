GET 和 POST 是 HTTP 协议中最常用的两种请求方法，它们在语义、数据传输方式、缓存行为、安全性等方面都存在显著差异。

### 核心区别对比

| 特性                     | GET                                                          | POST                                                         |
| ------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **语义和用途**           | 从服务器**获取**资源。是一种**安全的、幂等的**方法。         | 向服务器**提交**数据，创建或更新资源。不是安全的，也不是幂等的。 |
| **数据传输方式**         | 通过 URL 的查询字符串（Query String）传递。数据会暴露在 URL 中。 | 通过请求体（Request Body）传递。数据不会显示在 URL 中。      |
| **缓存**                 | GET 请求的响应是可以被浏览器或代理服务器缓存的。             | POST 请求的响应默认是不可缓存的。                            |
| **书签和历史记录**       | 由于参数在 URL 中，GET 请求可以方便地被收藏为书签或保存在历史记录中。 | POST 请求的参数在请求体中，无法直接收藏为书签。              |
| **数据大小限制**         | 由于 URL 的长度有限制（不同浏览器和服务器有不同限制，通常在 2KB - 8KB 之间），GET 请求发送的数据量有限。 | 理论上没有大小限制。实际限制取决于服务器的配置（如 `post_max_size`）和网络环境。 |
| **安全性**               | **不安全**。参数直接暴露在 URL 中，容易被拦截和篡改。        | **相对更安全**。参数位于请求体中，不会显示在 URL 或浏览器历史记录里，但在网络传输过程中，仍然可以被抓包工具截获。**注意：POST 本身不加密数据，要实现真正的安全，需要配合 HTTPS。** |
| **幂等性 (Idempotency)** | **是幂等的**。幂等性是指一次和多次请求某一个资源应该具有相同的副作用。例如，`GET /users/1` 无论执行多少次，都只会获取用户 1 的信息，不会改变服务器上的任何数据。 | **通常不是幂等的**。例如，你向一篇文章提交评论，每点击一次 “提交”（发送一次 POST 请求），服务器就会新增一条评论。执行多次，副作用就会发生多次。 |
| **可见性**               | 参数在地址栏可见，对所有人（包括历史记录、书签、网络代理）可见。 | 参数在地址栏不可见，相对隐蔽，但并非绝对安全。               |

------

### 详细解析

#### 1. 语义和用途 (Semantics & Purpose)

- **GET**: 语义是 “获取” 或 “查询”。它用于从服务器请求指定的资源。GET 请求应该只用于读取数据，而不应该对服务器上的数据产生任何副作用（即 “安全的”）。
- **POST**: 语义是 “创建” 或 “更新”。它用于向服务器提交数据，导致服务器状态的改变或创建新的资源。例如，用户注册、提交表单、发表评论等。

#### 2. 数据传输方式 (Data Location)

- **GET**: 请求参数附加在 URL 的末尾，以 `?` 开始，键值对之间用 `&` 分隔。例如：`https://example.com/search?keyword=apple&page=1`。
- **POST**: 请求参数放在请求体（Request Body）中进行传输。URL 本身不会暴露这些数据。

#### 3. 缓存 (Caching)

- **GET**: GET 请求的响应是可以被浏览器或代理服务器缓存的。这可以提高后续访问的速度，减轻服务器压力。
- **POST**: POST 请求的响应默认是不被缓存的。每次提交 POST 请求，浏览器都会直接向服务器发送全新的请求。

#### 4. 幂等性 (Idempotency)

- **幂等性**是指一次和多次执行同一操作，其结果是相同的，不会对系统状态造成额外的改变。
- **GET**: 是幂等的。你请求 `GET /users/1` 一次或一百次，服务器上用户 1 的数据都不会改变，你得到的也都是相同（或在那个时间点相同）的数据。
- **POST**: **通常不是幂等的**。例如，你用 POST 提交一个订单，每提交一次，服务器就会创建一个新的订单。如果你连续点击提交按钮两次，就会创建两个订单。

#### 5. 安全性 (Security)

这是一个常见的误区。请注意，这里的 “安全” 不是指加密，而是指**是否会对服务器数据造成修改**。

- **GET**: 因为它是 “安全的”（不修改数据），所以相对来说风险较小，但参数暴露在 URL 中，这是一个安全隐患。
- **POST**: 因为它会修改服务器数据，所以如果被恶意利用，风险更大。但它的参数不在 URL 中，相对 GET 来说更隐蔽一些。
- **重要提示**: **无论是 GET 还是 POST，它们本身都不提供数据加密。** 在网络上传输的所有数据（包括 URL 和请求体）都是明文的，可以被网络抓包工具（如 Wireshark）截获。要实现真正的安全通信，必须使用 **HTTPS** 协议，它会对整个 HTTP 请求（包括头部和 body）进行加密。

------

### 什么时候用 GET，什么时候用 POST？

#### 使用 GET 的场景：

- 获取数据，如查询文章列表、商品信息。
- 搜索、排序、筛选等操作。
- 请求的结果是 “只读” 的，不会改变服务器上的任何数据。

#### 使用 POST 的场景：

- 提交表单，特别是包含敏感信息（如密码）的表单。
- 创建一个新的资源（如创建新用户、发布新文章）。
- 执行任何会改变服务器数据的操作，且该操作不幂等。
- 上传文件。

### 总结

GET 用于**查询**，POST 用于**提交**。GET 把数据放在**URL**，POST 把数据放在**请求体**。GET 是**幂等**的，POST **通常不是**。GET 可**缓存**，POST 不可缓存。GET 相对**不安全**（参数暴露），POST 相对**安全**（参数隐藏），但真正的安全需要 HTTPS。

你提到get的不安全，具体哪里表现不安全？（我说是加密方面，但不太对，面试官就花了一些时间和我说是get请求的缓存，产生的一些不安全的问题）

你提到的加密方面是一个常见的安全考量，但面试官想引导你思考的是 **GET 请求本身的特性** 与 **Web 缓存机制** 结合时产生的 **具体安全风险**。

下面我们来详细拆解 GET 请求是如何因为缓存而变得不安全的。

------

### GET 请求的缓存机制

首先，我们需要明确 GET 请求的缓存行为：

- **默认可缓存**：GET 请求的响应默认是可以被浏览器或代理服务器缓存的。
- **缓存键（Cache Key）**：缓存系统通常使用 **完整的 URL** 作为缓存的键。这意味着，只要 URL 相同，后续的请求就会直接返回缓存中的响应，而不会再去请求源服务器。

例如，当你访问 `https://example.com/api/user?userId=123` 时，浏览器第一次会向服务器发送请求，获取用户 123 的数据。服务器返回数据的同时，可能会在响应头中包含 `Cache-Control` 或 `Expires` 等字段，指示浏览器可以缓存这个响应多长时间。

在缓存有效期内，如果你再次访问同一个 URL，浏览器会直接从本地缓存中读取数据并显示，而不会再与服务器通信。

------

### 缓存带来的安全风险

正是这种基于 URL 的缓存机制，在某些情况下会引入安全漏洞。主要风险点如下：

#### 1. 敏感信息泄露

这是最直接、最常见的风险。

- 场景 ：如果一个 GET 请求的 URL 中包含了敏感信息（如用户 ID、会话令牌、认证令牌、个人隐私数据等），那么这个 URL 以及对应的响应数据就可能被缓存到以下地方：

    - **浏览器历史记录**：URL 会被明文保存在浏览器的历史记录中。
    - **浏览器缓存**：响应内容（可能包含更多敏感数据）会被保存在用户本地的缓存文件中。
    - **代理服务器缓存**：如果用户处于一个使用代理服务器的网络环境（如公司、学校），代理服务器也可能缓存这个请求和响应。
    - **网络设备日志**：URL 可能会被沿途的路由器、防火墙等网络设备记录下来。

- 风险：

    - **本地泄露**：如果用户在公共电脑上操作，后续使用该电脑的人可以通过查看浏览器历史或缓存，获取到前一个用户的敏感信息。
    - **中间人泄露**：网络管理员或黑客如果控制了代理服务器或网络设备，就可以通过分析日志或缓存，大规模收集用户的敏感信息。

**举例**：

一个银行网站错误地使用 GET 请求来执行转账操作，并将转账金额和目标账户放在 URL 中：`https://bank.com/transfer?from=myAccount&to=yourAccount&amount=1000`

这个 URL 会被保存在浏览器历史和缓存中。任何能访问这台电脑的人都可以看到这笔转账的详细信息。更严重的是，如果这个请求被代理服务器缓存，那么其他用户访问这个 URL 时，可能会看到别人的转账确认页面或账户余额信息（虽然现实中银行不会这么做，但这是一个典型的错误示范）。

#### 2. 缓存投毒（Cache Poisoning）

这是一种更高级的攻击技术。

- **场景**：攻击者精心构造一个恶意的 GET 请求，其 URL 是目标网站上一个可被缓存的资源（例如一个 JavaScript 文件、一个 CSS 样式表或一个 API 接口）。攻击者想办法让这个恶意请求的响应被代理服务器或 CDN 缓存。

- 攻击过程 ：

    1. 攻击者找到一个存在漏洞的 URL，比如 `https://example.com/static/main.js?version=1.0`。
    2. 他向这个 URL 发送一个恶意请求，并在请求中携带一些特殊的 header 或参数，诱导服务器返回一个包含恶意代码（如 XSS 脚本）的响应。
    3. 如果代理服务器或 CDN 缓存了这个恶意的响应，那么在缓存有效期内，所有访问 `https://example.com/static/main.js?version=1.0` 的用户，都会从缓存中加载这个带有恶意代码的文件，从而受到攻击。

- **风险**：攻击范围广，一旦缓存被 “投毒”，所有访问该资源的用户都会受害，直到缓存过期。

#### 3. 数据不一致与 stale 数据

- **场景**：GET 请求用于获取一些**实时性要求很高**的数据，比如股票价格、实时通知、用户当前在线状态等。
- **风险**：如果这些数据被缓存，用户后续访问时得到的可能是 ** 过时的（stale）** 数据，这可能导致用户做出错误的决策，或者错过重要的信息。虽然这严格来说不是一个 “安全” 漏洞，但它会破坏数据的完整性和系统的可用性，在某些场景下（如金融交易）可能间接引发安全问题。

------

### 总结与防护措施

面试官想考察的，是你对 HTTP 协议细节和 Web 安全实践的深入理解。GET 请求的不安全，不仅仅是因为参数暴露在 URL 中容易被窃听（这一点可以通过 HTTPS 部分缓解），更因为其**可缓存的特性**会导致敏感信息的**持久化泄露**和**扩大化攻击面**。

**如何防护？**

1. **避免在 URL 中传递敏感信息**：这是最根本的原则。认证令牌（如 JWT）、会话 ID、密码、个人身份证号等敏感数据，绝对不要通过 GET 请求的 URL 传递。应该使用 POST 请求，并将这些数据放在请求体（Request Body）中。

2. **使用 HTTPS**：HTTPS 可以对整个通信过程（包括 URL、请求头、请求体）进行加密。这可以有效防止网络窃听和中间人攻击，即使使用 GET 请求，攻击者也无法轻易获取 URL 中的参数。

3. **控制缓存行为**：

    - 对于包含敏感信息或实时性要求高的 GET 请求，在服务器端的响应头中明确设置禁止缓存：

     










```http
     Cache-Control: no-store, no-cache, must-revalidate, max-age=0
     Pragma: no-cache
```



- `no-store` 是最严格的指令，它禁止浏览器和任何代理服务器存储本次响应的任何内容。

4. **使用 POST 代替 GET 执行状态更改操作**：根据 HTTP 规范，GET 应该只用于 “查询” 操作，而 POST 应该用于 “提交” 或 “修改” 操作。遵循这个规范可以从语义上减少安全风险。

5. **实现幂等性**：虽然这主要是针对 POST 请求的，但如果你必须使用 GET 来执行某些轻微的状态更改（不推荐），务必确保这个操作是幂等的，即多次执行不会产生副作用。

所以，当面试官问你 GET 请求的不安全表现时，除了说参数在 URL 中可见，更要能深入解释**这种可见性如何与缓存机制结合，导致敏感信息被持久化存储和未授权访问**，这样才能体现你的专业深度。

那post又为什么是相对安全的呢

面试官其实是在考察你是否能准确理解 **“相对安全”** 这个词的含义，以及 GET 和 POST 在安全特性上的核心差异。

POST 的 “相对安全” 并不是指它本身提供了加密或更强的安全保障，而是相对于 GET 而言，它**在默认情况下能避免某些特定的安全风险**。

具体分析如下：

------

### POST 相对安全的主要原因

#### 1. **请求参数不暴露在 URL 中**

- GET 的问题

  ：参数直接附加在 URL 末尾，会暴露在：

    - 浏览器地址栏
    - 浏览器历史记录
    - 书签
    - 网络代理日志
    - 服务器访问日志

- **POST 的优势**：参数放在请求体（Request Body）中传输，URL 本身不会泄露这些信息。

- 场景举例：

    - 用 GET 提交登录表单：`https://example.com/login?username=admin&password=123456`，密码会直接显示在地址栏，且被浏览器记录。
    - 用 POST 提交登录表单：参数在请求体中，地址栏保持干净，历史记录和日志中不会直接暴露敏感数据。

#### 2. **不会被缓存**

- **GET 的问题**：GET 请求默认会被浏览器或代理服务器缓存，缓存的内容可能包含敏感数据。
- **POST 的优势**：POST 请求默认不会被缓存，每次提交都会发送全新的请求，避免了缓存导致的数据泄露风险。

#### 3. **幂等性**

- **GET 的问题**：GET 是幂等的（多次请求结果一致），但这也意味着攻击者可以重复发送恶意 GET 请求（如查询敏感数据）而不会被轻易察觉。
- **POST 的优势**：POST 通常不是幂等的（多次请求会产生副作用，如创建多个资源），这使得攻击者难以通过重复请求来获取或修改数据。

#### 4. **参数长度无限制**

- **GET 的问题**：URL 长度有限制（通常 2KB-8KB），导致无法传输大量数据，可能需要将敏感数据拆分或暴露在 URL 中。
- **POST 的优势**：请求体可以传输大量数据，支持复杂的表单提交（如文件上传、多字段表单），避免了因数据量限制而导致的安全妥协。

------

### 为什么说 “相对安全” 而不是 “绝对安全”？

POST 并不是绝对安全的，它仍然存在以下风险：

1. **没有加密**：POST 请求的参数虽然在 URL 中不可见，但在网络传输过程中，请求体的内容是明文的，可以被抓包工具（如 Wireshark）截获。
2. **依赖 HTTPS**：只有结合 HTTPS 时，POST 请求的参数才会被加密传输，否则与 GET 一样存在被窃听的风险。
3. **服务器端漏洞**：如果服务器端没有对 POST 请求的参数进行严格验证，可能会导致 SQL 注入、XSS 等漏洞。
4. **代理服务器日志**：某些代理服务器可能会记录 POST 请求的内容，导致参数泄露。

------

### 总结

POST 的 “相对安全” 主要体现在：

- **参数隐藏**：避免了 GET 参数在 URL 中暴露的风险。
- **不被缓存**：减少了敏感数据被缓存泄露的可能。
- **幂等性**：降低了攻击者通过重复请求获取数据的风险。

但真正的安全需要依赖 **HTTPS** 和 **服务器端的严格验证**。POST 只是在默认情况下比 GET 更难被轻易利用，但并非绝对安全。



这个限制**不是由 HTTP 协议规定的**，而是由**浏览器和服务器共同决定**的。

### 具体来说：

1. **HTTP 协议本身没有限制**：HTTP/1.1 规范（RFC 2616）中并没有对 URL 的长度做出任何规定。理论上，HTTP 协议支持任意长度的 URL。

2. **浏览器的限制**：为了保证良好的用户体验和避免潜在的安全风险，**浏览器会对 URL 的长度施加限制**。这个限制是浏览器厂商自行决定的，不同浏览器之间可能会有所不同。

    - **常见的限制范围**：通常在 **2KB 到 8KB** 之间。

    - 具体例子 ：

        - **Chrome**: 以前的限制大约是 2MB，但在实际使用中，超过 8KB 的 URL 可能会导致问题，并且在某些版本中会有警告。
        - **Firefox**: 限制大约是 8KB。
        - **Safari**: 限制大约是 8KB。
        - **IE**: 历史上限制非常严格，大约是 2KB (2083 字符)。

    - **当 URL 超过限制时**：浏览器通常会直接截断 URL，或者弹出警告，或者干脆拒绝发送请求。

3. **服务器的限制**：即使浏览器允许发送很长的 URL，**服务器端也可能会有自己的限制**。这是为了防止 DoS（拒绝服务）攻击，因为处理非常长的 URL 会消耗更多的服务器资源。

    - Web 服务器 ：

        - **Apache**: `LimitRequestLine` 指令控制了请求行的最大长度，默认通常是 8190 字节。
        - **Nginx**: `client_header_buffer_size` 和 `large_client_header_buffers` 指令控制了请求头的大小。

    - 应用服务器 / 框架 ：

        - **Tomcat**: 也有类似的配置来限制请求头的大小。
        - **各种 Web 框架** (如 Spring Boot, Django, Flask) 也可能在处理请求时对 URL 长度有隐含的限制。

    - **当 URL 超过服务器限制时**：服务器通常会返回 `414 Request-URI Too Long` 的 HTTP 状态码。

### 总结

URL 的长度限制是一个**实际应用中的限制**，而非 HTTP 协议的规定。它是由**浏览器**和**服务器**共同作用的结果。

- **浏览器**为了自身的稳定性和用户体验，会限制 URL 的长度。
- **服务器**为了安全和性能，也会限制接收的 URL 的长度。

因此，在开发 Web 应用时，为了确保最大的兼容性和避免潜在的问题，**强烈建议将 URL 的长度控制在 2KB 以内**，或者更保守地，**使用 POST 请求来发送大量数据**，因为 POST 请求的数据是放在请求体（Request Body）中的，而请求体的大小限制通常要宽松得多。