### 一、为什么需要策略模式？

先看痛点场景：

- 你开发一个电商支付系统，需要支持多种支付方式（支付宝、微信、银联），每种支付方式的逻辑不同；
- 若用`if/else`实现：在`pay()`方法中判断支付类型，调用对应逻辑，新增支付方式（如 PayPal）时必须修改`pay()`方法，违反 “开闭原则”；
- 支付逻辑与订单逻辑耦合，代码臃肿且难以维护。

策略模式的解决思路：将每种支付方式封装为独立的`PaymentStrategy`类，订单类（客户端）持有策略对象，支付时直接调用策略的`pay()`方法，新增支付方式只需新增策略类，无需修改原有代码。

### 二、策略模式的核心结构

策略模式包含 4 个核心角色：

1. **抽象策略（Strategy）**：定义所有策略的通用接口（如支付方法`pay()`）；
2. **具体策略（Concrete Strategy）**：实现抽象策略接口，封装具体算法（如支付宝支付、微信支付）；
3. **环境类（Context）**：持有策略对象，提供设置 / 切换策略的接口，调用策略的算法（不负责选择策略，策略由客户端决定）；
4. **客户端（Client）**：创建具体策略对象，传递给环境类，决定使用哪种策略。

### 三、完整代码实现（支付场景）

#### 1. 抽象策略（Strategy）





```
// 支付策略抽象接口：定义通用支付方法
public interface PaymentStrategy {
    /**
     * 执行支付
     * @param amount 支付金额
     * @return 支付结果
     */
    String pay(double amount);

    // 获取支付方式名称
    String getPaymentName();
}
```

#### 2. 具体策略（Concrete Strategy）




```
// 具体策略1：支付宝支付
public class AlipayStrategy implements PaymentStrategy {
    private String userId; // 支付宝用户ID

    public AlipayStrategy(String userId) {
        this.userId = userId;
    }

    @Override
    public String pay(double amount) {
        // 模拟支付宝支付逻辑
        System.out.println("支付宝用户[" + userId + "]发起支付");
        return "支付宝支付成功，金额：" + amount + "元";
    }

    @Override
    public String getPaymentName() {
        return "支付宝";
    }
}

// 具体策略2：微信支付
public class WechatPayStrategy implements PaymentStrategy {
    private String openId; // 微信OpenID

    public WechatPayStrategy(String openId) {
        this.openId = openId;
    }

    @Override
    public String pay(double amount) {
        // 模拟微信支付逻辑
        System.out.println("微信用户[" + openId + "]发起支付");
        return "微信支付成功，金额：" + amount + "元";
    }

    @Override
    public String getPaymentName() {
        return "微信支付";
    }
}

// 具体策略3：银联支付
public class UnionPayStrategy implements PaymentStrategy {
    private String cardNo; // 银行卡号

    public UnionPayStrategy(String cardNo) {
        this.cardNo = cardNo;
    }

    @Override
    public String pay(double amount) {
        // 模拟银联支付逻辑
        System.out.println("银行卡[" + cardNo + "]发起支付");
        return "银联支付成功，金额：" + amount + "元";
    }

    @Override
    public String getPaymentName() {
        return "银联支付";
    }
}
```

#### 3. 环境类（Context）







```
// 订单环境类：持有支付策略，调用策略执行支付
public class Order {
    private String orderId;
    private double amount;
    // 持有策略对象（核心：面向抽象策略编程）
    private PaymentStrategy paymentStrategy;

    public Order(String orderId, double amount) {
        this.orderId = orderId;
        this.amount = amount;
    }

    // 设置/切换支付策略（灵活替换）
    public void setPaymentStrategy(PaymentStrategy paymentStrategy) {
        this.paymentStrategy = paymentStrategy;
    }

    // 执行支付：委托给策略对象
    public String pay() {
        if (paymentStrategy == null) {
            throw new RuntimeException("请先选择支付方式");
        }
        System.out.println("订单[" + orderId + "]使用" + paymentStrategy.getPaymentName() + "支付");
        return paymentStrategy.pay(amount);
    }
}
```

#### 4. 客户端使用示例







```
public class StrategyPatternDemo {
    public static void main(String[] args) {
        // 1. 创建订单（金额199.9元）
        Order order = new Order("ORD789", 199.9);

        // 2. 选择支付宝支付（切换策略1）
        order.setPaymentStrategy(new AlipayStrategy("zhangsan@alipay.com"));
        System.out.println(order.pay());
        System.out.println("-----");

        // 3. 切换为微信支付（切换策略2）
        order.setPaymentStrategy(new WechatPayStrategy("wx123456789"));
        System.out.println(order.pay());
        System.out.println("-----");

        // 4. 切换为银联支付（切换策略3）
        order.setPaymentStrategy(new UnionPayStrategy("622848XXXXXX1234"));
        System.out.println(order.pay());
    }
}
```

**输出结果**：







```
订单[ORD789]使用支付宝支付
支付宝用户[zhangsan@alipay.com]发起支付
支付宝支付成功，金额：199.9元
-----
订单[ORD789]使用微信支付
微信用户[wx123456789]发起支付
微信支付成功，金额：199.9元
-----
订单[ORD789]使用银联支付
银行卡[622848XXXXXX1234]发起支付
银联支付成功，金额：199.9元
```

### 四、策略模式的扩展：策略工厂（简化客户端）

若客户端需要频繁创建策略对象，可引入**策略工厂**封装策略的创建逻辑，进一步简化客户端代码：



```
// 支付策略工厂：创建策略对象
public class PaymentStrategyFactory {
    /**
     * 根据支付类型创建策略
     * @param type 支付类型（alipay/wechat/unionpay）
     * @param param 支付参数（userId/openId/cardNo）
     * @return 具体策略对象
     */
    public static PaymentStrategy createStrategy(String type, String param) {
        return switch (type) {
            case "alipay" -> new AlipayStrategy(param);
            case "wechat" -> new WechatPayStrategy(param);
            case "unionpay" -> new UnionPayStrategy(param);
            default -> throw new IllegalArgumentException("不支持的支付方式：" + type);
        };
    }
}

// 客户端简化使用
public class StrategyFactoryDemo {
    public static void main(String[] args) {
        Order order = new Order("ORD100", 299.8);
        
        // 通过工厂创建策略，客户端无需直接new策略对象
        PaymentStrategy strategy = PaymentStrategyFactory.createStrategy("alipay", "lisi@alipay.com");
        order.setPaymentStrategy(strategy);
        System.out.println(order.pay());
    }
}
```

### 五、策略模式 vs 状态模式（核心区别）

两者结构相似（都封装行为到独立类），但核心目标和使用场景完全不同，这是最易混淆的点：







|       维度       |                  策略模式                   |               状态模式               |
| :--------------: | :-----------------------------------------: | :----------------------------------: |
|     核心目标     | 封装**可替换的算法 / 策略**，客户端主动选择 | 封装**状态驱动的行为**，状态自动切换 |
|    行为触发者    |             客户端手动切换策略              |  状态内部自动切换（由状态变化触发）  |
|  类与上下文关系  |       策略类无上下文引用，仅执行算法        |   状态类持有上下文引用，可修改状态   |
| 行为与上下文关联 |         策略独立，与上下文状态无关          |       行为依赖上下文的当前状态       |
|     适用场景     |    多种算法可选（如支付方式、排序算法）     |  对象有明确状态流转（如订单、电梯）  |
|       示例       |       选择不同排序算法、不同支付方式        |      订单状态切换、电梯运行状态      |

### 六、策略模式的核心特点

#### 优点：

1. **消除`if/else`**：替代大量条件判断，代码更清晰、易维护；
2. **开闭原则**：新增策略只需添加新的策略类，无需修改原有代码；
3. **算法复用**：策略类可在不同场景复用（如支付宝支付可用于订单、充值）；
4. **灵活切换**：运行时可动态切换策略（如订单支付时临时切换支付方式）；
5. **单一职责**：每个策略类只负责一种算法，符合 “单一职责原则”。

#### 缺点：

1. **类数量增加**：每种策略对应一个类，策略过多时会导致类爆炸；
2. **客户端需了解策略**：客户端必须知道所有策略的区别，才能选择合适的策略；
3. **策略类无状态**：若策略需要维护状态，需注意线程安全（或使用享元模式）。

### 总结

1. **核心思想**：策略模式将算法与使用算法的代码解耦，核心是 “算法可替换、行为可动态切换”；

2. 适用场景 ：

    - 有多种算法 / 行为可选，且需要灵活切换；
    - 代码中存在大量与算法相关的`if/else`，难以维护；
    - 算法需要独立扩展，不影响使用算法的客户端；



3. 实现关键 ：

    - 抽象策略定义通用接口，具体策略实现各自算法；
    - 环境类持有策略对象，提供切换策略的接口，委托策略执行具体行为；
    - 客户端负责选择 / 创建具体策略，传递给环境类；



4. 优化建议 ：

    - 策略过多时，用策略工厂封装创建逻辑，简化客户端；
    - 无状态的策略可复用（如单例），避免创建大量实例；
    - 复杂场景可结合工厂模式 + 策略模式，进一步解耦。