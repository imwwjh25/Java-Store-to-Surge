### 一、三种工厂模式的核心实现与区别

#### 1. 简单工厂模式（Simple Creator.Factory）

**核心思想**：用一个 “工厂类” 根据传入的参数，决定创建哪一种产品实例（不属于 GoF 23 种设计模式，是工厂方法的简化版）。

**代码示例**：







```
// 1. 产品接口
interface Car {
    void drive();
}

// 2. 具体产品
class Benz implements Car {
    @Override
    public void drive() {
        System.out.println("开奔驰");
    }
}

class Bmw implements Car {
    @Override
    public void drive() {
        System.out.println("开宝马");
    }
}

// 3. 简单工厂类（核心）
class CarFactory {
    // 根据参数创建不同产品
    public static Car createCar(String type) {
        if ("benz".equals(type)) {
            return new Benz();
        } else if ("bmw".equals(type)) {
            return new Bmw();
        }
        return null;
    }
}

// 4. 使用示例
public class SimpleFactoryDemo {
    public static void main(String[] args) {
        // 无需直接new产品，通过工厂创建
        Car benz = CarFactory.createCar("benz");
        benz.drive(); // 输出：开奔驰
    }
}
```

**核心特点**：

- 结构最简单：一个工厂类 + 多个产品类，产品创建逻辑集中在工厂的`if/else`中。
- 扩展性差：新增产品（如 Audi）时，必须修改工厂类的`createCar`方法（违反 “开闭原则”：对扩展开放，对修改关闭）。
- 职责单一性差：工厂类承担了所有产品的创建逻辑，逻辑复杂时会变得臃肿。
- 适用场景：产品类型少、变化频率低的简单场景（如工具类创建）。

#### 2. 工厂方法模式（Creator.Factory Method）

**核心思想**：将 “创建具体产品” 的逻辑从单一工厂类，分散到**多个工厂子类**中（一个产品对应一个工厂），新增产品只需新增工厂类，符合开闭原则。

**代码示例**：









```
// 1. 产品接口
interface Car {
    void drive();
}

// 2. 具体产品
class Benz implements Car {
    @Override
    public void drive() {
        System.out.println("开奔驰");
    }
}

class Bmw implements Car {
    @Override
    public void drive() {
        System.out.println("开宝马");
    }
}

// 3. 工厂接口（定义创建产品的规范）
interface CarFactory {
    Car createCar();
}

// 4. 具体工厂（一个产品对应一个工厂）
class BenzFactory implements CarFactory {
    @Override
    public Car createCar() {
        return new Benz();
    }
}

class BmwFactory implements CarFactory {
    @Override
    public Car createCar() {
        return new Bmw();
    }
}

// 5. 使用示例
public class FactoryMethodDemo {
    public static void main(String[] args) {
        // 创建奔驰工厂 → 生产奔驰
        CarFactory benzFactory = new BenzFactory();
        Car benz = benzFactory.createCar();
        benz.drive(); // 输出：开奔驰
    }
}
```

**核心特点**：

- 结构分层：产品接口 + 具体产品；工厂接口 + 具体工厂（一对一）。
- 扩展性好：新增产品（如 Audi）时，只需新增`Audi`类和`AudiFactory`类，无需修改原有代码（符合开闭原则）。
- 职责拆分：每个工厂子类只负责创建一种产品，避免工厂类逻辑臃肿。
- 缺点：产品种类增多时，工厂类数量会成倍增加（类爆炸）。
- 适用场景：产品类型较多、需要频繁新增产品，且产品之间无关联的场景（如不同品牌的汽车、不同类型的日志记录器）。

#### 3. 抽象工厂模式（Abstract Creator.Factory）

**核心思想**：工厂方法的升级版，用于创建**一组相关 / 依赖的产品族**（而非单个产品），一个工厂负责创建一个产品族的所有产品。

**代码示例**：






```
// 1. 产品族1：汽车
interface Car {
    void drive();
}
class BenzCar implements Car {
    @Override
    public void drive() {
        System.out.println("开奔驰汽车");
    }
}
class BmwCar implements Car {
    @Override
    public void drive() {
        System.out.println("开宝马汽车");
    }
}

// 2. 产品族2：摩托车（和汽车属于同一品牌的“产品族”）
interface Motorcycle {
    void ride();
}
class BenzMotorcycle implements Motorcycle {
    @Override
    public void ride() {
        System.out.println("骑奔驰摩托车");
    }
}
class BmwMotorcycle implements Motorcycle {
    @Override
    public void ride() {
        System.out.println("骑宝马摩托车");
    }
}

// 3. 抽象工厂（定义创建“产品族”的规范）
interface VehicleFactory {
    Car createCar();       // 创建汽车
    Motorcycle createMotorcycle(); // 创建摩托车
}

// 4. 具体工厂（一个工厂创建一个品牌的所有产品）
class BenzFactory implements VehicleFactory {
    @Override
    public Car createCar() {
        return new BenzCar();
    }
    @Override
    public Motorcycle createMotorcycle() {
        return new BenzMotorcycle();
    }
}

class BmwFactory implements VehicleFactory {
    @Override
    public Car createCar() {
        return new BmwCar();
    }
    @Override
    public Motorcycle createMotorcycle() {
        return new BmwMotorcycle();
    }
}

// 5. 使用示例
public class AbstractFactoryDemo {
    public static void main(String[] args) {
        // 创建奔驰工厂 → 生产奔驰的汽车+摩托车（产品族）
        VehicleFactory benzFactory = new BenzFactory();
        Car benzCar = benzFactory.createCar();
        Motorcycle benzMotor = benzFactory.createMotorcycle();
        
        benzCar.drive();     // 输出：开奔驰汽车
        benzMotor.ride();    // 输出：骑奔驰摩托车
    }
}
```

**核心特点**：

- 面向 “产品族”：解决**一组相关产品**的创建问题（如奔驰的汽车 + 摩托车、华为的手机 + 平板），产品族内的产品有依赖关系。
- 扩展性：新增 “产品族”（如 Audi 的汽车 + 摩托车）只需新增`AudiFactory`及对应产品类（符合开闭原则）；但新增 “产品类型”（如新增自行车）需修改抽象工厂和所有具体工厂（违反开闭原则）。
- 复杂度高：结构最复杂，适合大规模、产品族明确的场景。
- 适用场景：需要创建一组相关产品，且产品族相对固定的场景（如跨平台组件：Windows 版按钮 + 输入框、Mac 版按钮 + 输入框）。

### 二、三种工厂模式核心区别对比表





|   维度   |         简单工厂模式         |          工厂方法模式          |           抽象工厂模式           |
| :------: | :--------------------------: | :----------------------------: | :------------------------------: |
| 核心目标 | 创建**单个产品**（任意类型） |  创建**单个产品**（指定类型）  |      创建**一组相关产品族**      |
| 工厂数量 |       1 个（全能工厂）       |    N 个（一个产品一个工厂）    |    M 个（一个产品族一个工厂）    |
| 开闭原则 |    违反（新增产品改工厂）    |     符合（新增产品加工厂）     | 产品族扩展符合，产品类型扩展违反 |
| 类复杂度 |          低（少类）          |     中（类数量随产品增加）     | 高（产品族 + 产品类型双层结构）  |
| 适用场景 |        产品少、变化少        |     产品多、需灵活新增产品     |    产品族明确、需创建一组产品    |
| 典型案例 |   工具类创建（如日志工厂）   | 单一产品创建（如不同品牌汽车） |    跨平台组件（如 UI 组件族）    |

### 总结

1. **核心差异**：简单工厂是 “单一工厂造所有产品”，工厂方法是 “一个工厂造一个产品”，抽象工厂是 “一个工厂造一组相关产品”。

2. 选型原则 ：

    - 产品少、变化少 → 简单工厂（简单高效）；
    - 产品多、需频繁新增单个产品 → 工厂方法（灵活扩展）；
    - 需创建一组相关产品、产品族固定 → 抽象工厂（统一管理产品族）。



3. **本质不变**：三种模式都遵循 “创建与使用分离” 的核心思想，降低耦合，提升代码可维护性。