### 一、为什么需要装饰者模式？

先看痛点场景：

- 你有一个基础的`Coffee`类，提供`cost()`方法返回咖啡价格（如美式咖啡 10 元）；
- 需求是给咖啡添加配料（牛奶、糖、奶泡），每种配料增加不同价格；
- 若用继承实现：需要创建`CoffeeWithMilk`、`CoffeeWithSugar`、`CoffeeWithMilkAndSugar`等无数子类，类数量会指数级增长（类爆炸）。

装饰者模式的解决思路：将 “牛奶、糖” 等配料封装成独立的装饰器类，动态包裹基础咖啡对象，按需组合功能，无需创建大量子类。

### 二、装饰者模式的核心结构

装饰者模式包含 4 个核心角色：

1. **抽象组件（Component）**：定义基础对象和装饰器的共同接口（如`Coffee`）；
2. **具体组件（Concrete Component）**：基础对象，提供核心功能（如`Americano`）；
3. **抽象装饰器（Decorator）**：实现抽象组件接口，持有一个抽象组件对象（被装饰者）；
4. **具体装饰器（Concrete Decorator）**：扩展抽象装饰器，添加具体的额外功能（如`MilkDecorator`、`SugarDecorator`）。

### 三、完整代码实现（咖啡配料场景）

#### 1. 抽象组件（Component）







```
// 咖啡抽象组件：定义核心方法（获取价格、获取描述）
public interface Coffee {
    // 获取价格
    double cost();
    // 获取咖啡描述（基础+配料）
    String getDescription();
}
```

#### 2. 具体组件（Concrete Component）





```
// 具体组件1：美式咖啡（基础咖啡）
public class Americano implements Coffee {
    @Override
    public double cost() {
        return 10.0; // 基础价格10元
    }

    @Override
    public String getDescription() {
        return "美式咖啡";
    }
}

// 具体组件2：拿铁咖啡（基础咖啡）
public class Latte implements Coffee {
    @Override
    public double cost() {
        return 15.0; // 基础价格15元
    }

    @Override
    public String getDescription() {
        return "拿铁咖啡";
    }
}
```

#### 3. 抽象装饰器（Decorator）







```
// 咖啡装饰器抽象类：实现Coffee接口，持有Coffee对象
public abstract class CoffeeDecorator implements Coffee {
    // 被装饰的咖啡对象（核心：组合而非继承）
    protected Coffee coffee;

    public CoffeeDecorator(Coffee coffee) {
        this.coffee = coffee;
    }
}
```

#### 4. 具体装饰器（Concrete Decorator）










```
// 具体装饰器1：牛奶配料
public class MilkDecorator extends CoffeeDecorator {
    public MilkDecorator(Coffee coffee) {
        super(coffee);
    }

    // 扩展功能：添加牛奶的价格
    @Override
    public double cost() {
        return coffee.cost() + 2.0; // 基础价格+牛奶2元
    }

    // 扩展描述：添加牛奶说明
    @Override
    public String getDescription() {
        return coffee.getDescription() + " + 牛奶";
    }
}

// 具体装饰器2：糖配料
public class SugarDecorator extends CoffeeDecorator {
    public SugarDecorator(Coffee coffee) {
        super(coffee);
    }

    @Override
    public double cost() {
        return coffee.cost() + 1.0; // 基础价格+糖1元
    }

    @Override
    public String getDescription() {
        return coffee.getDescription() + " + 糖";
    }
}

// 具体装饰器3：奶泡配料
public class FoamDecorator extends CoffeeDecorator {
    public FoamDecorator(Coffee coffee) {
        super(coffee);
    }

    @Override
    public double cost() {
        return coffee.cost() + 3.0; // 基础价格+奶泡3元
    }

    @Override
    public String getDescription() {
        return coffee.getDescription() + " + 奶泡";
    }
}
```

#### 5. 客户端使用示例









```
public class DecoratorPatternDemo {
    public static void main(String[] args) {
        // 1. 基础咖啡：美式咖啡
        Coffee coffee = new Americano();
        System.out.println(coffee.getDescription() + "：" + coffee.cost() + "元");
        // 输出：美式咖啡：10.0元

        // 2. 动态添加牛奶：美式咖啡+牛奶
        coffee = new MilkDecorator(coffee);
        System.out.println(coffee.getDescription() + "：" + coffee.cost() + "元");
        // 输出：美式咖啡 + 牛奶：12.0元

        // 3. 继续添加糖和奶泡：美式咖啡+牛奶+糖+奶泡
        coffee = new SugarDecorator(coffee);
        coffee = new FoamDecorator(coffee);
        System.out.println(coffee.getDescription() + "：" + coffee.cost() + "元");
        // 输出：美式咖啡 + 牛奶 + 糖 + 奶泡：16.0元

        // 4. 另一种组合：拿铁+牛奶+奶泡
        Coffee latte = new Latte();
        latte = new MilkDecorator(latte);
        latte = new FoamDecorator(latte);
        System.out.println(latte.getDescription() + "：" + latte.cost() + "元");
        // 输出：拿铁咖啡 + 牛奶 + 奶泡：20.0元
    }
}
```

### 四、装饰者模式的核心特点

#### 优点：

1. **灵活扩展**：无需修改原有代码，通过组合装饰器动态添加 / 移除功能（符合 “开闭原则”）；
2. **避免类爆炸**：相比继承（每种组合一个子类），装饰者将功能拆分为独立装饰器，按需组合；
3. **功能粒度化**：每个装饰器只负责一个功能，符合 “单一职责原则”；
4. **多层装饰**：可嵌套多个装饰器，实现复杂功能组合。

#### 缺点：

1. **复杂度增加**：过多装饰器会导致类数量增多，调试时需要逐层排查（如价格计算需看嵌套的装饰器）；
2. **顺序敏感**：装饰器的组合顺序可能影响结果（如先加牛奶和先加糖不影响价格，但某些场景可能有影响）；
3. **对象透明性**：客户端需要知道装饰器的存在，才能正确组合功能（不像继承那样 “一劳永逸”）。

### 五、装饰者模式 vs 适配器模式（核心区别）

这是最易混淆的两个模式，核心差异在于**目标不同**：







|    维度    |                        装饰者模式                        |             适配器模式             |
| :--------: | :------------------------------------------------------: | :--------------------------------: |
|  核心目标  |              增强 / 扩展原有对象的**功能**               | 解决接口**不兼容**问题（转换接口） |
|  接口关系  |             装饰器和被装饰者**实现同一接口**             |      适配者和目标接口**不同**      |
|  对象关系  |             装饰者 “包裹” 被装饰者，功能叠加             |   适配器 “封装” 适配者，接口转换   |
| 客户端感知 |            明确知道要扩展功能，主动组合装饰器            | 只知道目标接口，不知道适配者的存在 |
|  典型示例  | 咖啡加配料、Java IO 流（BufferedReader 装饰 FileReader） |      支付接口适配、电源适配器      |

### 六、经典应用：Java IO 流

Java 的 IO 体系是装饰者模式的完美实践，比如：

- 抽象组件：`InputStream`/`OutputStream`/`Reader`/`Writer`；
- 具体组件：`FileInputStream`（基础文件流）、`StringReader`（字符串流）；
- 抽象装饰器：`FilterInputStream`/`FilterReader`；
- 具体装饰器：`BufferedInputStream`（缓冲功能）、`DataInputStream`（读取基本类型数据）。

示例代码（IO 流中的装饰者）：









```
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

public class IoDecoratorDemo {
    public static void main(String[] args) throws IOException {
        // 基础组件：FileReader（读取文件）
        // 装饰器1：BufferedReader（添加缓冲功能，提升读取效率）
        BufferedReader br = new BufferedReader(new FileReader("test.txt"));
        String line = br.readLine();
        System.out.println(line);
        br.close();
    }
}
```

### 总结

1. **核心思想**：装饰者模式通过 “组合而非继承” 的方式，动态给对象添加功能，核心是 “扩展” 而非 “转换”；

2. 适用场景 ：

    - 需要动态给对象添加 / 移除功能；
    - 避免用继承实现功能扩展（防止类爆炸）；
    - 功能可拆分为多个独立的可叠加模块（如咖啡配料、IO 流功能）；



3. 实现关键 ：

    - 装饰器和被装饰者必须实现同一抽象组件接口；
    - 抽象装饰器持有被装饰者对象，通过组合实现功能叠加；



4. **经典案例**：Java IO 流、Spring 的`TransactionAwareCacheDecorator`（缓存事务装饰）。