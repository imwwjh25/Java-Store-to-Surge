
## 一、G1 可达性分析的基础依赖

在分析前，需先理解 G1 的两个关键设计 —— 这是其可达性分析高效性的前提：

### 1. 堆分区（Region）：缩小分析范围

G1 将 Java 堆划分为多个大小相等的**独立 Region**（默认 256MB 以内，大小可配置，如 1MB、2MB 等），每个 Region 可动态扮演 3 种角色：



- **年轻代 Region（Eden/Survivor）**：存放新创建的对象，回收频率高。
- **老年代 Region（Old）**：存放存活时间长的对象，回收频率低。
- **大对象 Region（Humongous）**：存放超过 Region 大小 50% 的大对象，直接分配在老年代附近。



**对可达性分析的意义**：无需对整个堆进行全量扫描，只需针对 “待分析的 Region” 及其关联引用（通过 RS 记录）进行处理，大幅缩小分析范围。

### 2. 记忆集（Remembered Set, RS）：解决跨 Region 引用

由于 Region 是独立的，一个 Region 中的对象可能被其他 Region 的对象引用（如 Old Region 引用 Eden Region 的对象）。若不记录这些引用，可达性分析时需遍历所有 Region 才能找到完整引用链，效率极低。



G1 为**每个 Region 配备一个 RS**，其核心作用是：



- 记录 “其他 Region 对当前 Region 中对象的引用”（即**跨 Region 入引用**）。
- 本质是一个 “哈希表”：Key 为 “引用源 Region 的起始地址”，Value 为 “引用所在的卡页（Card Page）”（堆被划分为 512B 的卡页，一个卡页对应多个对象）。



**对可达性分析的意义**：分析某个 Region 时，无需扫描全堆，只需通过其 RS 获取 “外部 Region 对它的引用”，再判断这些引用是否来自可达对象，避免全堆遍历的开销。

## 二、G1 可达性分析的核心流程

G1 的可达性分析嵌入在其 **“标记 - 清理 - 整理”** 周期中，核心分为 4 个阶段（前 3 个阶段完成可达性判断，第 4 个阶段基于结果回收）：

### 阶段 1：初始标记（Initial Mark）—— 快速标记根关联对象（STW）

此阶段为**短时间 STW**（毫秒级），仅做两件事：



1. 确定 GC Roots 集合

   ：G1 的根对象与其他收集器一致，包括：

    - 虚拟机栈（栈帧中的局部变量表）引用的对象；
    - 本地方法栈（JNI）引用的对象；
    - 方法区中静态变量、常量引用的对象；
    - 已启动的线程对象（Thread 实例）；
    - 被同步锁（synchronized）持有的对象。

2. **标记 “根直接关联的对象”**：仅遍历 GC Roots 直接引用的对象（不深入遍历引用链），并将这些对象标记为 “存活”，同时记录它们所在的 Region。



例如：若虚拟机栈中有一个引用指向 Eden Region 的对象 A，则初始标记会直接标记 A 为存活，无需处理 A 引用的其他对象。

### 阶段 2：并发标记（Concurrent Mark）—— 遍历引用链（并发执行）

此阶段**应用线程不暂停**，GC 线程与应用线程并发执行，核心是 “基于初始标记的结果，遍历完整的对象引用链”，具体分两步：



1. **遍历本地引用链**：对初始标记阶段标记的 “根关联对象”，递归遍历它们引用的子对象，将所有可达对象标记为 “存活”。
    - 若对象在**同一 Region 内**，直接继续遍历；
    - 若对象在**其他 Region**，则通过目标 Region 的 RS 记录 “当前 Region 对它的引用”（后续分析目标 Region 时会用到）。
2. **处理跨 Region 引用（依赖 RS）**：在遍历过程中，若遇到 “当前 Region 的对象引用了其他 Region 的对象”，会通过**写屏障（Write Barrier）** 更新目标 Region 的 RS（将当前引用所在的卡页记录到 RS 中）；反之，若分析一个 Region 时，需通过其 RS 获取 “外部 Region 对它的引用”，判断这些外部引用是否来自可达对象，若来自可达对象，则标记对应的内部对象为存活。

#### 关键技术：SATB（Snapshot-At-The-Beginning）—— 保证并发标记的一致性

并发标记时，应用线程会修改对象引用（如将对象 A 的引用从 B 改为 C），可能导致 “漏标”（如 B 原本可达，但引用被改后未被遍历，误判为垃圾）。G1 通过**SATB 机制**解决此问题，核心是 “在 GC 开始时生成对象图的快照，确保所有可达对象都被标记”：



- **快照生成**：初始标记阶段结束后，G1 会记录 “所有当前存活对象的引用关系”，形成一个快照。
- **写屏障记录变化**：并发标记期间，若应用线程修改对象引用（如 A→B 改为 A→C），会触发**写屏障**，将 “被覆盖的旧引用 B” 记录到**SATB 日志**中。
- **补充标记**：后续阶段会处理 SATB 日志，确保旧引用 B 对应的对象（及它引用的对象）被纳入可达性分析，避免漏标。



简单说：SATB 确保 “GC 开始时存活的对象，即使后续引用被修改，也能被正确标记为存活”。

### 阶段 3：重新标记（Remark）—— 修正并发标记的遗漏（STW）

此阶段为**短时间 STW**（比初始标记稍长，但仍毫秒级），核心是 “处理并发标记阶段的遗留问题”，确保可达性分析的准确性：



1. **处理 SATB 日志**：遍历并发标记期间记录的 “旧引用（SATB 日志）”，判断这些旧引用对应的对象是否可达，若可达则标记为存活。
2. **扫描漏标的根引用**：并发标记期间，可能有新的线程创建或栈帧变化（如方法调用结束），导致部分根引用未被初始标记扫描，此阶段会重新扫描这些动态变化的根引用，补充标记其关联的对象。
3. **清理无效 RS 条目**：删除 RS 中 “引用源对象已被标记为垃圾” 的无效条目，减少后续回收的开销。



至此，G1 完成了**全堆对象的可达性分析**：所有被标记为 “存活” 的对象，都是 GC Roots 可达的；未被标记的对象，则是待回收的垃圾。

### 阶段 4：筛选回收（Live Data Counting & Evacuation）—— 基于分析结果回收

此阶段并非可达性分析的一部分，但依赖其结果：



1. **计算 Region 存活密度**：G1 遍历所有 Region，统计每个 Region 中 “存活对象的占比”（存活对象大小 / Region 总大小）。
2. **优先回收垃圾多的 Region**：选择 “存活密度最低”（即垃圾最多）的 Region 进行回收（这也是 “Garbage-First” 的由来），回收时将 Region 中的存活对象复制到其他空 Region，再清空当前 Region（本质是 “复制算法”，避免内存碎片）。

## 三、G1 可达性分析的核心特点

对比 CMS（Concurrent Mark-Sweep）等其他并发收集器，G1 的可达性分析有 3 个关键优势：



1. **分区化减少扫描范围**：通过 Region 划分，无需全堆扫描，仅需处理目标 Region 及其 RS，效率更高。
2. **SATB 保证快照一致性**：基于 “GC 开始时的快照” 和写屏障记录，避免并发标记的漏标问题，比 CMS 的 “增量更新（Incremental Update）” 更适合大堆场景（CMS 增量更新需追踪引用变更，大堆下开销更高）。
3. **RS 解决跨 Region 引用**：通过记忆集记录跨 Region 引用，避免全堆遍历，是分区架构下可达性分析的核心支撑。

## 总结

G1 的可达性分析是一个 “**基于分区架构、依赖 RS 和 SATB 机制、分阶段（初始标记 - 并发标记 - 重新标记）完成**” 的过程：



- 基础：通过 Region 缩小分析范围，通过 RS 解决跨 Region 引用；
- 核心：以 SATB 机制保证并发标记的一致性，分 STW 阶段（初始 / 重新标记）和并发阶段（并发标记）完成可达性判断；
- 目标：为后续 “优先回收垃圾多的 Region” 提供准确的存活对象信息，兼顾回收效率和低 STW 时间。
