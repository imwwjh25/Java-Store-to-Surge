## [26校招阿里后端面经](https://www.nowcoder.com/feed/main/detail/b26771b5d32c443ba522d7db0dff938d)


### 1. 对 Spring Boot 的理解，以及为什么要用 Spring Boot？

#### 核心理解

Spring Boot 是 Spring 框架的**快速开发脚手架**，它基于 Spring 框架，通过 “约定大于配置” 的理念，简化了 Spring 应用的搭建、配置和部署流程。它不是对 Spring 的替代，而是对 Spring 的封装和增强。

#### 为什么要用 Spring Boot？

- **简化配置**：告别 Spring 繁琐的 XML 配置，通过注解、自动配置实现零配置 / 少配置启动项目。
- **内嵌服务器**：内置 Tomcat/Jetty/Undertow，无需手动部署 WAR 包，直接`java -jar`启动。
- **起步依赖（Starter）**：如`spring-boot-starter-web`整合了 web 开发所需的 Spring MVC、Tomcat、jackson 等依赖，无需手动管理依赖版本。
- **自动配置**：根据类路径下的依赖自动配置 Bean（如引入`spring-boot-starter-data-jpa`就自动配置 JPA 相关 Bean）。
- **监控与运维**：通过`spring-boot-starter-actuator`可快速实现应用健康检查、指标监控。
- **快速开发**：从搭建项目到运行，几分钟就能完成，大幅降低开发门槛。

### 2. AOP 的实现方式

AOP（面向切面编程）的核心是**将通用逻辑（如日志、事务、权限）与业务逻辑解耦**，其实现方式主要分为两大类：

#### （1）静态织入（编译期）

- **原理**：在 Java 编译成字节码（.class）的阶段，将切面逻辑直接织入目标类的字节码中，最终生成的 class 文件包含了切面逻辑。
- **代表技术**：AspectJ（最主流的静态 AOP 实现）。
- **特点**：性能高（织入在编译期完成，运行时无额外开销），但需要特殊的编译插件（如 maven 的 aspectj-maven-plugin）。

#### （2）动态代理（运行期）

- **原理**：在程序运行时，动态生成目标类的代理对象，切面逻辑通过代理对象执行（不修改原目标类的字节码）。

- 细分实现

  ：

    1. **JDK 动态代理**：基于接口实现，要求目标类必须实现接口，通过`java.lang.reflect.Proxy`和`InvocationHandler`生成代理类。
    2. **CGLib 动态代理**：基于继承实现，无需目标类实现接口，通过 ASM 字节码框架生成目标类的子类作为代理类。



- **特点**：无需特殊编译步骤，灵活，但运行时会有轻微的代理开销（可忽略）。

### 3. 除了 JDK Proxy 和 CGLib，还有别的实现 AOP 的方式吗？

有，除了主流的 JDK Proxy 和 CGLib，还有以下几种方式：

1. **AspectJ 静态织入**：如上文所述，编译期织入，不属于动态代理范畴，是独立的 AOP 实现。
2. **ByteBuddy**：新一代字节码操作库，比 CGLib 更高效、易用，Spring 5 + 默认用 ByteBuddy 替代 CGLib 实现动态代理。
3. **Javassist**：开源的字节码编辑库，可在运行时动态修改 / 生成字节码，也能实现 AOP（如 MyBatis 的动态代理就用到了 Javassist）。
4. **Spring AOP 的混合实现**：Spring AOP 默认优先用 JDK Proxy（目标类有接口），无接口时用 CGLib/ByteBuddy，本质是对动态代理的封装，但属于 Spring 特有的 AOP 实现方式。
5. **字节码增强框架（如 ASM）**：直接操作字节码指令，手动织入切面逻辑（底层实现，一般不直接使用）。

### 4. Spring Boot 简化配置具体是如何简化的？

Spring Boot 的配置简化体现在**消除冗余配置**和**自动化配置**，核心方式如下：

#### （1）消除 XML 配置

Spring Boot 完全摒弃了 Spring 的 XML 配置（如`applicationContext.xml`），转而使用：

- **注解配置**：如`@Configuration`（替代 XML 的`<beans>`）、`@Bean`（替代`<bean>`）、`@Autowired`（依赖注入）。
- **属性配置文件**：通过`application.properties`/`application.yml`集中管理配置，而非分散在多个 XML 中。

#### （2）自动配置（AutoConfiguration）

- **核心原理**：Spring Boot 启动时，通过`@EnableAutoConfiguration`注解扫描`META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports`文件，加载所有自动配置类（如`WebMvcAutoConfiguration`、`DataSourceAutoConfiguration`）。

- 条件触发

  ：自动配置类通过

  ```
  @Conditional
  ```

  系列注解（如

  ```
  @ConditionalOnClass
  ```

  、

  ```
  @ConditionalOnMissingBean
  ```

  ）判断是否生效：

    - 例：类路径下有`DispatcherServlet`才会启用 WebMvcAutoConfiguration；
    - 例：用户未自定义`DataSource` Bean 时，才会自动配置默认的数据源。



#### （3）起步依赖（Starter）

- 把相关依赖打包成一个 starter（如`spring-boot-starter-jdbc`包含 jdbc 核心包、连接池、Spring JDBC 等），只需引入一个 starter，无需手动引入多个依赖，且 Spring Boot 统一管理版本，避免版本冲突。

#### （4）默认配置值

- 为常用配置提供默认值，无需手动配置：

    - 例：内嵌 Tomcat 默认端口 8080；
    - 例：数据源默认连接池 HikariCP；
    - 例：日志默认使用 Logback。



#### （5）配置绑定

通过`@ConfigurationProperties`将配置文件中的属性绑定到 Java 类，无需手动读取配置：

java



运行









```
// 绑定application.yml中prefix为"my.datasource"的属性
@ConfigurationProperties(prefix = "my.datasource")
public class DataSourceProperties {
    private String url;
    private String username;
    // getter/setter
}
```

### 6. Spring Boot 是通过什么实现 “约定大于配置” 的？

“约定大于配置” 核心是：**默认遵循一套约定规则，无需配置；仅当需要偏离约定时，才手动配置**。Spring Boot 的实现方式如下：

#### （1）默认目录结构约定

- 源码默认放在`src/main/java`，资源文件放在`src/main/resources`；
- 配置文件默认命名为`application.properties/yml`，且放在`src/main/resources`根目录；
- 静态资源（js/css/img）默认放在`src/main/resources/static`；
- 模板文件（如 Thymeleaf）默认放在`src/main/resources/templates`；
- 主启动类默认放在根包下（如`com.example.demo`），Spring Boot 会自动扫描该包及其子包的 Bean。

#### （2）自动配置类的约定

- 自动配置类遵循 “先判断条件，再提供默认 Bean” 的约定：

    - 例：`DataSourceAutoConfiguration`默认使用 HikariCP 连接池，仅当用户配置`spring.datasource.type`时才切换；
    - 例：`WebMvcAutoConfiguration`默认映射`/`到静态资源，默认视图解析器前缀`/templates/`、后缀`.html`。



#### （3）起步依赖的版本约定

- Spring Boot 通过`spring-boot-dependencies`父工程统一管理所有依赖的版本，引入 starter 时无需指定版本，遵循父工程的版本约定；
- 例：引入`spring-boot-starter-web`时，默认依赖 Spring MVC 6.x、Tomcat 10.x（取决于 Spring Boot 版本）。

#### （4）属性配置的命名约定

- 配置属性遵循统一的命名规范，如`spring.datasource.url`、`server.port`，用户只需按约定命名，就能被自动配置类识别；
- 若偏离约定（如自定义配置文件名），需手动指定：`@PropertySource("classpath:custom.properties")`。

#### （5）条件注解的约定

- `@ConditionalOnMissingBean`：约定 “用户未自定义 Bean 时，使用默认 Bean”；
- `@ConditionalOnClass`：约定 “类路径下有指定类时，才启用该配置”；
- 这些注解确保了 “默认遵循约定，自定义覆盖约定” 的核心逻辑。

### 7. Maven 解决版本冲突，使两个版本的包都能被使用的方案

Maven 默认遵循 “最短路径优先”“声明优先” 原则解决版本冲突，但默认只能用一个版本。若需同时使用两个版本的包，核心方案是**隔离依赖**，具体如下：

#### 方案 1：使用 Maven Shade 插件（最常用）

- **原理**：将其中一个版本的包重新打包（修改包名），避免类名冲突，从而在工程中同时引用两个版本。

- 步骤

  ：

    1. 创建一个独立的 Maven 模块，引入需要隔离的包（如 commons-collections 3.2.1）；

    2. 在该模块的 pom.xml 中配置 shade 插件，重命名包路径：

       xml











     ```
     <build>
         <plugins>
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-shade-plugin</artifactId>
                 <version>3.5.0</version>
                 <executions>
                     <execution>
                         <phase>package</phase>
                         <goals><goal>shade</goal></goals>
                         <configuration>
                             <relocations>
                                 <!-- 将org.apache.commons.collections重命名为org.apache.commons.collections.v3 -->
                                 <relocation>
                                     <pattern>org.apache.commons.collections</pattern>
                                     <shadedPattern>org.apache.commons.collections.v3</shadedPattern>
                                 </relocation>
                             </relocations>
                         </configuration>
                     </execution>
                 </executions>
             </plugin>
         </plugins>
     </build>
     ```



3. 主工程引入该模块，同时引入另一个版本的包（如 commons-collections 4.4），通过不同的包名调用不同版本的类。



#### 方案 2：使用 OSGi 容器

- **原理**：OSGi（如 Apache Felix、Eclipse Equinox）支持同一个 JVM 中运行不同版本的类，通过类加载器隔离不同版本的包。
- **缺点**：复杂度高，学习成本大，一般不推荐新手使用。

#### 方案 3：自定义类加载器

- **原理**：为不同版本的包创建独立的类加载器，加载时指定类加载器，避免类冲突。

- 示例

  ：

  java



运行









  ```
  // 自定义类加载器加载版本1的包
  ClassLoader loader1 = new URLClassLoader(new URL[]{new File("commons-collections-3.2.1.jar").toURI().toURL()}, null);
  Class<?> clazz1 = loader1.loadClass("org.apache.commons.collections.MapUtils");
  
  // 系统类加载器加载版本2的包
  Class<?> clazz2 = Class.forName("org.apache.commons.collections.MapUtils");
  ```



- **缺点**：手动管理类加载器，易引发内存泄漏，仅适合特殊场景。

### 8. 分布式调度系统需要考虑的核心点

分布式调度系统（如 XXL-Job、Elastic-Job）的核心是**在多节点集群中协调任务执行**，需考虑以下关键点：

#### （1）任务调度核心能力

- **任务触发**：支持 CRON 表达式、固定频率、固定延迟、手动触发等触发方式；
- **任务分发**：将任务合理分发到集群节点，避免单点负载过高；
- **任务执行**：支持同步 / 异步执行、分片执行（大任务拆分成小任务，多节点并行执行）；
- **任务监控**：监控任务执行状态（成功 / 失败 / 运行中）、执行耗时、日志。

#### （2）高可用

- **调度中心高可用**：调度中心部署多节点，避免单点故障（如 XXL-Job 的调度中心集群）；
- **执行节点高可用**：执行节点集群部署，某个节点宕机后，任务可转移到其他节点执行；
- **失败重试**：任务执行失败后自动重试，支持自定义重试次数和间隔；
- **故障转移**：执行节点宕机时，未完成的任务自动切换到其他节点。

#### （3）一致性与幂等性

- **分布式锁**：防止同一任务在多个节点重复执行（如基于 Redis/ZooKeeper 实现分布式锁）；
- **幂等性设计**：确保任务重复执行（如重试、故障转移）时，结果一致（如通过唯一 ID、状态机、防重表实现）。

#### （4）性能与扩展性

- **任务分片**：将大任务拆分为多个分片，多节点并行执行，提升执行效率；
- **动态扩缩容**：支持执行节点动态增减，调度系统自动感知并调整任务分发；
- **异步执行**：非核心任务异步执行，避免阻塞调度中心。

#### （5）可靠性

- **任务持久化**：任务配置、执行记录持久化到数据库（如 MySQL），避免重启丢失；
- **日志持久化**：任务执行日志持久化，方便排查问题；
- **告警机制**：任务失败、超时、执行异常时，通过邮件 / 短信 / 钉钉告警。

#### （6）安全性

- **权限控制**：任务的新增 / 修改 / 删除需权限验证；
- **接口鉴权**：调度中心与执行节点之间的通信需鉴权（如 XXL-Job 的 access_token）；
- **防恶意调度**：限制任务执行频率，避免恶意触发任务。

### 9. 分布式调度集群保证高可用的思路

要实现调度集群的高可用，核心是**消除单点故障**，同时保证调度逻辑的一致性，具体思路如下：

#### （1）调度中心集群化

- **无状态设计**：调度中心本身设计为无状态（配置 / 数据持久化到数据库），多节点部署，通过负载均衡（如 Nginx）对外提供服务；
- **主从选举**：调度中心节点通过分布式锁（如 ZooKeeper/Redis）选举出 “主节点”，仅主节点负责触发任务，从节点待命；主节点宕机后，从节点重新选举，保证调度不中断（如 Elastic-Job 的主从选举）。

#### （2）执行节点集群化

- **去中心化**：执行节点无主从之分，均注册到调度中心，调度中心可将任务分发到任意节点；
- **故障检测**：调度中心通过心跳检测执行节点状态，宕机节点被标记为不可用，任务不再分发到该节点；
- **分片容错**：分片任务执行时，若某个分片节点宕机，可将该分片重新分配到其他节点（如 XXL-Job 的分片广播 + 故障转移）。

#### （3）数据一致性保障

- **统一存储**：任务配置、执行记录、分片信息等统一存储到数据库（如 MySQL），所有节点共享数据源；
- **分布式锁**：关键操作（如任务触发、分片分配）加分布式锁，避免并发冲突；
- **事务控制**：任务状态更新（如从 “运行中” 改为 “成功”）通过数据库事务保证原子性。

#### （4）兜底机制

- **任务超时控制**：设置任务最大执行时间，超时自动终止，避免任务卡死；
- **死信队列**：执行失败的任务进入死信队列，人工介入处理；
- **监控告警**：实时监控集群节点状态、任务执行成功率，异常时立即告警。

### 10. JVM 的内存区域、作用及常见 GC

#### （1）JVM 内存区域（基于 JDK 8+）

JVM 内存分为**线程私有区域**和**线程共享区域**：

表格







|       区域       |    归属    |                             作用                             |
| :--------------: | :--------: | :----------------------------------------------------------: |
|    程序计数器    |  线程私有  | 记录当前线程执行的字节码行号，用于线程切换后恢复执行位置，唯一不会 OOM 的区域 |
|     虚拟机栈     |  线程私有  | 存储方法的局部变量、操作数栈、方法出口等，栈帧对应一个方法的执行过程，易 OOM（StackOverflowError） |
|    本地方法栈    |  线程私有  |  为 Native 方法（如 JNI 调用）提供内存空间，与虚拟机栈类似   |
|        堆        |  线程共享  | JVM 最大的内存区域，存储对象实例和数组，GC 的主要区域，易 OOM（OutOfMemoryError） |
| 方法区（元空间） |  线程共享  | 存储类信息、常量、静态变量、JIT 编译后的代码等，JDK 8 替换为元空间（直接使用本地内存） |
|   运行时常量池   | 方法区子集 | 存储编译期生成的常量、字符串常量池等，运行时可动态添加（如 String.intern ()） |

#### （2）常见 GC（垃圾回收）类型

- **Minor GC（新生代 GC）**：仅回收新生代（Eden 区 + Survivor 区），触发频繁，回收速度快；当 Eden 区满时触发，将存活对象移到 Survivor 区。
- **Major GC（老年代 GC）**：回收老年代，触发频率低，回收速度慢；通常伴随 Minor GC（“Stop-the-World” 时间更长）。
- **Full GC**：回收新生代 + 老年代 + 元空间，触发条件：老年代满、元空间满、System.gc () 调用、Minor GC 后存活对象过多无法放入老年代；Full GC 会导致长时间 STW，应尽量避免。

### 11. JVM 中的垃圾回收器

JVM 的垃圾回收器分为**新生代回收器**、**老年代回收器**、**整堆回收器**，常见的有：

表格







|            回收器            | 适用区域 |                           核心特点                           |
| :--------------------------: | :------: | :----------------------------------------------------------: |
|            Serial            |  新生代  |   单线程回收，STW 时间长，适合单核、小内存应用（如客户端）   |
|            ParNew            |  新生代  |              Serial 的多线程版本，配合 CMS 使用              |
|      Parallel Scavenge       |  新生代  | 多线程回收，关注吞吐量（运行用户代码时间 / 总时间），适合后台计算型应用 |
|          Serial Old          |  老年代  |             Serial 的老年代版本，单线程，STW 长              |
|         Parallel Old         |  老年代  |      Parallel Scavenge 的老年代版本，多线程，关注吞吐量      |
| CMS（Concurrent Mark Sweep） |  老年代  | 并发回收，低延迟（STW 时间短），适合高响应要求的应用（如 Web），但会产生内存碎片 |
|     G1（Garbage-First）      |   整堆   | 分区回收，兼顾吞吐量和延迟，支持可预测的 STW 时间，JDK 9 默认回收器 |
|        ZGC/Shenandoah        |   整堆   | 低延迟（STW 毫秒级），支持大内存（TB 级），适合高并发、低延迟场景 |

### 12. G1 回收器的特色

G1（Garbage-First）是 JDK 7 引入的新一代回收器，核心特色如下：

#### （1）分区管理（Region）

- 将堆划分为多个大小相等的独立 Region（默认 1MB~32MB），新生代和老年代不再是物理隔离，而是分散在不同 Region 中；
- 每个 Region 可动态切换为 Eden、Survivor、Old、Humongous（存储大对象）类型。

#### （2）垃圾优先回收

- G1 会优先回收垃圾最多的 Region（“Garbage-First”），最大化回收效率；
- 通过维护 Region 的 “垃圾回收价值” 优先级队列，优先回收价值高的 Region。

#### （3）兼顾吞吐量和延迟

- 支持可预测的 STW 时间：用户可指定 “最大 STW 时间”（如`-XX:MaxGCPauseMillis=200`），G1 会根据目标时间调整回收策略；
- 并发标记阶段（大部分工作与用户线程并行），减少 STW 时间。

#### （4）避免内存碎片

- 采用 “复制算法” 回收 Region：将存活对象复制到空 Region，原 Region 清空，避免 CMS 的内存碎片问题；
- 对大对象（Humongous Region）单独处理，避免大对象频繁移动。

#### （5）混合回收

- 不区分新生代和老年代回收，一次 GC 可同时回收新生代和老年代的 Region，提升回收效率。

### 13. GC 只会对堆进行 GC 吗？

**不是**。GC 的回收范围不仅包括堆，还包括：

#### （1）方法区（元空间）

- JDK 8 之前的永久代（方法区实现）会触发 GC，回收废弃的类（满足：该类所有实例已被回收、类加载器已被回收、Class 对象无引用）；
- JDK 8 的元空间（使用本地内存）也会 GC，当元空间满时触发 Full GC，回收废弃的类信息。

#### （2）直接内存（堆外内存）

- DirectByteBuffer 使用的堆外内存不属于 JVM 堆，但会被 GC 间接管理：当 DirectByteBuffer 被回收时，其对应的堆外内存会被释放；
- 若堆外内存不足，会触发 Full GC，若仍不足则抛出 OOM。

#### （3）线程私有区域（几乎不 GC）

- 程序计数器、虚拟机栈、本地方法栈随线程创建 / 销毁而分配 / 释放，无需 GC；
- 虚拟机栈仅会抛出 StackOverflowError（栈深度超限）或 OOM（栈扩展失败），不会 GC。

**总结**：堆是 GC 的**主要区域**，但方法区、直接内存也会被 GC 涉及，只是触发条件更严格。

### 14. 解决线程并发问题的方案

线程并发问题的核心是**可见性、原子性、有序性**问题，解决方案从易到难分为以下几类：

#### （1）基础方案：同步机制

- **synchronized 关键字**：可修饰方法 / 代码块，保证原子性、可见性、有序性，JVM 层面的锁，自动释放。
- **Lock 接口（ReentrantLock）**：手动锁，比 synchronized 灵活（支持公平锁 / 非公平锁、可中断、超时获取锁），需手动释放（finally 中 unlock）。

#### （2）原子类：无锁方案

- 使用`java.util.concurrent.atomic`包下的原子类（如 AtomicInteger、AtomicReference），基于 CAS（Compare-And-Swap）实现原子操作，无锁且性能更高。

- 示例：

  java



运行









  ```
  AtomicInteger count = new AtomicInteger(0);
  // 原子自增，无需加锁
  count.incrementAndGet();
  ```



#### （3）并发容器：避免集合线程不安全

- 替换线程不安全的集合（如 ArrayList、HashMap）为并发容器：

    - `ConcurrentHashMap`：线程安全的 HashMap，分段锁 / CAS 实现，性能优于 Hashtable；
    - `CopyOnWriteArrayList`：读多写少场景的 ArrayList，写时复制，读无锁；
    - `BlockingQueue`：阻塞队列，用于生产者 - 消费者模型（如 ArrayBlockingQueue、LinkedBlockingQueue）。



#### （4）线程池：控制并发数

- 使用`java.util.concurrent.Executors`或手动创建`ThreadPoolExecutor`，控制线程数量，避免创建过多线程导致 OOM；

- 示例：

  java



运行









  ```
  ExecutorService executor = new ThreadPoolExecutor(
      5,  // 核心线程数
      10, // 最大线程数
      60, // 空闲线程存活时间
      TimeUnit.SECONDS,
      new ArrayBlockingQueue<>(100) // 任务队列
  );
  ```



#### （5）volatile 关键字：保证可见性和有序性

- 修饰变量，保证变量的修改对所有线程可见，禁止指令重排序，但**不保证原子性**；
- 适用于状态标记（如`volatile boolean stop = false`）。

#### （6）ThreadLocal：线程隔离

- 将变量绑定到当前线程，每个线程有独立的副本，避免多线程共享变量；
- 适用于存储线程上下文（如用户登录信息、数据库连接）。

#### （7）分布式场景：分布式锁

- 跨 JVM 的并发问题，需用分布式锁（Redis/ZooKeeper/ 数据库）保证一致性。

### 17. 悲观锁和乐观锁的区别

悲观锁和乐观锁是解决并发问题的两种核心思想，核心区别如下：

表格







|   维度   |                          悲观锁                          |                  乐观锁                  |
| :------: | :------------------------------------------------------: | :--------------------------------------: |
| 核心思想 |           假设一定会发生并发冲突，先加锁再操作           | 假设不会发生并发冲突，操作后检查是否冲突 |
| 实现方式 | 依赖锁机制（如 synchronized、ReentrantLock、数据库行锁） |     依赖 CAS 算法 / 版本号 / 时间戳      |
| 并发性能 |                高并发下锁竞争激烈，性能低                |       无锁竞争，性能高（冲突少时）       |
| 阻塞情况 |             会阻塞线程（未获取锁的线程等待）             |    不会阻塞线程（冲突时重试 / 放弃）     |
| 适用场景 |                 写多读少、冲突频繁的场景                 |         读多写少、冲突稀少的场景         |
| 异常问题 |                       可能导致死锁                       |            可能导致 ABA 问题             |

### 18. 悲观锁和乐观锁使用场景的差别

#### （1）悲观锁适用场景

- **写操作频繁**：如库存扣减、转账、订单状态修改（冲突概率高，加锁能避免频繁重试）；
- **数据一致性要求极高**：如金融交易，不允许数据不一致，必须保证操作的原子性；
- **低并发场景**：并发量低时，锁竞争少，悲观锁的性能损耗可忽略。

#### （2）乐观锁适用场景

- **读操作频繁**：如商品详情查询、用户信息查询（冲突概率低，无锁能提升读性能）；
- **高并发、低冲突场景**：如电商商品浏览、点赞 / 收藏（大部分操作是读，少量写，重试成本低）；
- **分布式场景**：分布式锁的性能损耗高，乐观锁（如数据库版本号）更适合。

### 19. Java 中实现乐观锁的方式

Java 中实现乐观锁的核心是**检测操作前后数据是否被修改**，常见方式如下：

#### （1）CAS 算法（最常用）

- 原理

  ：Compare-And-Swap，比较并交换，核心步骤：

    1. 获取当前值（V）；
    2. 计算新值（N）；
    3. 若当前值仍为 V，则更新为 N；否则重试。



- **实现**：JDK 的`Atomic`类（AtomicInteger、AtomicReference）、Unsafe 类的 CAS 方法。

- 示例

  ：

  java



运行









  ```
  AtomicReference<User> userRef = new AtomicReference<>(new User("张三", 20));
  User oldUser = userRef.get();
  User newUser = new User("张三", 21);
  // CAS更新，只有当前值为oldUser时才更新
  boolean success = userRef.compareAndSet(oldUser, newUser);
  ```



#### （2）版本号机制

- **原理**：为数据添加版本号字段，更新时检查版本号是否一致，一致则更新并递增版本号。

- **实现**：数据库层面（如 MySQL 的版本号字段）、Java 代码层面。

- 示例（数据库）

  ：

  sql











  ```
  -- 表结构：id, name, version
  UPDATE user SET name = '李四', version = version + 1 
  WHERE id = 1 AND version = 1;
  ```



#### （3）时间戳机制

- **原理**：为数据添加时间戳字段，更新时检查时间戳是否与操作前一致，一致则更新。
- **缺点**：时间戳精度问题（如系统时间同步）、可见性问题（下文详述）。

#### （4）Redisson 的乐观锁（分布式）

- **原理**：基于 Redis 的 Hash 结构存储版本号，通过 Lua 脚本实现 CAS 操作。

- 示例

  ：

  java



运行









  ```
  RLock lock = redissonClient.getLock("myLock");
  // 尝试加乐观锁，等待10秒，锁过期10秒
  boolean success = lock.tryLock(10, 10, TimeUnit.SECONDS);
  if (success) {
      try {
          // 业务操作
      } finally {
          lock.unlock();
      }
  }
  ```



### 20. 使用时间戳会不会有可见性问题？

**会有可见性问题**。

#### 原因：

- 时间戳字段若未被`volatile`修饰，线程 A 修改了时间戳后，线程 B 可能无法立即看到最新值（CPU 缓存未刷新）；
- 即使线程 B 读取到了时间戳，也可能因为指令重排序，导致 “读取时间戳” 和 “更新数据” 之间的操作被打乱，出现数据不一致。

#### 示例：

java



运行









```
// 无volatile修饰，存在可见性问题
private long timestamp; 

public boolean updateData(String newData) {
    long oldTs = this.timestamp; // 线程B可能读取到旧的timestamp
    // 业务操作
    if (this.timestamp == oldTs) { // 即使这里相等，也可能是旧值
        this.timestamp = System.currentTimeMillis();
        this.data = newData;
        return true;
    }
    return false;
}
```

### 21. volatile 能解决吗，就够了吗？

#### （1）volatile 能解决什么？

- ```
  volatile
  ```

  修饰时间戳字段后，能保证：

    1. **可见性**：线程修改时间戳后，其他线程能立即看到最新值；
    2. **有序性**：禁止指令重排序，避免 “读取时间戳” 和 “更新数据” 的操作被打乱。



#### （2）volatile 不够的原因：

- `volatile`**不保证原子性**：若多个线程同时读取时间戳并更新，可能出现 “ABA 问题” 或更新覆盖；

- 示例：

  java



运行









  ```
  private volatile long timestamp;
  
  public boolean updateData(String newData) {
      long oldTs = this.timestamp; 
      // 线程A和B同时读取到oldTs，执行业务操作后，都认为timestamp未变，最终只有一个更新生效，另一个被覆盖
      if (this.timestamp == oldTs) { 
          this.timestamp = System.currentTimeMillis();
          this.data = newData;
          return true;
      }
      return false;
  }
  ```



#### （3）完整解决方案：

- `volatile + CAS`：既保证可见性 / 有序性，又保证原子性；

- 示例：

  java



运行









  ```
  private AtomicLong timestamp = new AtomicLong(System.currentTimeMillis());
  
  public boolean updateData(String newData) {
      long oldTs = timestamp.get();
      // CAS更新，保证原子性
      boolean success = timestamp.compareAndSet(oldTs, System.currentTimeMillis());
      if (success) {
          this.data = newData;
          return true;
      }
      return false;
  }
  ```



### 22. 除了加锁还有没有别的解法，绕开加锁使性能更好？

有，绕开加锁的核心是**避免共享状态**或**使用无锁算法**，常见方案如下：

#### （1）无锁算法：CAS

- 如 Atomic 类、Unsafe 类的 CAS 方法，无锁竞争，性能远高于加锁；
- 适用于简单的原子操作（如计数、状态更新）。

#### （2）线程本地存储：ThreadLocal

- 将共享变量改为线程私有变量，每个线程有独立副本，无需加锁；

- 示例：

  java



运行









  ```
  private static ThreadLocal<SimpleDateFormat> sdf = ThreadLocal.withInitial(() -> new SimpleDateFormat("yyyy-MM-dd"));
  
  public String formatDate(Date date) {
      // 每个线程使用自己的SimpleDateFormat，无并发问题
      return sdf.get().format(date);
  }
  ```



#### （3）不可变对象

- 使用不可变对象（如 String、Integer、枚举），对象创建后不可修改，天然线程安全；
- 自定义不可变对象：所有字段用`final`修饰，无 setter 方法，构造方法初始化所有字段。

#### （4）分段锁 / 分离锁

- 将共享数据拆分为多个段，每个段独立加锁，减少锁竞争（如 ConcurrentHashMap 的分段锁）；
- 示例：将一个全局计数器拆分为 10 个分段计数器，每个线程只竞争其中一个分段的锁。

#### （5）写时复制（Copy-On-Write）

- 读操作无锁，写操作时复制一份新数据，修改后替换原数据，适用于读多写少场景（如 CopyOnWriteArrayList、CopyOnWriteArraySet）。

#### （6）生产者 - 消费者模型

- 使用阻塞队列（如 ArrayBlockingQueue）解耦生产者和消费者，避免直接共享数据；
- 生产者只往队列放数据，消费者只从队列取数据，队列本身保证线程安全。

### 23. ThreadLocal 使用的时候需要注意哪些点

ThreadLocal 是线程私有存储工具，但使用不当易引发内存泄漏、数据混乱等问题，核心注意点如下：

#### （1）必须手动移除（避免内存泄漏）

- **原因**：ThreadLocal 的底层是 ThreadLocalMap，Key 是弱引用（ThreadLocal 实例），Value 是强引用（存储的对象）。若 ThreadLocal 实例被回收，Key 变为 null，Value 无法被 GC，导致内存泄漏。

- 解决方案

  ：使用完 ThreadLocal 后，调用

  ```
  remove()
  ```

  方法移除 Value：

  java



运行









  ```
  ThreadLocal<User> userThreadLocal = new ThreadLocal<>();
  try {
      userThreadLocal.set(new User("张三"));
      // 业务操作
  } finally {
      userThreadLocal.remove(); // 必须手动移除
  }
  ```



#### （2）避免使用 static ThreadLocal（按需使用）

- static ThreadLocal 的生命周期与类一致，若线程是线程池中的核心线程（长期存活），易导致 Value 长期无法释放；
- 若必须使用 static，务必在使用后 remove。

#### （3）线程池场景注意数据污染

- 线程池中的线程会复用，若前一个线程未移除 ThreadLocal 的 Value，后一个线程会读取到旧数据；
- 解决方案：在任务执行完后，手动 remove ThreadLocal。

#### （4）避免存储大对象

- ThreadLocal 存储的对象随线程存活，若存储大对象（如大集合、大字节数组），易导致内存占用过高。

#### （5）不可传递性

- ThreadLocal 的 Value 仅在当前线程有效，子线程无法获取父线程的 ThreadLocal 值；
- 若需传递，可使用`InheritableThreadLocal`（子线程继承父线程的 ThreadLocal 值），但注意线程池场景下的复用问题。

### 24. 线程并发还有别的问题吗？

除了可见性、原子性、有序性三大核心问题，线程并发还会引发以下问题：

#### （1）死锁

- **原因**：多个线程互相持有对方需要的锁，且不释放，导致永久阻塞；
- **示例**：线程 A 持有锁 1，等待锁 2；线程 B 持有锁 2，等待锁 1；
- **避免**：按固定顺序加锁、设置锁超时、使用可中断锁（ReentrantLock 的 lockInterruptibly）。

#### （2）活锁

- **原因**：线程不断重试某个操作，但始终失败（如 CAS 重试、分布式锁重试），线程未阻塞但无法执行；
- **避免**：重试时添加随机延迟，避免多个线程同时重试。

#### （3）饥饿

- **原因**：某个线程长期无法获取锁（如公平锁中，高优先级线程一直抢占锁，低优先级线程饥饿）；
- **避免**：使用公平锁、控制线程优先级、限制单个线程持有锁的时间。

#### （4）内存泄漏

- **原因**：线程池中的线程长期存活，ThreadLocal 未移除 Value、未关闭资源（如连接、流）导致内存泄漏；
- **避免**：手动释放资源、使用完 ThreadLocal 后 remove。

#### （5）上下文切换开销

- **原因**：多线程切换时，CPU 需要保存 / 恢复线程的上下文（程序计数器、寄存器等），频繁切换会增加开销；
- **优化**：减少线程数量、使用协程（如 Project Loom）、避免细粒度锁。

#### （6）ABA 问题

- **原因**：乐观锁（CAS）中，数据从 A 变为 B，再变回 A，CAS 认为数据未修改，导致错误更新；
- **避免**：使用版本号（AtomicStampedReference）替代单纯的 CAS。

### 25. 常用的线程池有哪些呢？

Java 中常用的线程池均基于`ThreadPoolExecutor`实现，`Executors`工具类提供了以下常用线程池：

#### （1）FixedThreadPool（固定线程数线程池）

- **创建**：`Executors.newFixedThreadPool(int nThreads)`；
- **核心参数**：核心线程数 = 最大线程数 = nThreads，队列是无界的 LinkedBlockingQueue；
- **特点**：线程数固定，空闲线程不会被回收，任务队列无界；
- **适用**：任务量固定、耗时较长的场景（如 IO 密集型任务）；
- **风险**：任务队列无界，任务过多会导致 OOM。

#### （2）CachedThreadPool（缓存线程池）

- **创建**：`Executors.newCachedThreadPool()`；
- **核心参数**：核心线程数 = 0，最大线程数 = Integer.MAX_VALUE，队列是同步队列（SynchronousQueue），空闲线程存活时间 60 秒；
- **特点**：线程数随任务量动态增减，无任务时线程全部回收；
- **适用**：短期、轻量级任务（如快速处理大量临时任务）；
- **风险**：最大线程数过大，任务过多会创建大量线程，导致 OOM。

#### （3）SingleThreadExecutor（单线程线程池）

- **创建**：`Executors.newSingleThreadExecutor()`；
- **核心参数**：核心线程数 = 最大线程数 = 1，队列是无界的 LinkedBlockingQueue；
- **特点**：只有一个线程执行任务，任务按顺序执行；
- **适用**：需要保证任务顺序执行的场景（如日志写入）；
- **风险**：队列无界，任务过多导致 OOM。

#### （4）ScheduledThreadPool（定时任务线程池）

- **创建**：`Executors.newScheduledThreadPool(int corePoolSize)`；
- **核心参数**：核心线程数 = corePoolSize，最大线程数 = Integer.MAX_VALUE，队列是 DelayedWorkQueue；
- **特点**：支持定时执行、周期性执行任务；
- **适用**：定时任务（如心跳检测、数据同步）；
- **方法**：`schedule()`（延迟执行）、`scheduleAtFixedRate()`（固定频率执行）、`scheduleWithFixedDelay()`（固定延迟执行）。

#### （5）WorkStealingPool（工作窃取线程池）

- **创建**：`Executors.newWorkStealingPool()`（JDK 8+）；
- **核心参数**：默认线程数 = CPU 核心数，基于 Fork/Join 框架实现；
- **特点**：每个线程有独立的任务队列，空闲线程会 “窃取” 其他线程的任务，提高并行效率；
- **适用**：CPU 密集型、任务可拆分的场景（如大数据计算）。

#### （6）手动创建 ThreadPoolExecutor（推荐）

- 避免使用

  ```
  Executors
  ```

  的默认实现（易 OOM），手动创建更可控：

  java



运行









  ```
  ExecutorService executor = new ThreadPoolExecutor(
      2, // 核心线程数
      5, // 最大线程数
      60, // 空闲线程存活时间
      TimeUnit.SECONDS,
      new ArrayBlockingQueue<>(100), // 有界队列，避免OOM
      new ThreadPoolExecutor.CallerRunsPolicy() // 拒绝策略：主线程执行
  );
  ```



------

### 总结

#### 核心知识点回顾

1. **Spring Boot**：核心是 “约定大于配置”，通过自动配置、起步依赖、默认目录结构简化开发，底层封装 Spring 框架。
2. **AOP 实现**：静态织入（AspectJ）、动态代理（JDK Proxy/CGLib/ByteBuddy），核心是解耦通用逻辑。
3. **JVM**：堆是 GC 核心区域，G1 回收器兼顾吞吐量和延迟，GC 还涉及方法区、直接内存。
4. **并发编程**：乐观锁（CAS / 版本号）适用于读多写少，悲观锁适用于写多读少；ThreadLocal 需手动 remove 避免内存泄漏；线程池推荐手动创建（可控）。
5. **分布式调度**：高可用核心是集群化（调度中心 + 执行节点）、分布式锁、故障转移。
6. **Maven 版本冲突**：多版本共存需通过 Shade 插件重打包或自定义类加载器隔离。