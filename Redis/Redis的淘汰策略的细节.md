### 4. Redis 的淘汰策略有哪些？

当 Redis 内存使用达到 `maxmemory` 配置的上限时，就会触发内存淘汰策略，选择一些键值对删除以释放空间。

Redis 共提供了 **8 种** 淘汰策略，分为三大类：

#### 1. 不淘汰数据（2 种）

- `noeviction`（默认策略）不淘汰任何数据，内存不足时拒绝所有写入操作（`SET`、`HSET` 等），并返回 `OOM command not allowed when used memory > 'maxmemory'` 错误。适用于对数据完整性要求极高、不允许丢失数据的场景（如金融交易记录）。
- `volatile-ttl`仅淘汰 ** 设置了过期时间（TTL）** 的键，优先淘汰 TTL 最短的键（即将过期的数据）。适用于需要保留永久数据，同时对临时数据进行自动清理的场景（如缓存会话信息）。

#### 2. 淘汰设置了过期时间的键（3 种）

- `volatile-lru`（Least Recently Used，最近最少使用）仅淘汰**设置了过期时间**的键，优先淘汰最近最少被访问的键。核心思想：“如果一个数据最近很少被访问，那么未来被访问的概率也很低”。适用于缓存场景（如商品详情页缓存），优先保留热点数据。
- `volatile-lfu`（Least Frequently Used，最不经常使用）仅淘汰**设置了过期时间**的键，优先淘汰最近访问频率最低的键（通过计数器记录访问次数）。核心思想：“如果一个数据最近被访问的次数很少，那么未来被访问的概率也很低”。相比 LRU，LFU 更能过滤掉偶尔被访问的 “冷数据”，适用于访问模式相对稳定的场景（如用户行为统计）。
- `volatile-random`仅淘汰**设置了过期时间**的键，随机选择键进行淘汰。实现简单，但可能淘汰掉热点数据，适用于对淘汰精度要求不高的场景。

#### 3. 淘汰所有键（3 种）

- `allkeys-lru`淘汰**所有键**（无论是否设置过期时间），优先淘汰最近最少被访问的键。适用于缓存场景（如首页热点数据缓存），允许淘汰永久数据以保证系统可用性。
- `allkeys-lfu`淘汰**所有键**，优先淘汰最近访问频率最低的键。适用于需要优化整体缓存命中率的场景，兼顾热点数据和访问频率。
- `allkeys-random`淘汰**所有键**，随机选择键进行淘汰。适用于对数据淘汰无特殊要求、仅需快速释放内存的场景（如临时存储大量日志数据）。

### 5. Redis 怎么实现淘汰策略的？（懒加载 + 定期删除 + 数据结构）

Redis 的淘汰策略并非单一机制，而是通过 **“懒加载（惰性删除）” + “定期删除” + “数据结构辅助”** 的组合方式实现的，核心是在 “内存占用” 和 “CPU 消耗” 之间寻找平衡。

#### 1. 懒加载（惰性删除）：避免浪费 CPU，只在必要时删除

- **核心思想**：不主动扫描过期键，而是在**访问某个键时**，才检查该键是否过期。如果过期，则删除该键并返回 `nil`；如果未过期，则正常返回键值。

- 实现逻辑 ：

    - 当执行 `GET`、`HGET` 等读操作时，Redis 会先检查键的 `expire` 字典（存储过期时间）。
    - 如果键存在过期时间且已过期，Redis 会立即删除该键，并释放对应的内存。
    - 如果键未过期或未设置过期时间，则正常返回数据。

- 优点 ：

    - 无需额外的扫描线程，CPU 消耗极低。
    - 只删除 “真正被访问的过期键”，避免删除未被访问的 “冷数据”（可能后续还会被访问）。

- 缺点 ：

    - 过期键如果长期不被访问，会一直占用内存，导致内存泄漏（直到触发内存淘汰）。

#### 2. 定期删除：主动清理过期键，缓解内存压力

- **核心思想**：每隔一段时间，Redis 会主动扫描部分过期键并删除，避免过期键长期占用内存。

- 实现逻辑 ：

    - Redis 内部维护一个 **“过期键字典”（expire dict）**，存储所有设置了过期时间的键及其过期时间戳。

    - 每隔```hz```（默认 10，可配置）秒，Redis 会执行一次定期删除任务：

    1. 从过期键字典中随机选择 `sample` 个键（默认 5 个）。
    2. 检查这些键是否过期，删除所有过期的键。
    3. 如果删除的键数超过 `sample * 25%`（即 5 个键中删除了 2 个以上），则继续重复步骤 1-2；否则，本次定期删除任务结束。

- 优点 ：

    - 主动清理部分过期键，缓解内存泄漏问题。
    - 扫描频率和扫描数量可配置，避免对 CPU 造成过大压力。

- 缺点 ：

    - 可能存在 “漏删”（部分过期键未被扫描到），仍需依赖懒加载补充。

#### 3. 数据结构辅助：实现 LRU/LFU 淘汰策略

Redis 的 LRU/LFU 淘汰策略并非通过传统的 “双向链表” 实现（会占用过多内存），而是通过 **“近似 LRU/LFU 算法” + “数据结构标记”** 实现，兼顾性能和内存占用。

##### （1）近似 LRU 算法（volatile-lru /allkeys-lru）

- **核心思想**：不记录所有键的访问顺序，而是通过 **“最近访问时间戳（lru field）”** 标记键的访问情况，淘汰时随机采样部分键，选择时间戳最早的键删除。

- 实现逻辑 ：

    - 每个 Redis 对象（`redisObject`）中包含一个 `lru` 字段（24 位），存储该键的 “最近访问时间戳”（实际存储的是 Redis 内部的时钟周期 `server.lruclock`）。
    - 当访问一个键时，Redis 会更新该键的 `lru` 字段为当前的 `server.lruclock`。
    - 触发 LRU 淘汰时，Redis 会：
        1. 从 “待淘汰键集合”（如所有键或仅过期键）中随机选择 `maxmemory-samples` 个键（默认 5 个，可配置）。
        2. 比较这些键的 `lru` 字段，选择 `lru` 值最小（访问时间最早）的键删除。
        3. 重复步骤 1-2，直到内存占用低于 `maxmemory` 阈值。

- 优点 ：

    - 无需维护复杂的链表结构，内存占用低。
    - 采样数量可配置（`maxmemory-samples` 越大，淘汰精度越高，但 CPU 消耗也越高）。

- 缺点 ：

    - 是 “近似 LRU”，可能淘汰掉部分 “次热点数据”，但实际效果接近理想 LRU。

##### （2）近似 LFU 算法（volatile-lfu /allkeys-lfu）

- **核心思想**：通过 **“访问频率计数器（lfu field）”** 标记键的访问次数，淘汰时随机采样部分键，选择计数器值最小的键删除。

- 实现逻辑 ：

    - Redis 4.0+ 版本中，```redisObject```的```lru```字段被复用为```lfu```字段（24 位），分为两部分：

    - 高 16 位：`lfu_age`，存储 “最近一次访问的时间戳”（单位：分钟）。
    - 低 8 位：`lfu_cnt`，存储 “访问频率计数器”（最大值 255，采用对数衰减机制）。

- 当访问一个键时：

    1. 如果距离上次访问时间超过 `lfu_decay_time`（默认 1 分钟，可配置），则 `lfu_cnt` 会衰减（衰减公式：`lfu_cnt = lfu_cnt * e^(-Δt / lfu_decay_time)`）。
    2. `lfu_cnt` 增加 1（但不超过 255）。
    3. 更新 `lfu_age` 为当前时间戳。

- 触发 LFU 淘汰时，Redis 会：

    1. 从 “待淘汰键集合” 中随机选择 `maxmemory-samples` 个键。
    2. 比较这些键的 `lfu_cnt` 字段，选择 `lfu_cnt` 值最小（访问频率最低）的键删除。
    3. 重复步骤 1-2，直到内存占用低于 `maxmemory` 阈值。

- 优点 ：

    - 相比 LRU，更能准确识别 “冷数据”（如偶尔访问一次的键），淘汰精度更高。
    - 支持频率衰减，避免 “一次性热点数据” 长期占用内存。

- 缺点 ：

    - 实现比 LRU 复杂，CPU 消耗略高。
    - 同样是 “近似 LFU”，采样数量会影响淘汰精度。

#### 4. 淘汰策略的触发流程

当 Redis 执行写入操作（如 `SET`、`HSET`）时，会先检查内存是否超过 `maxmemory` 阈值：

1. 如果未超过阈值，正常执行写入操作。
2. 如果超过阈值，根据配置的淘汰策略（如 `allkeys-lru`），通过 “定期删除” 或 “懒加载” 的方式删除部分键。
3. 重复步骤 2，直到内存占用低于 `maxmemory` 阈值，或淘汰策略为 `noeviction` 时返回 OOM 错误。

### 总结

1. Redis 淘汰策略分为 “不淘汰”“仅淘汰过期键”“淘汰所有键” 三大类，共 8 种，核心是根据业务场景选择 “保留热点数据” 或 “保证数据完整性”。
2. 淘汰机制的底层是 **“懒加载（访问时删除过期键）+ 定期删除（主动扫描部分过期键）”** 的组合，避免 CPU 和内存的浪费。
3. LRU/LFU 淘汰策略通过 “近似算法 + 数据结构标记” 实现：
    - LRU 依赖 `lru` 字段记录访问时间戳，随机采样淘汰最近最少访问的键。
    - LFU 依赖 `lfu` 字段（访问频率计数器 + 时间衰减），随机采样淘汰最不经常访问的键。