## [26秋招阿里后端一面面经](https://www.nowcoder.com/feed/main/detail/ed1e139fb39040468b9d6c6c3f085745)




### 1. 项目中设计过哪些表，设计思路是什么？

这是考察数据库设计能力的核心问题，应答要体现**业务驱动、规范设计、性能考量**，核心思路如下：

#### 应答框架（以电商订单系统为例）

plaintext











```
1. 核心表举例：
   - user（用户表）：存储用户基础信息（id、username、phone、password、create_time）；
   - product（商品表）：存储商品信息（id、name、price、stock、category_id、create_time）；
   - order_main（订单主表）：存储订单核心信息（id、user_id、total_amount、status、create_time）；
   - order_item（订单项表）：存储订单明细（id、order_id、product_id、quantity、price）。

2. 设计思路：
   - ① 贴合业务：按“用户-商品-订单”的业务链路拆分表，避免单表存储所有信息（如订单主从表分离，主表存核心，从表存明细）；
   - ② 遵循范式：基础表（user/product）满足第三范式（消除冗余），订单表适度反范式（如订单主表存total_amount，避免关联计算）；
   - ③ 性能优化：
     - 主键用自增ID（B+树索引效率高）；
     - 订单表按user_id、create_time建立联合索引（高频查询“用户近3个月订单”）；
     - 大字段（如商品描述）拆分到单独表，避免查询时加载冗余数据；
   - ④ 扩展性：预留字段（如ext_info）或分表策略（订单表按时间分表，应对海量数据）；
   - ⑤ 规范：字段命名统一（如create_time）、必写字段非空（如user_id）、时间用datetime类型。
```

#### 关键要点

- 不要只罗列表名，重点讲 “为什么这么拆”“怎么优化”；
- 结合业务场景（如订单表分主从是为了避免查询明细时锁主表）；
- 提到索引、范式、分表等设计细节，体现思考深度。

### 2. 了解过 MySQL 索引吗？

应答要从**定义、分类、原理、使用原则**四个维度展开，核心如下：

plaintext











```
1. 索引定义：MySQL索引是帮助数据库高效查询的数据结构（默认B+树），本质是“排好序的快速查找数据结构”，避免全表扫描。

2. 核心分类：
   - 按数据结构：B+树索引（主流）、哈希索引、全文索引、空间索引；
   - 按物理存储：聚簇索引（主键索引，索引和数据存一起）、非聚簇索引（普通索引，叶子节点存主键值）；
   - 按功能：主键索引（唯一非空）、唯一索引（值唯一）、普通索引、联合索引（多字段，遵循最左前缀）、前缀索引（字符串前n位）。

3. 使用原则：
   - 联合索引遵循“最左前缀”，如(index a,b,c) 支持a、a+b、a+b+c查询；
   - 避免在索引字段做函数/运算（如where date(create_time) = '2024-01-01' 会失效）；
   - like查询%放开头索引失效（如%abc），放结尾生效（如abc%）；
   - 小表无需建索引，更新频繁的表减少索引（索引会降低写入性能）。
```

### 3. 讲一下 B + 树？

B + 树是 MySQL 索引的底层数据结构，应答要突出**结构特点、适配 MySQL 的原因**：

#### 核心讲解

plaintext











```
1. 结构特点：
   - B+树是多路平衡查找树（m阶B+树每个节点最多m个子节点）；
   - 分层存储：非叶子节点只存索引（键值），不存数据；叶子节点存全量数据（或主键值），且所有叶子节点通过双向链表连接；
   - 有序性：所有节点的索引按升序排列，叶子节点链表也是有序的。

2. 为什么MySQL选B+树？
   - 磁盘IO高效：非叶子节点仅存索引，单次IO能加载更多索引（减少磁盘访问次数）；
   - 范围查询快：叶子节点链表连接，遍历范围数据只需遍历链表，无需回表；
   - 查询稳定：所有查询最终都到叶子节点，响应时间一致（B树查询时间取决于数据位置，不稳定）；
   - 适配磁盘特性：磁盘是块存储，B+树的节点大小适配磁盘块（如4KB），提升读取效率。

3. 举例：
   主键索引的B+树，非叶子节点存主键值和子节点指针，叶子节点存整行数据；普通索引的B+树，叶子节点存主键值，需要回表（通过主键查聚簇索引）获取全量数据。
```

### 4. MySQL 中的数据类型底层怎么存的？

面试官关注的是**基础类型的存储格式**，核心讲解常用类型：

#### 核心类型存储方式

表格







| 数据类型 |                         底层存储方式                         |
| :------: | :----------------------------------------------------------: |
|   INT    | 固定 4 字节（32 位），无符号范围 0~2^32-1，有符号范围 - 2^31~2^31-1；小整数（如 TINYINT）占 1 字节，SMALLINT 占 2 字节，BIGINT 占 8 字节；存储时按二进制补码存储。 |
|   TIME   | 占 3 字节，存储格式为`HH:MM:SS`，底层用整数存储：- 第 1 字节：小时（0~23）；- 第 2 字节：分钟（0~59）；- 第 3 字节：秒（0~59）；支持负数（如 - 1:00:00），用于表示时间间隔。 |
| DATETIME | 占 8 字节，分为日期部分（4 字节，存储从 1970-01-01 到当前的天数）和时间部分（4 字节，存储秒数）；无时区问题，直接存储绝对时间。 |
| VARCHAR  | 变长字符串，存储分两部分：- 长度前缀：1~2 字节（根据字段长度定义，如 VARCHAR (255) 占 1 字节，VARCHAR (65535) 占 2 字节），存储实际字符长度；- 实际字符：按字符集（如 UTF8）编码存储（UTF8 每个字符占 1~3 字节）。 |
|   CHAR   | 定长字符串，不足长度补空格，存储时直接按字符集编码存储，无长度前缀（如 CHAR (10)，无论存多少字符都占 10× 字符编码长度）。 |
| DECIMAL  | 高精度小数，按字符串存储（避免浮点精度丢失），分为整数部分和小数部分，用字节存储每一位数字（如 DECIMAL (10,2)，存储 10 位数字，其中 2 位小数）。 |

#### 面试应答示例

“以 INT 为例，它固定占用 4 个字节，用二进制补码形式存储，有符号的 INT 范围是 - 2 的 31 次方到 2 的 31 次方减 1；TIME 类型占 3 个字节，分别存储小时、分钟、秒的整数值；VARCHAR 是变长存储，先存 1-2 字节的长度前缀，再存实际的字符编码，而 CHAR 是定长存储，不足补空格，没有长度前缀。”

### 5. MySQL 基础架构

补充你没答全的部分，完整架构分为**连接层、服务层、存储引擎层**：

plaintext











```
1. 连接层（客户端交互）：
   - 连接器：负责客户端连接（认证、权限校验），连接后会维护连接池（长连接/短连接）；
   - 线程池：为每个连接分配线程，避免频繁创建销毁线程。

2. 服务层（核心逻辑）：
   - 查询缓存（MySQL8.0已移除）：缓存查询语句和结果，命中则直接返回；
   - 分析器：词法分析（拆分SQL为关键词，如SELECT、FROM）→ 语法分析（校验SQL语法是否正确）；
   - 优化器：选择最优执行计划（如选择哪个索引、表连接顺序）；
   - 执行器：调用存储引擎接口执行SQL，返回结果。

3. 存储引擎层（数据存储）：
   - 插件式架构，常用InnoDB（默认）、MyISAM；
   - 负责数据的存储、读取、索引维护、事务管理等；
   - 数据文件：InnoDB的表空间文件（.ibd）、MyISAM的.MYD（数据）和.MYI（索引）。
```

### 6. MySQL 的事务隔离级别有哪些？

补充**问题解决 + 默认级别**，完整应答：

plaintext











```
1. 事务隔离级别是为了解决并发事务的3个问题：脏读、不可重复读、幻读；MySQL有4个隔离级别（从低到高）：
   - 读未提交（READ UNCOMMITTED）：能读取其他事务未提交的数据，会出现脏读、不可重复读、幻读；
   - 读已提交（READ COMMITTED）：只能读取其他事务已提交的数据，解决脏读，但仍有不可重复读、幻读；
   - 可重复读（REPEATABLE READ）：MySQL默认级别，同一事务内多次读取同一数据结果一致，解决脏读、不可重复读，通过MVCC+间隙锁基本解决幻读；
   - 串行化（SERIALIZABLE）：最高级别，事务串行执行，加表锁，彻底解决所有问题，但性能极差。

2. 核心实现：
   - 读已提交/可重复读：基于MVCC（多版本并发控制），为每行数据生成版本号，事务读取对应版本的数据；
   - 串行化：基于表锁，事务执行时锁定整张表，其他事务等待。
```

### 7. MVCC 是什么，原理是什么？（你写的 mycc 是笔误，应为 MVCC）

MVCC 是 MySQL 解决并发读写的核心机制，应答如下：

plaintext











```
1. 定义：MVCC（Multi-Version Concurrency Control，多版本并发控制）是一种并发控制方法，为每行数据维护多个版本，不同事务可以看到不同版本的数据，实现“读不加锁，读写不冲突”。

2. 核心原理（InnoDB）：
   - 隐藏字段：InnoDB为每行数据添加3个隐藏字段：
     - db_trx_id：最后修改该行的事务ID；
     - db_roll_ptr：回滚指针，指向undo log中的旧版本数据；
     - db_row_id：行ID（无主键时自动生成）；
   - Undo Log：事务修改数据时，先将旧版本数据写入undo log，用于回滚或MVCC读取；
   - Read View：事务开启时生成的“可见性视图”，包含4个核心值：
     - m_ids：当前活跃的事务ID列表；
     - min_trx_id：最小活跃事务ID；
     - max_trx_id：下一个要分配的事务ID；
     - creator_trx_id：当前事务ID；
   - 可见性规则：行的db_trx_id < min_trx_id → 可见；db_trx_id > max_trx_id → 不可见；在m_ids中 → 不可见；否则 → 可见。

3. 作用：
   实现可重复读隔离级别，让事务在整个生命周期内看到一致的数据版本，同时避免加锁导致的性能问题。
```

### 8. 悲观锁和乐观锁讲一下

核心讲**定义、实现、适用场景**，对比清晰：

plaintext











```
1. 悲观锁：
   - 定义：认为并发一定会发生冲突，操作前先加锁，阻止其他事务修改；
   - 实现：
     - MySQL中：SELECT ... FOR UPDATE（行锁）、表锁；
     - Java中：Synchronized、Lock；
   - 适用场景：写多读少（如库存扣减、转账），冲突概率高；
   - 缺点：加锁会导致阻塞，性能开销大。

2. 乐观锁：
   - 定义：认为并发冲突概率低，操作时不加锁，提交时检查数据是否被修改；
   - 实现：
     - MySQL中：版本号法（字段version，更新时WHERE version = 旧版本）、时间戳法；
     - Java中：CAS（Compare And Swap）；
   - 示例SQL：
     UPDATE product SET stock = stock - 1, version = version + 1 WHERE id = 1 AND version = 5;
   - 适用场景：读多写少（如商品详情查询、用户信息修改），冲突概率低；
   - 缺点：ABA问题（需加版本号解决）、高并发下重试次数多。

3. 核心区别：
   悲观锁是“先锁后操作”，乐观锁是“先操作后校验”；悲观锁阻塞，乐观锁非阻塞。
```

### 9. 数据库范式有哪些？

数据库范式（NF）是为了消除数据冗余、保证数据一致性，核心讲 1-3 范式（常用）：

plaintext











```
1. 第一范式（1NF）：
   - 定义：列不可再分，每个字段只能存单一值（原子性）；
   - 反例：user表的address字段存“北京市朝阳区XX街道”，可拆分为province、city、district，拆分后满足1NF。

2. 第二范式（2NF）：
   - 定义：满足1NF + 非主键字段完全依赖于主键（消除部分依赖）；
   - 反例：order_item表（主键order_id+product_id），字段order_name（订单名称）只依赖order_id，不依赖product_id，违反2NF；需将order_name拆分到order_main表。

3. 第三范式（3NF）：
   - 定义：满足2NF + 非主键字段不传递依赖于主键（消除传递依赖）；
   - 反例：user表（主键id），字段city_id、city_name，city_name依赖city_id，city_id依赖id，属于传递依赖；需将city_name拆分到city表，user表只存city_id。

4. 补充：
   - 巴斯-科德范式（BCNF）：3NF的增强版，消除主键之间的依赖；
   - 4NF/5NF：解决多值依赖、连接依赖，实际开发中极少用到，一般业务表满足3NF即可，适度反范式（如订单表存total_amount）提升性能。
```

### 10. HTTP 协议和 TCP 协议的区别是什么？

核心从**协议类型、作用、特性**对比：

plaintext











```
1. 协议类型：
   - TCP：传输层协议（面向连接、可靠的字节流协议）；
   - HTTP：应用层协议（基于TCP的应用层协议，无状态、无连接）。

2. 核心作用：
   - TCP：负责两台主机之间的数据传输，保证数据可靠、有序、不丢失（三次握手建立连接，四次挥手断开）；
   - HTTP：定义客户端和服务器之间的请求/响应格式（如GET/POST、请求头/响应头），用于Web数据交互。

3. 关键特性：
   - 连接性：TCP是面向连接的（必须先建连接再传输）；HTTP1.0无连接（每次请求建一次TCP连接），HTTP1.1支持长连接（一个TCP连接处理多个HTTP请求）；
   - 可靠性：TCP保证可靠传输（重传、校验和、序号）；HTTP不保证（依赖TCP的可靠性）；
   - 状态性：TCP有状态（维护连接状态）；HTTP无状态（每次请求独立，需Cookie/Session维持状态）；
   - 数据格式：TCP是字节流（无固定格式）；HTTP有固定格式（请求行+请求头+请求体）。
```

### 11. TCP 和 HTTP 分别作用于网络层哪几层？

先讲分层，再对应协议：

plaintext











```
1. 网络七层模型（OSI）：应用层 → 表示层 → 会话层 → 传输层 → 网络层 → 数据链路层 → 物理层；
   实际常用TCP/IP四层模型：应用层 → 传输层 → 网络层 → 网络接口层。

2. 协议对应层级：
   - TCP：作用于**传输层**（四层模型）/ 传输层（七层模型）；
   - HTTP：作用于**应用层**（四层模型）/ 应用层（七层模型）；
   - 补充：IP协议作用于网络层，MAC协议作用于数据链路层。
```

### 12. 七层网络协议有哪些？

按层级讲核心协议，突出常用的：

plaintext











```
七层网络协议（OSI模型）从下到上：
1. 物理层：负责物理介质的信号传输（如网线、光纤），无协议，关注电压、接口、速率；
2. 数据链路层：将物理层的信号封装为帧，负责局域网内传输，核心协议：以太网协议、MAC协议、ARP（地址解析）；
3. 网络层：负责跨网络的路由选择，核心协议：IP（IPv4/IPv6）、ICMP（ping命令基于此）、IGMP；
4. 传输层：负责端到端的数据传输，核心协议：TCP（可靠）、UDP（不可靠）；
5. 会话层：建立、管理、终止会话（如RPC、NetBIOS）；
6. 表示层：数据格式转换、加密解密（如JPEG、SSL/TLS）；
7. 应用层：面向用户的应用协议，核心协议：HTTP、HTTPS、FTP、SMTP、DNS、Redis、MySQL。
```

### 13. UDP 协议是什么？

对比 TCP 讲 UDP，突出核心特性：

plaintext











```
1. 定义：UDP（用户数据报协议）是传输层的无连接、不可靠的协议，基于数据报传输。

2. 核心特性：
   - 无连接：无需三次握手，直接发送数据，无需维护连接状态；
   - 不可靠：不保证数据有序、不丢失，无重传、无校验和（可选）、无序号；
   - 高效：头部小（仅8字节，TCP头部20字节），传输开销小，延迟低；
   - 面向数据报：数据以“数据报”为单位传输，一次发送一个数据报，不能拆分/合并。

3. 适用场景：
   - 对实时性要求高、可容忍少量丢包的场景：直播、视频通话、游戏、DNS查询、IoT数据传输；
   - 补充：TCP适合对可靠性要求高的场景（如文件传输、HTTP请求）。
```

### 14. 常见的 Linux 命令有哪些？

分类整理，突出高频命令：

plaintext











```
1. 文件操作：
   - ls：列出文件（ls -l 详细信息，ls -a 显示隐藏文件）；
   - cd：切换目录（cd /home 绝对路径，cd .. 上级目录）；
   - pwd：显示当前路径；
   - mkdir：创建目录（mkdir -p 递归创建）；
   - rm：删除（rm -rf 强制删除目录/文件）；
   - cp：复制（cp -r 复制目录）；
   - mv：移动/重命名；
   - cat：查看文件内容（cat -n 显示行号）；
   - less/more：分页查看大文件；
   - vi/vim：编辑文件（i插入，esc退出，:w保存，:q退出）。

2. 进程/系统：
   - ps：查看进程（ps -ef 所有进程，ps -ef | grep java 过滤java进程）；
   - kill：杀死进程（kill -9 进程ID 强制杀死）；
   - top：实时监控系统资源；
   - df：查看磁盘空间（df -h 人性化显示）；
   - du：查看文件/目录大小（du -sh 目录名）。

3. 网络：
   - ifconfig/ip addr：查看网卡/IP；
   - ping：测试网络连通性；
   - netstat/ss：查看端口占用（netstat -tulpn | grep 8080）；
   - curl/wget：访问URL（curl http://localhost:8080）。

4. 权限：
   - chmod：修改权限（chmod 755 文件，7=读+写+执行，5=读+执行）；
   - chown：修改所有者（chown user:group 文件）。
```

### 15. 查看 CPU 负载、内存使用率的命令？

补充 top 之外的高频命令：

plaintext











```
1. CPU负载：
   - top：实时显示CPU使用率（%CPU列）、负载平均值（top界面左上角load average：1分钟/5分钟/15分钟负载）；
   - mpstat：查看每个CPU核心的使用率（mpstat -P ALL 1 每秒刷新，显示每个核心的%usr/%sys）；
   - uptime：快速查看负载平均值（无需进入top）；
   - vmstat：查看CPU状态（vmstat 1，%us用户态，%sy内核态，%id空闲）。

2. 内存使用率：
   - top：实时显示内存（%MEM列）、总内存/已用/空闲（top界面Mem行）；
   - free：查看内存详情（free -h 人性化显示，total总内存，used已用，free空闲，buff/cache缓存）；
   - vmstat：查看内存交换区（swap行，si/so非0表示内存不足，使用交换区）。

3. 示例：
   free -h 输出：
   total        used        free      shared  buff/cache   available
   16Gi       2.5Gi       10Gi       128Mi       3.5Gi        13Gi
   （available是实际可用内存，比free更准确）
```

### 16. 用户态和内核态有了解吗？

核心讲**定义、切换、区别**：

plaintext











```
1. 定义：
   - 内核态：CPU的特权模式，运行内核代码，能访问所有系统资源（内存、硬件、寄存器）；
   - 用户态：CPU的非特权模式，运行用户程序，只能访问受限资源，不能直接访问硬件/内核内存。

2. 核心区别：
   - 权限：内核态权限最高，用户态权限低；
   - 地址空间：内核态有独立的内核地址空间，用户态只能访问用户地址空间；
   - 执行代码：内核态执行内核代码（如系统调用、驱动），用户态执行应用代码（如Java程序）。

3. 切换场景：
   - 用户态→内核态：用户程序调用系统调用（如read/write文件、网络请求）、触发中断（如键盘输入）、发生异常（如除0）；
   - 内核态→用户态：系统调用执行完成、中断处理完成，返回用户程序。

4. 切换开销：
   切换需要保存/恢复CPU上下文（寄存器、程序计数器），开销较大，所以高性能程序会减少系统调用次数（如Redis用epoll减少系统调用）。
```

### 17. 进程和线程的区别

从**定义、资源、调度、开销**等维度对比：

plaintext











```
1. 定义：
   - 进程：操作系统分配资源的基本单位（独立的内存空间、文件句柄、PID）；
   - 线程：CPU调度的基本单位，是进程的执行单元，共享进程的资源。

2. 核心区别：
   | 维度       | 进程               | 线程               |
   |------------|--------------------|--------------------|
   | 资源分配   | 拥有独立资源（内存、文件句柄） | 共享进程的资源     |
   | 调度       | 操作系统调度（切换慢） | CPU调度（切换快） |
   | 开销       | 创建/销毁/切换开销大 | 开销小（仅切换上下文） |
   | 独立性     | 独立运行，互不影响 | 一个线程崩溃导致进程崩溃 |
   | 通信       | 需IPC（管道、消息队列） | 直接共享内存（易出现线程安全问题） |

3. 举例：
   - 一个Java程序运行时是一个进程（PID），里面的多个线程（如主线程、GC线程）共享JVM的堆、方法区，每个线程有独立的虚拟机栈、程序计数器。
```

### 18. 进程间通信有哪些？

分类讲常用的 IPC 方式，突出适用场景：

plaintext











```
1. 管道（Pipe）：
   - 匿名管道：父子进程间通信，半双工（单向传输），如shell的|（ls | grep java）；
   - 命名管道（FIFO）：无亲缘关系的进程间通信，基于文件系统。

2. 消息队列：
   - 存储消息的链表，独立于进程，可实现跨进程的异步通信，如System V消息队列、POSIX消息队列。

3. 共享内存：
   - 多个进程共享同一块内存区域，最快的IPC方式（无需拷贝数据），需配合信号量实现同步。

4. 信号量（Semaphore）：
   - 用于进程/线程间的同步互斥，不是传输数据，而是控制资源访问（如PV操作）。

5. 信号（Signal）：
   - 通知进程发生某个事件（如kill -9 发送SIGKILL信号），用于异步通知。

6. 套接字（Socket）：
   - 跨网络的进程间通信（如TCP/UDP），也可用于本机进程通信（unix domain socket）。

7. 总结：
   - 高性能：共享内存；
   - 简单：管道；
   - 跨网络：Socket；
   - 异步通知：信号/消息队列。
```

### 19. Redis 和 Kafka 有了解吗？

即使没用过，也要讲核心定位，避免 “完全不会”：

plaintext











```
1. Redis：
   - 定位：高性能的内存数据库（键值对存储），支持持久化、集群；
   - 核心特点：单线程、基于内存、支持多种数据类型（String/Hash/List/Set/ZSet）；
   - 典型应用：缓存、分布式锁、计数器、限流、消息队列（List/ZSet）。

2. Kafka：
   - 定位：分布式的消息队列（流处理平台），基于磁盘存储；
   - 核心特点：高吞吐、高可用、持久化、分区副本；
   - 典型应用：日志收集、消息解耦、流处理（如用户行为数据上报、订单消息异步处理）；
   - 补充：虽然没实际用过，但了解其核心是“生产者-消费者”模型，通过分区实现并发，副本保证高可用。
```

### 20. Kafka 基础组件有什么？

核心组件讲清楚，即使没用过也能答出框架：

plaintext











```
Kafka的核心组件：
1. Producer（生产者）：发送消息到Kafka集群的客户端；
2. Consumer（消费者）：从Kafka集群读取消息的客户端，消费者组（Consumer Group）保证一个分区的消息只被一个消费者消费；
3. Broker（服务节点）：Kafka集群的服务器节点，存储消息；
4. Topic（主题）：消息的分类，生产者发送消息到指定Topic，消费者订阅Topic；
5. Partition（分区）：Topic的物理拆分，每个Topic分为多个Partition，分布式存储，提升并发；
6. Replica（副本）：Partition的副本，分为Leader副本（处理读写）和Follower副本（同步数据，故障时切换）；
7. Offset（偏移量）：消费者消费的位置标记，记录消费到Partition的哪个位置；
8. ZooKeeper（Kafka<3.0）/KRaft（Kafka≥3.0）：管理集群元数据（如Broker节点、Topic配置）、选主。
```

### 21. Redis 的基础数据类型有哪些？

讲 5 个核心类型 + 典型应用：

plaintext











```
Redis核心基础数据类型：
1. String（字符串）：
   - 存储：文本/数字（整数/浮点数）；
   - 应用：缓存（如用户信息）、计数器（incr/decr）、分布式锁（SETNX）。
2. Hash（哈希）：
   - 存储：键值对的集合（类似Java的Map）；
   - 应用：缓存对象（如商品信息，hset product:1 name "手机" price 2000）。
3. List（列表）：
   - 存储：有序的字符串列表（双向链表）；
   - 应用：消息队列（lpush/rpop）、最新列表（如用户最近浏览的商品）。
4. Set（集合）：
   - 存储：无序、唯一的字符串集合；
   - 应用：去重（如用户签到）、交集/并集（如共同好友）。
5. Sorted Set（ZSet，有序集合）：
   - 存储：按score排序的集合；
   - 应用：排行榜（如商品销量排名）、延迟队列（score为时间戳）。
```

### 22. Redis 的列表底层数据结构是什么？

Redis 3.2 + 的 List 底层是**快速链表（quicklist）**，补充演进过程：

plaintext











```
1. 早期版本：
   - 小列表：压缩列表（ziplist），节省内存；
   - 大列表：双向链表（linkedlist），增删快但内存开销大。

2. Redis 3.2+：
   - 快速链表（quicklist）：将多个压缩列表用双向链表连接，结合了ziplist的内存优势和linkedlist的增删优势；
   - 核心：每个quicklist节点是一个ziplist，当ziplist达到阈值时，新建节点，避免单个ziplist过大。

3. 关键：
   quicklist是Redis List的默认实现，既节省内存，又保证增删效率。
```

### 23. Redis 的哈希类型的结构是什么？

分两种情况，讲清楚触发条件：

plaintext











```
Redis Hash的底层结构：
1. 压缩列表（ziplist）：
   - 触发条件：Hash的键值对数量≤512个，且每个键/值的长度≤64字节；
   - 特点：连续内存存储，节省内存，查询效率稍低。

2. 哈希表（hashtable）：
   - 触发条件：不满足ziplist条件时，自动转为hashtable；
   - 特点：类似Java的HashMap（数组+链表），查询效率高（O(1)），内存开销大。

3. 补充：
   Redis可通过配置（hash-max-ziplist-entries、hash-max-ziplist-value）调整ziplist的阈值。
```

### 24. Redis 的删除策略有哪些？

讲 3 种核心策略 + 过期键处理：

plaintext











```
Redis的删除策略针对过期键（设置了expire的键）：
1. 惰性删除（Lazy Delete）：
   - 逻辑：访问键时才检查是否过期，过期则删除；
   - 优点：节省CPU（只在访问时处理）；
   - 缺点：内存泄漏（过期键长期不访问，占用内存）。

2. 定期删除（Periodic Delete）：
   - 逻辑：Redis每隔一段时间（默认100ms）随机抽取部分过期键检查，过期则删除；
   - 优点：平衡CPU和内存；
   - 缺点：可能漏删（未抽到的过期键仍占用内存）。

3. 内存淘汰（Memory Eviction）：
   - 逻辑：当内存达到阈值时，触发淘汰策略，删除部分键（不一定是过期键）；
   - 核心策略：
     - volatile-lru：淘汰过期键中最近最少使用的；
     - allkeys-lru：淘汰所有键中最近最少使用的；
     - volatile-ttl：淘汰过期键中剩余时间最短的；
     - noeviction：默认，不淘汰，内存满时拒绝写入。

4. 总结：
   Redis默认用“惰性删除+定期删除”处理过期键，配合内存淘汰策略解决内存不足问题。
```

### 25. Redis 的分布式锁是什么？

讲**定义、实现、问题解决**：

plaintext











```
1. 定义：
   Redis分布式锁是用于分布式系统中，保证多个节点对共享资源的互斥访问的机制。

2. 核心实现（基础版）：
   - 加锁：SET key value NX EX 过期时间（NX=仅当key不存在时设置，EX=过期时间，避免死锁）；
     示例：SET lock:order 1 NX EX 10（加锁10秒）；
   - 解锁：先判断value是否为自己的，再删除（避免误删其他线程的锁），用Lua脚本保证原子性：
     if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end。

3. 核心问题&解决：
   - 死锁：设置过期时间（EX）；
   - 误删：解锁时校验value（如用UUID作为value）；
   - 锁过期：续期（如Redisson的watchdog机制，定时延长过期时间）；
   - 集群一致性：Redlock算法（多Redis实例加锁，超过半数成功才算加锁）。
```

### 26. Redis 的持久化怎么做？

讲两种核心方式 + 对比：

plaintext











```
Redis持久化有两种核心方式：
1. RDB（Redis Database）：
   - 逻辑：定时将内存中的数据快照保存到磁盘（.rdb文件）；
   - 触发方式：
     - 手动：SAVE（阻塞）、BGSAVE（后台线程，不阻塞）；
     - 自动：配置save m n（m秒内有n次修改则触发）；
   - 优点：文件小，恢复快；
   - 缺点：数据丢失（两次快照之间的修改），BGSAVE会fork子进程，消耗内存。

2. AOF（Append Only File）：
   - 逻辑：记录所有写命令（如SET、HSET）到日志文件（.aof），恢复时重新执行命令；
   - 触发方式：
     - 同步策略：always（每次写都同步，最安全）、everysec（每秒同步，默认）、no（交给操作系统）；
     - 重写（AOF Rewrite）：压缩日志文件（合并重复命令），避免文件过大；
   - 优点：数据丢失少（最多1秒），命令易理解；
   - 缺点：文件大，恢复慢。

3. 混合持久化（Redis 4.0+）：
   - 结合RDB和AOF：RDB保存全量数据，AOF保存增量命令，兼顾恢复速度和数据安全性。
```

### 27. 手撕：字符串中的最长不重复子串

这是 LeetCode 第 3 题，核心用**滑动窗口 + 哈希表**实现，代码可直接运行：

#### 解题思路

- 滑动窗口：用左右指针表示当前不重复子串的范围；
- 哈希表：记录字符最后出现的索引，遇到重复字符时，左指针跳到重复字符的下一位；
- 遍历过程中记录窗口的最大长度。

#### 完整代码（Java）

java



运行









```
import java.util.HashMap;
import java.util.Map;

public class LongestNonRepeatSubstring {
    public static int lengthOfLongestSubstring(String s) {
        // 哈希表：字符 → 最后出现的索引
        Map<Character, Integer> charIndexMap = new HashMap<>();
        int maxLen = 0; // 最长长度
        int left = 0; // 滑动窗口左指针

        // 右指针遍历字符串
        for (int right = 0; right < s.length(); right++) {
            char c = s.charAt(right);
            // 如果字符已存在，且在当前窗口内（索引≥left），更新左指针
            if (charIndexMap.containsKey(c) && charIndexMap.get(c) >= left) {
                left = charIndexMap.get(c) + 1;
            }
            // 更新字符最后出现的索引
            charIndexMap.put(c, right);
            // 计算当前窗口长度，更新最大值
            maxLen = Math.max(maxLen, right - left + 1);
        }
        return maxLen;
    }

    // 测试用例
    public static void main(String[] args) {
        System.out.println(lengthOfLongestSubstring("abcabcbb")); // 3（abc）
        System.out.println(lengthOfLongestSubstring("bbbbb"));    // 1（b）
        System.out.println(lengthOfLongestSubstring("pwwkew"));   // 3（wke）
        System.out.println(lengthOfLongestSubstring(""));         // 0
    }
}
```

#### 代码解释

- `charIndexMap`：存储每个字符最后一次出现的索引，避免重复遍历；
- `left`：滑动窗口左边界，保证窗口内无重复字符；
- 时间复杂度：O (n)（n 为字符串长度，每个字符遍历一次）；
- 空间复杂度：O (1)（最多存储 26/52 个字母，或 ASCII 字符，视为常数）。

------

### 总结

1. **MySQL 核心**：索引（B + 树）、事务隔离级别、MVCC、锁机制、数据类型存储是底层高频考点，需掌握原理和应用；
2. **网络 / 系统**：七层协议、TCP/UDP/HTTP 区别、Linux 监控命令、进程线程 / 用户态内核态是基础，需分类记忆；
3. **Redis 核心**：数据类型、底层结构、删除策略、分布式锁、持久化是必考点，重点讲清 “是什么 + 为什么 + 怎么用”；
4. **算法编程**：最长不重复子串用滑动窗口 + 哈希表是最优解，需掌握思路和代码实现，能解释时间 / 空间复杂度。