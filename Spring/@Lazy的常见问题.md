在 Spring 中，`@Lazy` 注解的核心作用是**延迟 Bean 的初始化**（默认 Spring 容器启动时会初始化单例 Bean，`@Lazy` 会让 Bean 直到第一次被使用时才初始化）。它的核心问题确实和 **Bean 之间的依赖关系** 强相关 —— 延迟初始化会打破默认的 “启动时校验依赖” 机制，把依赖问题从 “容器启动阶段” 推迟到 “Bean 首次使用阶段”，还可能引发循环依赖、依赖注入失效等连锁问题。

### 一、核心问题：与依赖 Bean 相关的核心风险

#### 1. 依赖缺失 / 依赖不满足的问题被 “隐藏”，启动时无法发现

Spring 默认的 “饿汉式初始化”（非 `@Lazy`）会在容器启动时初始化所有单例 Bean，此时若某个 Bean 依赖的其他 Bean 不存在、配置错误（如属性缺失）或无法初始化（如构造函数抛异常），容器会直接启动失败，开发者能立即发现问题。

但用 `@Lazy` 后，被标注的 Bean 及其依赖链的初始化会推迟到 “首次调用” 时：

- 示例：BeanA 依赖 BeanB，且 BeanA 被 `@Lazy` 标注。容器启动时，BeanA 和 BeanB 都不初始化，启动成功；但当业务代码第一次调用 BeanA 时，Spring 才尝试初始化 BeanA，此时发现 BeanB 不存在（或 BeanB 初始化失败），会直接抛出 `NoSuchBeanDefinitionException` 或 `BeanCreationException`，导致**运行时故障**（可能是线上流量触发，影响范围更大）。
- 关键：把 “启动时校验” 变成 “运行时校验”，依赖问题从 “早发现” 变成 “晚爆发”，排查成本更高。

#### 2. 循环依赖处理异常（与 `@Autowired` 配合时）

Spring 本身能解决 “单例 Bean 构造器注入之外” 的循环依赖（如字段注入、setter 注入），核心是通过 “三级缓存” 提前暴露未完全初始化的 Bean。但 `@Lazy` 会打破这个机制：

- 场景：BeanA 依赖 BeanB，BeanB 依赖 BeanA，且两者都用 `@Lazy` 标注（或其中一个用 `@Lazy`）。
- 问题：容器启动时，两者都未初始化，三级缓存中没有任何一方的 “提前暴露实例”；当首次调用 BeanA 时，Spring 初始化 BeanA，发现依赖 BeanB，进而初始化 BeanB，BeanB 又依赖 BeanA，但此时 BeanA 还处于 “初始化中” 状态，三级缓存无法提供实例，最终抛出 `BeanCurrentlyInCreationException`（循环依赖无法解决）。
- 对比：非 `@Lazy` 的单例 Bean，Spring 启动时会通过三级缓存提前暴露 BeanA 的半成品实例，BeanB 依赖时能获取到，避免循环依赖报错；`@Lazy` 让这个 “提前暴露” 机制失效，因为 Bean 根本没启动初始化。

#### 3. 依赖注入的 Bean 可能是 “代理对象”，导致方法调用异常

Spring 中 `@Lazy` 常与 AOP 结合（如事务 `@Transactional`、缓存 `@Cacheable`），此时被 `@Lazy` 标注的 Bean 会被 Spring 生成**代理对象**（JDK 动态代理或 CGLIB 代理），而非原始 Bean 实例。若依赖注入时未注意代理类型，会引发问题：

- 场景：BeanA 被 `@Lazy` + `@Transactional` 标注（代理对象），BeanB 依赖注入 BeanA 后，直接调用 BeanA 的非 public 方法（或 final 方法）。
- 问题：AOP 代理的核心是 “拦截目标方法”，但 JDK 动态代理只代理接口方法，CGLIB 代理无法拦截 final 方法 / 非 public 方法；`@Lazy` 延迟初始化时，注入的是代理对象，而非原始 Bean，调用这些不可拦截的方法时，会导致事务、缓存等功能失效，甚至抛出 `IllegalAccessException`（非 public 方法访问权限问题）。
- 本质：`@Lazy` 延迟了 “原始 Bean 初始化”，但代理对象的创建是提前的，依赖注入的是代理，而非原始 Bean，开发者可能误把代理当原始 Bean 操作，忽略代理的限制。

#### 4. 单例 Bean 的 “懒初始化” 不保证线程安全

Spring 单例 Bean 的初始化默认是 “线程安全” 的（容器启动时单线程初始化），但 `@Lazy` 让初始化推迟到 “首次调用”，而首次调用可能发生在多线程环境下：

- 问题：若多个线程同时首次调用被 `@Lazy` 标注的单例 Bean，Spring 会尝试同时初始化该 Bean，可能导致 “重复初始化”（虽然 Spring 内部有简单的锁机制，但复杂依赖场景下仍可能出现线程安全问题），或初始化过程中 Bean 状态不一致（如某个线程正在给 Bean 注入依赖，另一个线程已经开始调用 Bean 的方法）。
- 关联依赖：若该 Bean 还依赖其他 `@Lazy` Bean，多线程同时触发初始化时，会导致依赖链的 Bean 都面临线程安全风险，可能出现依赖注入不完整就被调用的情况。

#### 5. 依赖的 Bean 若为 “原型 Bean”，导致重复创建或状态混乱

Spring 中原型 Bean（`@Scope("prototype")`）的特点是 “每次获取都创建新实例”，若原型 Bean 被 `@Lazy` 标注，且被单例 Bean 依赖注入：

- 场景：单例 BeanA 依赖注入原型 BeanB（`@Lazy` + `@Scope("prototype")`）。
- 问题：单例 BeanA 初始化时（首次调用时），会获取一次原型 BeanB 并注入；但后续 BeanA 调用 BeanB 时，不会再创建新的原型实例（因为注入只发生一次），导致原型 Bean 变成 “伪单例”，状态混乱（多个线程共享同一个原型 Bean 实例）。
- 本质：`@Lazy` 只延迟 “首次获取原型 Bean”，但单例 Bean 的依赖注入是 “一次性” 的，无法体现原型 Bean “每次获取新实例” 的特性，依赖关系与作用域冲突。

### 二、其他衍生问题（与依赖相关的连锁反应）

#### 1. 启动时间缩短的 “假象”，运行时首次调用耗时增加

`@Lazy` 确实能减少容器启动时的初始化工作量，让启动时间变快，但这是 “预支未来时间”—— 首次调用被 `@Lazy` 标注的 Bean 时，Spring 要完成该 Bean 及其所有依赖 Bean 的初始化（可能是一串依赖链），导致首次调用的响应时间大幅增加（如从毫秒级变成秒级），若在高并发场景下（如秒杀接口首次触发），可能引发超时。

#### 2. 日志排查困难，依赖链追踪复杂

容器启动时不初始化 `@Lazy` Bean，所以启动日志中没有该 Bean 的初始化日志、依赖注入日志；当运行时出现问题时，日志中只有首次调用时的报错信息，无法追溯 Bean 的依赖链（如 “哪个 Bean 依赖了它”“依赖的 Bean 初始化顺序是什么”），排查难度远大于启动时的报错。

### 三、总结：`@Lazy` 与依赖 Bean 相关的核心矛盾

`@Lazy` 的本质是 “推迟初始化”，而 Spring 容器的核心优势之一是 “启动时校验依赖、提前暴露实例、保证初始化顺序”，两者存在天然矛盾：

- 依赖问题从 “启动时暴露” 变成 “运行时爆发”，影响范围更大；
- 循环依赖、代理对象、作用域冲突等问题，都因 “依赖初始化顺序被打乱”“依赖注入时机推迟” 而产生；
- 核心建议：除非有明确的性能优化需求（如某个 Bean 依赖重、启动慢且不常用），否则尽量不用 `@Lazy`；若必须使用，需提前校验依赖链（避免循环依赖）、确保依赖的 Bean 作用域匹配（单例 vs 原型）、避免调用代理对象的不可拦截方法，并做好运行时异常兜底（如首次调用失败重试）。