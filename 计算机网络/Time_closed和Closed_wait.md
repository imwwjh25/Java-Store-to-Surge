### 1. CLOSE_WAIT 状态

**含义**：
当本地收到了对方的FIN请求时，本地的TCP进入 CLOSE_WAIT 状态，表示连接另一端已经关闭，本地还没有关闭。此时应用程序需要关闭socket，调用close()，最终连接才会真正关闭。

**过多出现的影响**：

- **资源占用**：每个CLOSE_WAIT连接都占用系统的文件描述符（socket），过多会导致文件描述符耗尽，从而影响新连接的建立和其他进程的正常运行。
- **系统性能下降**：大量处于CLOSE_WAIT的连接长时间得不到释放，会导致内存和其它内核资源被占用，影响系统性能。
- **问题根源是应用程序未及时关闭socket**：CLOSE_WAIT过多通常表明应用程序存在Bug（比如没有正确调用close()），需要排查代码逻辑。

------

### 2. TIME_WAIT 状态

**含义**：
当主动关闭连接的一方发送了最后一个ACK后，会进入TIME_WAIT状态，保持连接一段时间（通常是2倍的MSL，约2分钟），以确保对方收到ACK，防止旧连接的报文影响新连接。

**过多出现的影响**：

- **端口资源浪费**：TIME_WAIT状态的连接会占用本地端口，端口资源会被暂时占用，一旦数量过多，会影响新的连接建立，尤其是短连接场景。
- **系统内存和CPU开销**：内核需要维护这些TIME_WAIT的连接状态，也会消耗一定的内存和CPU。
- **常见于大量短连接服务**，比如HTTP短链接服务器。

------

### 哪个危害更大？

- **CLOSE_WAIT的危害一般更严重**，因为它直接反映出应用程序没有正确关闭socket，导致连接长期占用文件描述符和内存资源，容易导致文件句柄耗尽，使系统无法新建连接或运行其他服务。
- TIME_WAIT虽然数量多也会有影响，但多数情况下它是正常的TCP连接关闭现象，可以通过优化协议设计（如使用长连接，开启端口复用，调整内核参数）来缓解。

------

### 总结

| 状态       | 产生原因                       | 主要危害                     | 哪个危害更大                                           |
| ---------- | ------------------------------ | ---------------------------- | ------------------------------------------------------ |
| CLOSE_WAIT | 对方关闭连接，本端未及时close  | 文件描述符耗尽，资源占用过高 | CLOSE_WAIT更严重，因为是应用层关闭不及时导致的资源耗尽 |
| TIME_WAIT  | 本端主动关闭连接后等待若干时间 | 端口资源占用，影响新连接建立 | 较轻微，但影响短连接场景性能                           |

------

### 建议

- 对于**CLOSE_WAIT过多**，需排查应用程序代码，确保在收到FIN后及时关闭socket。
- 对于**TIME_WAIT过多**，可考虑使用长连接、优化内核参数（如`tcp_tw_recycle`、`tcp_tw_reuse`，不过部分已废弃或不推荐使用），或者增加端口范围。

------
