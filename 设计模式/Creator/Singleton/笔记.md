### 一、常见实现方式及核心区别

#### 1. 饿汉式（静态常量）

**实现思路**：在类加载时就完成实例化，天生线程安全，但不支持懒加载。







```
public class HungrySingleton {
    // 1. 私有静态常量，类加载时直接初始化
    private static final HungrySingleton INSTANCE = new HungrySingleton();
    
    // 2. 私有构造方法，禁止外部new
    private HungrySingleton() {}
    
    // 3. 公共静态方法，返回唯一实例
    public static HungrySingleton getInstance() {
        return INSTANCE;
    }
}
```

**核心特点**：

- 线程安全：类加载由 JVM 保证线程安全，不会出现多线程创建多个实例的问题。
- 无懒加载：类一加载就创建实例，即使实例从未被使用，也会占用内存。
- 性能：获取实例时无锁，性能最优。
- 适用场景：实例占用内存小、程序启动时就需要使用的单例。

#### 2. 懒汉式（非线程安全）

**实现思路**：延迟加载（懒加载），只有调用`getInstance()`时才创建实例，但多线程环境下会创建多个实例。





```
public class LazySingletonUnsafe {
    private static LazySingletonUnsafe instance;
    
    private LazySingletonUnsafe() {}
    
    public static LazySingletonUnsafe getInstance() {
        // 未加锁，多线程同时进入会创建多个实例
        if (instance == null) {
            instance = new LazySingletonUnsafe();
        }
        return instance;
    }
}
```

**核心特点**：

- 非线程安全：多线程并发调用`getInstance()`时，会突破`if (instance == null)`的判断，创建多个实例。
- 支持懒加载：只有使用时才创建实例，节省内存。
- 性能：无锁，单线程下性能好，但多线程下不可用。
- 适用场景：仅单线程环境，实际开发中**禁止使用**。

#### 3. 懒汉式（加同步方法）

**实现思路**：给`getInstance()`加`synchronized`关键字，保证线程安全，但性能差。




```
public class LazySingletonSafe {
    private static LazySingletonSafe instance;
    
    private LazySingletonSafe() {}
    
    // 同步方法，保证线程安全，但每次调用都要加锁
    public static synchronized LazySingletonSafe getInstance() {
        if (instance == null) {
            instance = new LazySingletonSafe();
        }
        return instance;
    }
}
```

**核心特点**：

- 线程安全：`synchronized`保证同一时间只有一个线程执行方法。
- 支持懒加载：仅在首次调用时创建实例。
- 性能差：每次调用`getInstance()`都要获取锁，即使实例已创建，锁竞争会导致性能损耗。
- 适用场景：单例使用频率极低、对性能要求不高的场景，实际很少用。

#### 4. 双重检查锁（DCL，Double-Checked Locking）

**实现思路**：结合懒加载和锁优化，仅在实例未创建时加锁，是目前最常用的实现方式。


```
public class DclSingleton {
    // 关键：volatile修饰，禁止指令重排
    private static volatile DclSingleton instance;
    
    private DclSingleton() {}
    
    public static DclSingleton getInstance() {
        // 第一次检查：实例已创建则直接返回，避免加锁
        if (instance == null) {
            // 加锁：保证只有一个线程进入创建逻辑
            synchronized (DclSingleton.class) {
                // 第二次检查：防止多个线程等待锁后重复创建
                if (instance == null) {
                    instance = new DclSingleton();
                }
            }
        }
        return instance;
    }
}
```

**核心特点**：

- 线程安全：双重检查 +`volatile`（禁止`instance = new DclSingleton()`的指令重排，避免出现 “半初始化实例”）。
- 支持懒加载：仅首次调用时创建实例。
- 性能优：仅首次创建实例时加锁，后续调用无锁，兼顾线程安全和性能。
- 注意点：必须用`volatile`修饰实例变量，否则在高并发下可能获取到未完全初始化的实例。
- 适用场景：绝大多数并发场景（如工具类、配置类），是工业级首选。

#### 5. 静态内部类（Holder 模式）

**实现思路**：利用 JVM 类加载机制保证线程安全，是更优雅的懒加载实现。

```
public class HolderSingleton {
    // 私有构造方法
    private HolderSingleton() {}
    
    // 静态内部类：仅在调用getInstance()时才加载
    private static class SingletonHolder {
        private static final HolderSingleton INSTANCE = new HolderSingleton();
    }
    
    // 公共方法：返回内部类的静态常量
    public static HolderSingleton getInstance() {
        return SingletonHolder.INSTANCE;
    }
}
```

**核心特点**：

- 线程安全：JVM 保证静态内部类的加载是线程安全的，仅在首次加载时创建实例。
- 支持懒加载：静态内部类`SingletonHolder`只有在`getInstance()`被调用时才会加载，实现延迟初始化。
- 性能优：无锁，获取实例时直接返回常量，性能和饿汉式一致。
- 适用场景：需要懒加载、对代码优雅性要求高的场景，是比 DCL 更推荐的实现方式（无 volatile 依赖）。

#### 6. 枚举单例

**实现思路**：利用 Java 枚举的特性（JVM 保证枚举类的实例唯一且线程安全），是《Effective Java》推荐的最佳实现。









```
public enum EnumSingleton {
    // 唯一实例
    INSTANCE;
    
    // 枚举类可以添加自定义方法
    public void doSomething() {
        System.out.println("枚举单例执行方法");
    }
}

// 使用方式：EnumSingleton.INSTANCE.doSomething();
```

**核心特点**：

- 绝对线程安全：JVM 底层保证枚举实例的创建是线程安全的，且不会被反射、序列化破坏。
- 无懒加载：枚举类在首次被使用时加载，和饿汉式类似（但枚举加载时机更晚，接近懒加载）。
- 防破坏：普通单例可通过反射调用私有构造方法创建新实例，枚举则无法被反射实例化；序列化时枚举也能保证实例唯一。
- 适用场景：需要绝对安全（防反射 / 序列化破坏）、无需懒加载的单例（如配置中心、核心服务）。

### 二、各实现方式对比表






|       实现方式       |     线程安全      | 懒加载 | 防反射 / 序列化 | 性能 |          适用场景          |
| :------------------: | :---------------: | :----: | :-------------: | :--: | :------------------------: |
|  饿汉式（静态常量）  |        是         |   否   |       否        | 最优 |     实例小、启动即使用     |
| 懒汉式（非线程安全） |        否         |   是   |       否        |  高  |      仅单线程（禁用）      |
|  懒汉式（同步方法）  |        是         |   是   |       否        |  低  |   使用率极低、性能无要求   |
|  双重检查锁（DCL）   | 是（需 volatile） |   是   |       否        |  高  | 绝大多数并发场景（工业级） |
| 静态内部类（Holder） |        是         |   是   |       否        | 最优 |      懒加载、代码优雅      |
|       枚举单例       |        是         |  接近  |       是        | 最优 |     绝对安全、核心服务     |

### 总结

1. **核心区别维度**：判断单例实现的关键是`线程安全`、`懒加载`、`性能`、`防破坏能力`，这也是不同实现的核心差异点。

2. 选型建议 ：

    - 无需懒加载：优先选**饿汉式**（简单）或**枚举单例**（安全）；
    - 需要懒加载：优先选**静态内部类**（优雅）或**DCL**（灵活）；
    - 要求绝对安全（防反射 / 序列化）：必须选**枚举单例**。



3. **避坑点**：懒汉式（非线程安全）绝对不能用于多线程；DCL 必须加`volatile`，否则会出现 “半初始化实例” 问题。