### 一、MySQL 主从复制核心原理

MySQL 主从复制是实现**数据备份、读写分离、高可用**的核心机制，其本质是主库将数据修改操作记录到二进制日志（binlog），从库通过网络拉取该日志并执行，最终实现主从数据一致。

#### 1. 核心组件

| 组件                 | 作用                                                         |
| -------------------- | ------------------------------------------------------------ |
| 主库（Master）       | ① 记录所有数据修改操作到 binlog；② 启动 dump 线程，向从库传输 binlog |
| 从库（Slave）        | ① IO 线程：连接主库，拉取 binlog 并写入本地中继日志（relay log）；② SQL 线程：读取 relay log，解析并执行 SQL，还原主库数据；③ relay log：存储主库 binlog 内容，避免直接依赖主库；④ [master.info](https://master.info/)：记录主库连接信息和复制进度；⑤ [relay-log.info](https://relay-log.info/)：记录 relay log 的执行进度 |
| binlog（二进制日志） | 主库核心日志，记录数据修改操作（增删改、DDL），支持 3 种格式（见下文） |

#### 2. 复制流程（异步复制，默认模式）











```plaintext
主库写操作 → 写入binlog → 从库IO线程拉取binlog → 从库写入relay log → 从库SQL线程执行relay log → 从库数据同步
```

具体步骤：

1. **主库生成 binlog**：主库执行 INSERT/UPDATE/DELETE/DDL 等操作后，按配置的 binlog 格式将操作记录到 binlog（刷盘策略可配置，如 sync_binlog=1 保证事务刷盘）。
2. **从库 IO 线程请求 binlog**：从库通过 CHANGE MASTER TO 配置主库地址、账号、起始 binlog 位置后，IO 线程连接主库的 dump 线程，请求指定 binlog 文件的指定位置之后的日志。
3. **主库 dump 线程传输 binlog**：主库 dump 线程读取 binlog 内容，通过网络传输给从库 IO 线程。
4. **从库写入 relay log**：从库 IO 线程将接收到的 binlog 内容写入本地 relay log 文件（按序存储）。
5. **从库 SQL 线程执行 relay log**：从库 SQL 线程逐行读取 relay log，解析为 SQL 并执行，最终让从库数据与主库一致。

#### 3. 复制模式（binlog 格式）

| 复制模式                                           | 说明                                                       | 优点                  | 缺点                                                      |
| -------------------------------------------------- | ---------------------------------------------------------- | --------------------- | --------------------------------------------------------- |
| 基于语句（SBR）                                    | 记录执行的 SQL 语句                                        | binlog 体积小、效率高 | 非确定性语句（NOW ()、RAND ()、自增主键）会导致数据不一致 |
| 基于行（RBR）                                      | 记录数据行的修改（如 “某行 id=1 的 name 字段从 A 改为 B”） | 数据一致性极高        | binlog 体积大，占磁盘 / 网络带宽多                        |
| 混合模式（MBR）                                    | 默认用 SBR，遇到非确定性语句自动切换为 RBR                 | 平衡体积和一致性      | 逻辑稍复杂，仍可能存在边缘场景不一致                      |
| **推荐**：生产环境优先用 RBR，避免数据不一致问题。 |                                                            |                       |                                                           |

### 二、主从复制常见问题及解决方案

#### 1. 主从数据不一致

##### 现象

- 从库数据行数 / 字段值与主库不符；
- 业务查询从库时出现数据缺失 / 错误。

##### 核心原因

1. 复制模式为 SBR，执行了非确定性 SQL（如使用 NOW ()、UUID ()、自增主键未指定规则）；
2. 从库未设置只读，被手动写入数据；
3. 主从库配置不一致（sql_mode、字符集、时区、表结构不同）；
4. 复制中断后未完全同步就强制恢复；
5. 大事务导致从库执行过程中异常。

##### 解决方法

1. 预防 ：

    - 强制使用 RBR 模式；
    - 从库设置`read_only=1` + `super_read_only=1`（MySQL 5.7+，禁止超级权限用户写操作）；
    - 保证主从库配置完全一致（sql_mode、character_set_server、time_zone 等）；

2. 修复 ：

    - 使用 Percona 工具`pt-table-checksum`校验数据不一致的表；
    - 使用`pt-table-sync`自动修复不一致数据（谨慎操作，建议先备份）；
    - 若差异过大，重新搭建从库（主库全量备份 + 增量 binlog 恢复）。

#### 2. 主从复制延迟（Seconds_Behind_Master > 0）

##### 现象

- `show slave status\G`中`Seconds_Behind_Master`数值持续大于 0；
- 从库数据落后主库，读写分离业务读取到旧数据。

##### 核心原因

1. 从库性能瓶颈：CPU / 内存 / 磁盘 IO 不足（如从库用机械硬盘，主库用 SSD）；
2. 主库大事务：批量插入、大表 ALTER、DELETE 全表等操作，从库 SQL 线程单线程执行耗时；
3. 网络延迟：主从跨机房部署，网络带宽 / 延迟高；
4. 复制线程限制：MySQL 5.6 之前 SQL 线程为单线程，无法并行执行；
5. 从库负载高：从库同时承担大量查询请求，挤占 SQL 线程资源；
6. 主库写入压力过大：binlog 生成速度超过从库同步速度。

##### 解决方法

1. 优化从库性能 ：

    - 升级从库硬件（SSD 替换机械硬盘、增加 CPU / 内存）；
    - 开启多线程复制（MySQL 5.6 + 配置`slave_parallel_workers>0`，MySQL 8.0 支持按库 / 表 / 行并行）；

2. 优化主库操作 ：

    - 拆分大事务（如批量插入拆分为多次小批量插入）；
    - 避免在业务高峰期执行 DDL 操作；

3. 网络优化 ：

    - 主从同机房部署，降低网络延迟；
    - 增大从库 IO 线程的网络缓冲区（`slave_net_timeout`调大）；

4. 负载分流 ：

    - 从库仅用于备份 / 灾备，单独部署只读实例承担查询；
    - 读写分离中间件（如 MyCat、ShardingSphere）路由延迟敏感的查询到主库；

5. 配置优化 ：

    - 从库关闭慢查询日志、二进制日志（若无需级联复制）；
    - 主库设置`sync_binlog=1` + `innodb_flush_log_at_trx_commit=1`，避免 binlog 丢失导致延迟。

#### 3. 复制中断（Slave_IO_Running/Slave_SQL_Running = No）

##### 现象

- `show slave status\G`中 IO 线程或 SQL 线程状态为 No；
- 从库停止同步，数据不再更新。

##### 常见原因及解决

| 中断类型     | 核心原因                                                     | 解决方法                                                     |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| SQL 线程中断 | 1. 主键 / 唯一键冲突（从库已有主库要插入的主键）；2. 表结构不一致（主库加字段，从库无）；3. 权限不足（从库执行 SQL 时无权限） | 1. 查看`Last_SQL_Error`定位错误；2. 修复冲突数据 / 表结构；3. 跳过错误（`START SLAVE UNTIL SQL_AFTER_MTS_GAPS;` 或 `SET GLOBAL sql_slave_skip_counter=1;`）；4. 重启 SQL 线程（`START SLAVE SQL_THREAD;`） |
| IO 线程中断  | 1. 主库 binlog 文件被删除（从库 IO 线程找不到指定文件）；2. 网络中断 / 防火墙拦截；3. 主库 repl 用户权限不足；4. 主库 dump 线程异常 | 1. 主库配置`expire_logs_days`保留足够久的 binlog（如 7 天）；2. 排查网络 / 防火墙（主库 3306 端口、从库能 ping 通主库）；3. 主库重新授权 repl 用户：`GRANT REPLICATION SLAVE ON *.* TO 'repl'@'从库IP' IDENTIFIED BY '密码';`；4. 重启 IO 线程（`START SLAVE IO_THREAD;`） |

#### 4. binlog 相关问题

##### 问题 1：主库 binlog 未开启 / 格式错误

- 现象：从库 IO 线程无数据可拉取，`Slave_IO_Running=Yes`但`Seconds_Behind_Master`为 NULL；
- 解决：主库修改`my.cnf`开启 binlog（`log_bin=mysql-bin`），设置`binlog_format=ROW`，重启主库后重新配置从库复制。

##### 问题 2：主库 binlog 刷盘策略不安全

- 现象：主库宕机后，未刷盘的 binlog 丢失，从库数据缺失；
- 解决：主库配置`sync_binlog=1`（每次事务刷盘） + `innodb_flush_log_at_trx_commit=1`（InnoDB 事务日志实时刷盘），牺牲少量性能换取数据安全。

##### 问题 3：binlog 文件过大

- 现象：从库同步单个 binlog 文件耗时过长，延迟增加；
- 解决：配置`max_binlog_size=1G`（自动切分 binlog），定期清理过期 binlog（`PURGE BINARY LOGS BEFORE '2025-12-01 00:00:00';`）。

#### 5. 半同步复制的特殊问题

半同步复制（主库需等待至少一个从库确认接收 binlog 后才返回）是异步复制的改进，但易出现以下问题：

- 现象：主库等待从库确认超时，退化为异步复制，`show status like '%semi_sync%'`中`Rpl_semi_sync_master_no_tx`数值增加；
- 原因：从库 IO 线程延迟、网络超时、半同步超时配置过小；
- 解决：
    - 调整`rpl_semi_sync_master_timeout=10000`（超时时间 10 秒，根据业务调整）；
    - 监控半同步状态，若频繁退化，优化从库性能 / 网络；
    - 配置多个半同步从库，提升确认可靠性。

#### 6. 主键 / 唯一键冲突

##### 现象

- SQL 线程中断，`Last_SQL_Error`提示`Duplicate entry 'xxx' for key 'PRIMARY'`；
- 原因：从库手动写入数据、SBR 模式下自增主键规则不一致、主从删除 / 插入操作时序冲突；
- 解决：
    - 禁止从库手动写操作；
    - 主库配置自增主键规则（`auto_increment_increment=2`，`auto_increment_offset=1`；从库`offset=2`）；
    - 删除从库冲突数据行，重启 SQL 线程。

### 三、主从复制最佳实践

1. **复制模式**：优先使用 RBR，避免数据不一致；

2. **从库只读**：强制设置`read_only=1` + `super_read_only=1`；

3. **配置一致性**：主从库的 sql_mode、字符集、时区、表结构必须完全一致；

4. 性能优化 ：

    - 从库开启多线程复制；
    - 从库关闭不必要的日志（如 binlog，若无需级联复制）；
    - 主库拆分大事务，避免 DDL 在高峰期执行；

5. 监控告警 ：
    - 监控`Seconds_Behind_Master`（超过阈值告警）；
    - 监控`Slave_IO_Running`、`Slave_SQL_Running`（状态为 No 立即告警）；
    - 定期用`pt-table-checksum`校验数据一致性；

6. 数据安全 ：

    - 主库开启 binlog 刷盘，配置合理的 binlog 保留时间；
    - 关键业务采用半同步复制，降低数据丢失风险；

7. **灾备**：定期备份从库数据，避免主库宕机后数据无法恢复。

### 四、总结

MySQL 主从复制的核心风险是**数据不一致**和**复制延迟**，生产环境需通过 “合理配置复制模式 + 从库只读 + 性能优化 + 监控告警” 规避；复制中断多由配置 / 数据 / 网络问题导致，需先定位错误日志，再针对性修复，避免盲目跳过错误导致数据差异扩大。




要理解**读己之写、单调读、一致前缀读**的核心价值，首先需要明确背景：分布式系统（如主从复制、分库分表、多节点集群）中，因数据异步复制、网络延迟、节点分片等问题，会出现各种**读不一致**现象（写后读不到、读回退、读乱序）。这三种是分布式系统中最核心的**弱一致性保证**（强一致性性能代价过高），分别针对不同的不一致场景提供解决方案。

### 一、读己之写（Read Your Writes）：解决 “自己写的数据自己读不到” 的问题

#### 1. 核心问题

确保**同一个用户 / 会话**提交的写操作，后续的读操作能立刻看到该写操作的结果，避免 “自己写了但自己看不到” 的矛盾（本质是 “写后读一致性”）。

#### 2. 典型破坏场景（反例）

- 主从复制场景：用户在主库写入一条评论，立刻从从库读取，因从库同步延迟，看不到这条评论；
- 分布式节点场景：用户在节点 A 修改个人昵称，随即访问节点 B，节点 B 未同步该修改，页面仍显示旧昵称；
- 多终端场景：手机端发朋友圈，电脑端立刻刷新看不到（数据未同步到电脑端访问的节点）。

#### 3. 业务价值

解决用户 “操作无效” 的感知问题 —— 比如改昵称、下单、发消息后，自己看不到结果，会误以为操作失败，严重影响体验。

#### 4. 常见实现思路（简要）

- 会话绑定：将用户的读 / 写请求路由到同一个节点；
- 写后强制读主库：用户写入后，一段时间内的读请求直接访问主库；
- 同步等待：写操作后，等待数据同步到至少一个读节点再返回。

### 二、单调读（Monotonic Reads）：解决 “多次读取越读越旧” 的问题

#### 1. 核心问题

确保**同一个用户 / 会话**的多次读操作，不会读到比上一次更旧的数据版本，避免 “读回退”（后读的内容比先读的更早期）。

#### 2. 典型破坏场景（反例）

- 多从库场景：用户第一次读从库 1（已同步到版本 V3），看到 “订单已支付”；第二次读从库 2（仅同步到版本 V1），看到 “订单未支付”，出现数据回退；
- 副本切换场景：负载均衡器将用户的读请求切换到更旧的副本，导致后续读取到更早的数据（比如先看到 “发货中”，再刷新看到 “待发货”）。

#### 3. 业务价值

避免逻辑矛盾 —— 用户感知到 “数据时光倒流”，会疑惑业务状态异常（比如订单已支付又变回未支付、朋友圈动态越刷越少）。

#### 4. 常见实现思路（简要）

- 会话绑定节点：用户会话期间的所有读请求固定到同一个节点；
- 版本号过滤：记录用户上次读取的最小版本号，后续读操作只返回不低于该版本的数据；
- 优先读最新副本：负载均衡器优先路由到同步进度靠前的副本。

### 三、一致前缀读（Consistent Prefix Reads）：解决 “读操作看到乱序的写操作” 的问题

#### 1. 核心问题

确保读取到的一系列写操作，符合它们被提交时的**先后顺序**，不会出现 “后写的先读到，先写的后读到” 或 “缺失前置操作” 的情况（即读取结果满足操作的 “前缀闭合”）。

#### 2. 典型破坏场景（反例）

- 时序操作乱序：用户先执行 W1（创建订单 ID=1001），再执行 W2（支付订单 ID=1001）；因分库复制延迟，读取时只看到 W2（“订单 1001 已支付”），但看不到 W1（“订单 1001 不存在”），逻辑完全矛盾；
- 多表操作乱序：写操作 W1（用户 A 转账给 B）、W2（B 收到转账），读取时看到 W2 却看不到 W1，导致 “B 收到钱但无转账记录”。

#### 3. 业务价值

保证业务逻辑的连贯性 —— 避免 “无前置条件的结果”（比如支付了不存在的订单、发货了未支付的订单），符合用户对操作时序的基本认知。

#### 4. 常见实现思路（简要）

- 全局顺序写入：所有写操作按顺序提交，读取时按同一顺序执行；
- 绑定副本集：读 / 写请求路由到同一个副本集，确保操作顺序一致；
- 等待前缀同步：读取后续操作前，等待前置操作同步完成。

### 四、三者核心对比表

| 一致性保证 | 核心解决的问题             | 典型反例                       | 适用业务场景                     |
| ---------- | -------------------------- | ------------------------------ | -------------------------------- |
| 读己之写   | 自己写的数据自己读不到     | 改昵称后刷新还是旧昵称         | 个人信息修改、发动态、下单       |
| 单调读     | 多次读取越读越旧（读回退） | 先看到订单已支付，再看到未支付 | 订单状态查询、朋友圈刷新         |
| 一致前缀读 | 读操作看到乱序的写操作     | 看到支付记录却看不到对应的订单 | 订单创建 - 支付 - 发货、转账流程 |

### 五、补充说明

1. 这三种均属于**最终一致性**范畴（数据最终会同步一致），比强一致性（如分布式事务、线性一致性）性能更高、实现成本更低，是分布式系统（MySQL 主从、NoSQL、微服务）中最常用的一致性策略；
2. 实际应用中常组合使用：比如电商场景同时需要 “读己之写”（下单后自己能看到订单）+“单调读”（订单状态不回退）+“一致前缀读”（支付必须基于已创建的订单）；
3. 三者均是 “会话级” 的一致性保证（仅针对同一个用户 / 会话），不同用户间无此约束（比如用户 A 写的数据，用户 B 可以延迟看到）。