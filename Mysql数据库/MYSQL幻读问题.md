核心结论：

1. MySQL 可重复读（RR）隔离级别 **不能完全解决幻读**，仅能解决 “快照读” 场景的幻读，无法解决 “当前读” 场景的幻读；
2. 加间隙锁（Gap Lock）+ 行锁（Record Lock）组成的 **Next-Key Lock**（RR 级别默认锁机制），能 **完全解决普通场景的幻读**，但分页查询等特殊场景仍可能出现 “类幻读” 现象；
3. 分页场景的 “类幻读” 本质是数据偏移导致的结果不一致，需通过特殊方案规避，而非锁机制本身的缺陷。

## 一、先明确：什么是幻读？



幻读是指 **同一事务内，两次执行相同的查询语句，第二次查询返回了第一次查询未出现的 “新数据”**（这些新数据是其他事务插入的），导致事务看到 “幻觉般” 的结果。关键前提：两次查询之间，有其他事务插入了符合查询条件的新数据。

## 二、可重复读（RR）隔离级别能否解决幻读？



### 1. RR 级别的核心机制：MVCC 快照读



RR 级别通过 **MVCC（多版本并发控制）** 实现 “可重复读”：

- 事务启动时会生成一个 **Read View（读视图）**，记录当前活跃事务的 ID；
- 事务内的 “快照读”（普通 SELECT，不加锁）会读取 **Read View 可见的历史版本数据**，而非最新数据；
- 其他事务插入的新数据，因事务 ID 不在当前 Read View 中，快照读无法看到，因此避免了 “快照读场景的幻读”。

#### 示例：快照读避免幻读


```
-- 事务 A（RR 级别）
START TRANSACTION;
-- 第一次查询：无数据（快照读，生成 Read View）
SELECT * FROM user WHERE age = 20; -- 结果为空
-- 此时事务 B 插入一条数据：INSERT INTO user(age) VALUES(20); 并提交
-- 第二次查询：仍无数据（快照读，读取历史版本，看不到事务 B 插入的数据）
SELECT * FROM user WHERE age = 20; -- 结果仍为空
COMMIT;
```



### 2. RR 级别的缺陷：当前读场景仍有幻读



“当前读” 是指读取数据最新版本的查询（如 `SELECT ... FOR UPDATE`、`SELECT ... LOCK IN SHARE MODE`，以及 UPDATE/DELETE 语句的隐含查询），这类查询会忽略 MVCC 快照，直接读取最新数据，因此仍可能出现幻读。

#### 示例：当前读触发幻读

```
-- 事务 A（RR 级别）
START TRANSACTION;
-- 第一次查询：无数据（当前读，加行锁，但无匹配行，未加锁）
SELECT * FROM user WHERE age = 20 FOR UPDATE; -- 结果为空
-- 事务 B 插入数据：INSERT INTO user(age) VALUES(20); 并提交
-- 第二次查询：出现新数据（当前读，读取最新版本，看到事务 B 插入的数据）
SELECT * FROM user WHERE age = 20 FOR UPDATE; -- 结果为 (20)，触发幻读
COMMIT;
```



### 结论 1：RR 隔离级别 **不能完全解决幻读**



- 快照读（普通 SELECT）：通过 MVCC 避免幻读；
- 当前读（加锁查询、UPDATE/DELETE）：仍可能出现幻读。

## 三、加间隙锁能完全解决幻读问题吗？



### 1. 间隙锁的作用：阻止插入 “间隙数据”



MySQL InnoDB 在 RR 级别默认启用 **Next-Key Lock** 机制，它由两部分组成：

- 行锁（Record Lock）：锁定已存在的具体行数据；
- 间隙锁（Gap Lock）：锁定 “不存在的数据区间”（如 `age=20` 不存在时，锁定 `(19,21)` 区间），阻止其他事务在该区间插入新数据。

Next-Key Lock 的核心目标是 **“阻止插入符合查询条件的新数据”**，从而从根源上解决当前读场景的幻读。

#### 示例：Next-Key Lock 解决当前读幻读

```
-- 事务 A（RR 级别）
START TRANSACTION;
-- 第一次查询：无数据，但加了间隙锁（锁定 age 在 (19,21) 区间）
SELECT * FROM user WHERE age = 20 FOR UPDATE; -- 结果为空，加 Gap Lock
-- 事务 B 插入数据：INSERT INTO user(age) VALUES(20); 阻塞（被间隙锁拦截）
-- 事务 A 第二次查询：仍无数据（当前读，无新数据插入）
SELECT * FROM user WHERE age = 20 FOR UPDATE; -- 结果为空，无幻读
COMMIT; -- 释放锁，事务 B 插入成功
```



### 2. 间隙锁的局限性：仅对 “连续区间查询” 有效



间隙锁是基于查询条件的 “区间锁定”，若查询条件无法形成连续区间（如用非索引字段查询），InnoDB 会升级为 **表锁**（锁定整个表），此时仍能阻止插入，但性能极差；若查询条件是离散的（如 `age IN (18,20)`），间隙锁会锁定多个离散区间，仍能阻止插入符合条件的数据。

### 结论 2：加间隙锁（Next-Key Lock）**能完全解决普通场景的幻读**



- 前提：查询基于 **索引字段**（避免表锁），且事务隔离级别为 RR；
- 效果：阻止其他事务插入符合查询条件的新数据，当前读和快照读均无幻读；
- 例外：非索引查询导致表锁，虽能阻止插入，但不属于 “间隙锁的精准控制”，且性能不可接受。

## 四、分页情况下能否解决幻读？



分页查询（如 `LIMIT m, n`）是特殊场景：即使启用 Next-Key Lock，仍可能出现 “类幻读” 现象 —— 两次分页查询的结果集不一致（非新数据插入，而是数据偏移导致），但这并非严格意义上的幻读，而是分页逻辑与锁机制的协同问题。

### 1. 分页场景的 “类幻读” 示例



假设表 `user` 有数据：`id=1(age=18)`、`id=2(age=19)`（id 是主键索引），事务 A 执行分页查询：


```
-- 事务 A（RR 级别）
START TRANSACTION;
-- 第一次分页查询：查询第 1 页（LIMIT 0,2），加 Next-Key Lock（锁定 id 区间 (0,3)）
SELECT * FROM user ORDER BY id LIMIT 0,2 FOR UPDATE; -- 结果：id=1、id=2
-- 事务 B 插入数据：INSERT INTO user(id, age) VALUES(3,20); 阻塞（被间隙锁拦截）
-- 事务 C 删除数据：DELETE FROM user WHERE id=1; 执行成功（id=1 被行锁锁定，但事务 A 已读取，MVCC 允许删除历史版本）
-- 事务 A 第二次分页查询：查询第 1 页（LIMIT 0,2）
SELECT * FROM user ORDER BY id LIMIT 0,2 FOR UPDATE; -- 结果：id=2、id=3（事务 B 插入的新数据，事务 C 删除的 id=1 消失）
COMMIT;
```



- 现象：两次分页结果不一致，出现了新数据（id=3），消失了旧数据（id=1）；
- 原因：
  1. 间隙锁阻止了事务 B 插入 id=3（原本阻塞），但事务 C 删除了 id=1 后，事务 A 的锁释放了部分区间，导致事务 B 插入成功；
  2. 分页查询依赖 “偏移量”，数据删除后，后续数据向前偏移，导致第二次查询包含了新插入的数据。

### 2. 分页场景的解决方案（避免 “类幻读”）



“类幻读” 的本质是 “偏移量依赖动态数据”，需通过 “基于主键的精准分页” 替代 “偏移量分页”，结合锁机制确保结果一致：

#### 方案 1：用主键 ID 分页（避免偏移量）



```
-- 事务 A
START TRANSACTION;
-- 第一次查询：记录最后一条数据的主键 id=2
SELECT * FROM user WHERE id > 0 ORDER BY id LIMIT 2 FOR UPDATE; -- 结果：id=1、id=2
-- 事务 B 插入 id=3 阻塞，事务 C 删除 id=1 阻塞（id=1 被行锁锁定）
-- 第二次查询：基于上次的 id=2 分页
SELECT * FROM user WHERE id > 2 ORDER BY id LIMIT 2 FOR UPDATE; -- 结果：无（事务 B 未插入）
COMMIT;
```



- 原理：主键 ID 是唯一且有序的，基于 ID 分页不会因数据删除 / 插入导致偏移，结合 Next-Key Lock 阻止新数据插入，确保结果一致。

#### 方案 2：分页查询时锁定全表（适用于小表）




```
-- 事务 A
START TRANSACTION;
LOCK TABLES user WRITE; -- 锁定全表，阻止插入/删除
SELECT * FROM user ORDER BY id LIMIT 0,2; -- 分页查询
-- 事务 B 插入/删除均阻塞
SELECT * FROM user ORDER BY id LIMIT 0,2; -- 结果一致
UNLOCK TABLES;
COMMIT;
```



- 原理：表锁完全阻止其他事务修改数据，适合数据量小、并发低的场景。

### 结论 3：分页场景 **不能仅靠间隙锁解决 “类幻读”**



- 偏移量分页（`LIMIT m,n`）：即使加间隙锁，仍可能因数据删除 / 插入导致结果偏移，出现 “类幻读”；
- 解决方案：用 “主键 ID 分页” 替代偏移量分页，结合 Next-Key Lock，可完全避免分页场景的结果不一致；小表可直接用表锁。

## 五、终极总结



1. **RR 隔离级别与幻读**：仅解决快照读幻读，当前读仍有幻读，不能完全解决；

2. **间隙锁（Next-Key Lock）与幻读**：RR 级别下，基于索引的查询通过 Next-Key Lock 能完全解决普通场景的幻读（包括当前读）；

3. **分页场景**：偏移量分页仍可能出现 “类幻读”，需用 “主键 ID 分页”+ Next-Key Lock 规避；



   - 普通场景：用 RR 隔离级别 + 索引查询（依赖 Next-Key Lock），完全解决幻读；
   - 分页场景：优先使用 “主键 ID 分页”，避免偏移量导致的结果不一致；
   - 严格避免幻读：升级到串行化（Serializable）隔离级别（强制所有查询加表锁，性能差，不推荐高并发场景）。
