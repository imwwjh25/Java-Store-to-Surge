### 一、什么是死锁？

死锁是 **多线程 / 进程并发场景** 中出现的一种严重问题：多个线程 / 进程互相持有对方所需的资源，且都不愿释放自己的资源，导致所有线程 / 进程都陷入永久阻塞，无法继续执行。

举个通俗例子：线程 A 持有锁 1，想要获取锁 2；线程 B 持有锁 2，想要获取锁 1。两者互相等待对方释放资源，永远无法推进，这就是死锁。

### 二、死锁的四个必要条件（缺一不可）

死锁的发生必须同时满足以下 4 个条件，只要破坏其中任意一个，就能避免死锁：

1. **互斥条件**：资源只能被一个线程 / 进程独占使用（比如一把锁同一时间只能被一个线程持有），无法共享。
2. **请求与保持条件**：线程 / 进程已经持有至少一个资源，又尝试请求其他线程持有的资源，且在请求过程中不释放自己已持有的资源。
3. **不可剥夺条件**：线程 / 进程持有的资源不能被强制剥夺，只能由持有者主动释放（比如锁不能被其他线程 “抢走”）。
4. **循环等待条件**：多个线程 / 进程之间形成闭环的资源等待链（比如 A 等 B 的资源，B 等 C 的资源，C 等 A 的资源）。

### 三、如何解除死锁？（已发生死锁时的解决手段）

解除死锁的核心是 “打破死锁的四个必要条件”，常用手段如下：

#### 1. 资源剥夺法（破坏 “不可剥夺条件”）

- 核心逻辑：强制剥夺部分线程持有的资源，分配给处于死锁状态的其他线程，让等待链断裂。
- 具体实现：
    - 对持有资源的线程设置 “超时时间”，超时未完成任务则强制释放资源；
    - 优先级策略：剥夺低优先级线程的资源，分配给高优先级线程（需注意优先级反转问题）。
- 适用场景：资源类型较少、线程优先级明确的场景。

#### 2. 撤销进程 / 线程法（破坏 “请求与保持条件”）

- 核心逻辑：直接终止部分死锁中的线程 / 进程，释放其持有的资源，让剩余线程正常推进。
- 两种策略：
    - 最小代价撤销：优先终止 “占用资源少、剩余任务少” 的线程，减少系统损失；
    - 全面撤销：若死锁涉及线程少，可直接终止所有死锁线程（简单但粗暴）。
- 注意：需处理线程终止后的资源清理、数据一致性问题（如数据库事务回滚）。

#### 3. 进程回退法（破坏 “循环等待条件”）

- 核心逻辑：让死锁中的线程回退到 “未请求冲突资源” 的安全状态，重新执行，避免循环等待。
- 关键前提：系统需记录线程的 “资源请求历史” 和 “状态快照”，支持回退操作。
- 适用场景：对数据一致性要求高、线程执行流程可复现的场景（如分布式事务）。

#### 4. 手动干预法（应急方案）

- 核心逻辑：通过人工介入（如运维工具、命令行）检测死锁（如 Java 的`jstack`命令），手动终止死锁线程或释放资源。
- 适用场景：紧急故障处理，不适合自动化系统。

### 补充：死锁的 “预防” 比 “解除” 更重要

解除死锁是 “事后补救”，而预防死锁是 “事前规避”，更高效且无业务损失，常用预防手段：

1. 破坏 “循环等待条件”：给所有资源编号，线程必须按 “递增顺序” 请求资源（如先锁 1 后锁 2，不可反向）；
2. 破坏 “请求与保持条件”：线程需一次性申请所有所需资源，申请不到则不启动，启动后不释放资源直到结束；
3. 破坏 “不可剥夺条件”：资源设置超时机制，超时自动释放（如 Java 的`Lock.tryLock(timeout)`）。

### 总结

- 死锁的本质是 “资源竞争 + 不当的请求顺序”，四个必要条件缺一不可；
- 解除死锁的核心是 “打破任意一个必要条件”，优先选择 “资源剥夺法” 或 “最小代价撤销法”，减少系统损失；
- 实际开发中，优先通过 “资源编号顺序请求”“超时锁”“一次性申请资源” 等方式预防死锁，避免陷入被动。