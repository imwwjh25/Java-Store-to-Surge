## 一、先明确：InnoDB 中幻读的核心场景（必须先分清）



幻读仅发生在 **「当前读」场景**（如 `SELECT ... FOR UPDATE`、`UPDATE`、`DELETE`，这些操作会读取最新的物理数据，并加锁），而 **「快照读」场景**（普通 `SELECT`，基于 MVCC 读取历史版本）不会出现幻读（因为快照读隔离了其他事务的修改）。

举个典型幻读场景（事务 A 执行当前读）：

1. 事务 A（RR 隔离级别）：`SELECT * FROM user WHERE age > 20 FOR UPDATE` → 返回 2 行（id=1、id=2）；

2. 事务 B（并发）：`INSERT INTO user (age) VALUES (25)` → 提交；

3. 事务 A 再次执行：

   ```
   SELECT * FROM user WHERE age > 20 FOR UPDATE
   ```



→ 返回 3 行（多了 id=3）；

此时事务 A 出现幻读 —— 同一查询条件，前后结果集行数不一致。

## 二、MVCC 为什么不能解决幻读？



MVCC（多版本并发控制）的核心是「通过版本链 + Read View 实现快照读」，它的设计目标是 **解决「不可重复读」**，而非幻读，原因如下：

### 1. MVCC 的工作原理限制



- MVCC 仅对「快照读」生效：普通 `SELECT` 会通过 Read View 读取事务启动时的「数据快照」（历史版本），即使其他事务插入 / 删除了数据，快照读也看不到这些新修改，因此不会出现幻读；
- 但 MVCC 对「当前读」无效：当前读（`SELECT ... FOR UPDATE`、`UPDATE` 等）会强制读取「最新的物理数据」（而非快照），并加锁防止其他事务修改已读取的行 —— 但 MVCC 没有任何机制阻止其他事务「插入新的符合查询条件的行」。

### 2. 幻读的核心是「插入新行」，MVCC 无法拦截



MVCC 的版本链仅跟踪「已有数据的修改 / 删除版本」，无法感知「新插入的行」：

- 事务 A 第一次当前读时，读取到 id=1、id=2（最新数据）；
- 事务 B 插入 id=3（新行，没有历史版本），提交后，该数据成为最新物理数据；
- 事务 A 第二次当前读时，会读取最新物理数据，自然包含 id=3，导致幻读；
- MVCC 无法阻止「新行插入」，因为新行不在事务 A 启动时的快照中，且当前读必须读最新数据。

### 结论：MVCC 只解决「快照读的不可重复读」，对「当前读的幻读」无任何防护。



## 三、临键锁（Next-Key Lock）为什么不能完全解决幻读？



临键锁是 InnoDB RR 隔离级别下默认的锁机制，它是「记录锁 + 间隙锁」的组合，核心目标是 **解决「不可重复读」和「部分幻读」**，但无法解决「所有幻读场景」，原因如下：

### 1. 临键锁的工作原理



- 临键锁会锁定「查询条件覆盖的记录 + 记录之间的间隙」，防止其他事务在间隙中插入新行（这是它能防部分幻读的原因）；
- 例如：查询 `age > 20 FOR UPDATE`，假设表中已有 age=21、23 的行，临键锁会锁定「23 之后的间隙」（防止插入 25、26 等），同时锁定 21、23 这两行。

### 2. 临键锁的局限性：无法锁定「查询条件之外的间隙」



临键锁的锁定范围是「基于当前表中已有的数据分布」，如果其他事务插入的新行「不在当前查询的间隙范围内」，但「符合查询条件」，临键锁无法拦截，导致幻读。

#### 典型案例（临键锁失效的幻读）：



假设 `user` 表中 `age` 字段的现有数据为 [18, 22, 25]，索引为 B+ 树结构，间隙为 (-∞,18)、(18,22)、(22,25)、(25,+∞)。

1. 事务 A（RR 级别）：`SELECT * FROM user WHERE age BETWEEN 20 AND 30 FOR UPDATE` → 匹配 age=22、25，临键锁会锁定 (22,25)、(25,+∞) 间隙，以及 22、25 记录；
2. 事务 B（并发）：`INSERT INTO user (age) VALUES (19)` → 19 落在间隙 (18,22)，而事务 A 的查询条件是 20-30，临键锁未锁定 (18,22) 间隙（因为当前表中 18-22 之间没有符合 20-30 的记录），所以事务 B 可以成功插入；
3. 事务 A 再次执行 `SELECT * FROM user WHERE age BETWEEN 20 AND 30 FOR UPDATE` → 此时 19 不符合条件，但如果事务 B 插入的是 `age=21`（仍在 (18,22) 间隙），则 21 符合 20-30 的条件，事务 A 第二次查询会返回 21、22、25 → 出现幻读！

### 3. 核心原因：临键锁的锁定范围是「动态的」，依赖当前数据分布



- 临键锁只能锁定「当前查询条件匹配到的记录及相邻间隙」，无法预判「未来可能插入的、符合查询条件的新行所在的间隙」；
- 只要新行插入的间隙「不在当前锁定范围内」，但符合查询条件，就会导致幻读 —— 临键锁无法提前锁定所有「可能符合条件的间隙」（否则会导致锁范围过大，性能崩溃）。

### 结论：临键锁能解决「基于已有数据间隙的幻读」（如插入 26、27 到 (25,+∞) 间隙会被拦截），但无法解决「插入到未锁定间隙但符合查询条件的幻读」，因此不能完全解决幻读。



## 四、真正能解决幻读的方案是什么？



要彻底解决幻读，需针对「当前读的插入 / 删除场景」进行全量防护，有两种方案：

1. **升级到 Serializable 隔离级别**：InnoDB 最高隔离级别，会强制所有事务串行执行，禁止并发插入 / 删除，从根源上杜绝幻读 —— 但性能极差，很少使用；
2. **使用 Gap Lock + 覆盖所有可能的间隙**：手动扩大锁范围（如 `SELECT * FROM user WHERE age > 0 FOR UPDATE`，锁定所有间隙），但会导致锁冲突严重，性能开销大；
3. **业务层防护**：通过唯一索引、乐观锁（版本号）等机制，阻止并发插入符合条件的新行 —— 这是实际开发中最常用的方案。

## 五、总结



1. 幻读的核心是「当前读场景下，其他事务插入 / 删除符合查询条件的新行，导致结果集行数不一致」；
2. MVCC 不能解决幻读：MVCC 仅对快照读生效（隔离历史版本），对当前读无效，无法阻止新行插入；
3. 临键锁不能完全解决幻读：临键锁仅锁定「当前数据分布下的匹配记录及相邻间隙」，无法预判并锁定「未来可能插入符合条件新行的间隙」，存在漏锁场景；
4. 彻底解决幻读的方案：Serializable 隔离级别（不推荐）、业务层防护（推荐）。

简单说：MVCC 管「快照读的一致性」，临键锁管「已有数据的修改 / 间隙插入防护」，但都管不了「未锁定间隙的新行插入」—— 这是幻读无法被两者完全解决的核心。