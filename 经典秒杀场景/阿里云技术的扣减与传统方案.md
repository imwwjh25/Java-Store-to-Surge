要彻底搞懂 **Redis 分桶合并扣减方案** 与 **传统 Redis 分桶扣减方案** 的区别，我们可以从 **核心设计理念、库存存储载体、扣减链路、一致性保障、适用场景** 这 5 个维度对比，结合你熟悉的订单 / 库存业务场景拆解，**一句话总结核心差异**：

> 传统方案把 Redis 当「库存数据库」用，直接存库存数值；新方案把 Redis 当「扣减计数器 / 防超卖屏障」用，库存的最终一致性完全靠 DB 明细和合并提交兜底。

### 一、先回顾传统 Redis 分桶扣减方案（对比基准）



传统方案是为了解决 **DB 单点热点扣减瓶颈** 而生，核心思路是 **库存分层**：把 DB 中的库存数据，拆分到多个 Redis 分桶中，下单时直接扣 Redis，异步同步到 DB。

#### 1. 核心流程



```
1. 初始化：将 DB 库存 N 拆分为 k 个 Redis 分桶，每个分桶库存 = N/k
2. 下单扣减：路由到任意分桶 → Redis DECR 扣减 → 判断结果 ≥0 → 扣减成功
3. 异步同步：定时任务将 Redis 分桶库存汇总，更新到 DB
```



#### 2. 核心痛点（也是新方案要解决的）



| 痛点                    | 具体原因                                                     | 业务影响（订单场景）                       |
| ----------------------- | ------------------------------------------------------------ | ------------------------------------------ |
| **无法避免少卖**        | Redis 扣减超时 / 失败时，应用层不敢确认结果（怕超卖），只能默认扣减失败；回补时默认成功 | 明明有库存，用户却下单失败，损失订单量     |
| **无法避免超卖风险**    | Redis 是内存存储，宕机 / 数据丢失后，无法追溯已扣减的库存；异步同步到 DB 存在延迟 | 实际库存已空，但 Redis 还能扣减，导致超卖  |
| **不支持复杂库存模型**  | 仅用 `INCR/DECR` 维护一个数值，无法处理 `可售库存(sq)→预扣库存(wq)→占用库存(oq)` 的流转 | 订单下单、付款、取消的库存生命周期无法管理 |
| **强依赖 Redis 稳定性** | Redis 挂了，整个扣减链路直接瘫痪                             | 热点抢购时 Redis 故障 = 业务停摆           |

### 二、新方案（Redis 分桶 + DB 合并提交）的核心改进



新方案的**核心思想**是：**Redis 只负责「快速拦截 + 防超卖」，DB 负责「最终一致性 + 库存流转」**，通过 **预锁库存、扣减明细、合并提交** 三个关键设计，解决传统方案的所有痛点。

我们用 **对比表格** 直观展示差异：

| 对比维度           | 传统 Redis 分桶扣减方案                                      | 新方案（Redis 分桶 + DB 合并提交）                           |
| ------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **库存存储载体**   | 核心库存存在 Redis 分桶，DB 仅作为「备份」，异步同步         | 核心库存存在 DB，Redis 分桶仅存「预锁库存的计数」，不存储真实库存 |
| **扣减核心依据**   | 以 Redis DECR/INCR 的结果为准                                | 以 DB 中的「扣减明细」为准，Redis 扣减只是「前置校验」       |
| **扣减链路**       | 扣 Redis → 成功则下单 → 异步同步 DB（Redis 是主流程，DB 是兜底） | 1. **预锁库存**：DB 把 sq 锁到 lq，同步 lq 到 Redis 分桶2. **下单扣减**：扣 Redis → 成功则写 DB 明细 → 扣减成功3. **合并提交**：延迟 1s 扫描明细 → 批量更新 DB 库存（DB 是主流程，Redis 是加速） |
| **一致性保障机制** | 依赖 Redis 数据完整性 + 异步同步，存在数据不一致风险         | 三层保障：1. DB 层面：`where sq-lq-δq>0` 防止超卖2. Redis 层面：分桶库存不允许负数3. 明细层面：以 DB 明细总和为准，Redis 丢数据也能追溯 |
| **Redis 宕机影响** | 完全无法扣减，链路瘫痪                                       | 降级走传统 DB 扣减流程，不影响业务                           |
| **支持的库存模型** | 仅支持「单一数值库存」（如限购次数、权益数量）               | 支持 `sq→wq→oq` 复杂流转（适配订单下单 / 付款 / 取消全流程） |
| **适用场景**       | 非实物库存（如优惠券、限购），允许少量少卖 / 超卖            | 实物库存（如直播抢购商品），要求 **绝对不超卖、不少卖**      |

### 三、关键细节对比：两个方案的「灵魂差异」



#### 1. 「库存是谁的？」—— 存储载体的本质区别



- **传统方案**：Redis 是「主库存」，DB 是「从库存」。

  比如商品库存 1000，拆成 10 个 Redis 分桶，每个桶 100。用户下单扣的是 Redis 里的 100，DB 里的 1000 只是个「影子数据」，等异步任务同步。

  > 风险：Redis 宕机，10 个桶的库存数据全丢，不知道已经扣了多少，只能重置，必然少卖 / 超卖。

- **新方案**：DB 是「主库存」，Redis 是「临时计数器」。

  比如商品库存 1000，DB 先锁 500 到 lq（预锁库存），然后把 500 同步到 Redis 分桶。用户下单扣的是 Redis 里的 500，但**扣减是否有效，取决于有没有写入 DB 明细**。

  > 关键：Redis 只是「拦截器」，防止同一时间 500 个请求都打到 DB；即使 Redis 丢了 500 的计数，只要扫 DB 明细，就能知道实际扣了多少（比如 300），然后批量更新 DB 库存 1000-300=700。

#### 2. 「扣减成功的标准是什么？」—— 核心依据的区别



- **传统方案**：Redis DECR 后结果 ≥0 → 扣减成功。

  比如 Redis 分桶库存 10，用户下单扣 1，结果 9 ≥0 → 成功。但如果 Redis 扣减时网络超时，应用层不敢确定是扣成了 9 还是没扣，只能返回失败 → **明明有库存，用户下单失败（少卖）**。

- **新方案**：**DB 扣减明细写入成功 → 扣减成功**。

  流程是：扣 Redis（成功）→ 写 DB 明细（订单号、扣减数量、分桶 ID）→ 扣减成功。

    - 如果 Redis 扣减超时：直接降级走 DB 扣减，不丢单；
    - 如果 Redis 数据丢失：扫 DB 明细就能统计出实际扣减数量，不会少卖；
    - 如果合并提交时并发扫描明细：Redis 扣减屏障会拦截，防止漏扫导致超卖。

#### 3. 「复杂库存场景怎么支持？」—— 模型适配的区别



你的业务涉及 **订单处理**，必然需要库存的生命周期管理：

- 下单时：`sq（可售）→ wq（预扣）`

- 付款时：`wq（预扣）→ oq（占用）`

- 取消时：`wq（预扣）→ sq（可售）`

- **传统方案**：用 Redis 的一个数值根本无法区分 sq/wq/oq，只能记录「剩余库存」，无法支持订单的全流程。

- **新方案**：通过 **DB 扣减明细** 记录库存流转的每一步，比如：

    - 下单明细：`订单A，扣 sq 1，分桶1`

    - 付款明细：`订单A，wq 转 oq 1`

    - 取消明细：```订单A，wq 转回 sq 1```同时 DB 层面维护 sq/wq/oq 三个字段，完全适配订单业务的复杂库存模型。

### 四、一句话总结区别



传统方案是 **「Redis 当家，DB 打杂」**—— 性能高但一致性差；

新方案是 **「DB 当家，Redis 打杂」**—— 既保留了 Redis 的高性能，又通过 DB 明细和合并提交保证了强一致性，完美解决热点抢购场景的「不超卖、不少卖、高性能」需求。