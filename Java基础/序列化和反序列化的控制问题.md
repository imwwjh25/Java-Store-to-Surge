要搞懂这个问题，我们需要先理清 **序列化、`transient` 关键字的作用**，再给出 “不保存某些数据” 的具体实现方案，最后补充序列化的核心细节，帮你彻底理解。

## 一、先明确两个基础概念

### 1. 什么是序列化？

序列化是指将 **Java 对象** 转换为 **字节序列**（二进制数据）的过程，目的是：

- 持久化存储（如写入文件、存入数据库 BLOB 字段）；
- 网络传输（如 RPC 调用、分布式系统间传递对象）。

反序列化则是序列化的逆过程：将字节序列恢复为 Java 对象。

#### 序列化的核心要求：

- 被序列化的类必须实现 `java.io.Serializable` 接口（这是一个标记接口，无任何抽象方法，仅用于告知 JVM “该类支持序列化”）；
- 类的所有非静态成员变量（默认）都会被序列化（静态变量、 transient 变量除外）；
- 若类的父类实现了 `Serializable`，则子类自动支持序列化；若父类未实现，子类需手动处理父类的序列化（重写 `writeObject`/`readObject`）。

### 2. 什么是 `transient`？

`transient`（瞬时关键字）是 Java 中的一个修饰符，仅用于修饰 **成员变量**（不能修饰类、方法、局部变量），核心作用是：

- 标记该变量 **不参与序列化过程**，即序列化时会忽略该变量，反序列化后该变量会被赋默认值（基本类型默认 0/false，引用类型默认 null）；
- `transient` 仅对 **对象的非静态成员变量** 有效，静态变量（`static`）本身就不会被序列化（无论是否加 `transient`）。

## 二、序列化时 “不保存某些数据” 的 3 种方案（按常用度排序）

### 方案 1：用 `transient` 修饰变量（最简单、最常用）

直接在不需要序列化的成员变量前加 `transient` 关键字，JVM 序列化时会自动跳过该变量。

#### 代码示例：










```java
import java.io.*;

// 实现 Serializable 接口，支持序列化
class User implements Serializable {
    private static final long serialVersionUID = 1L; // 序列化版本号（后面解释）
    
    private String username; // 会被序列化
    private transient String password; // 加 transient，不被序列化
    private transient int age; // 基本类型加 transient，不被序列化
    private static String staticField = "静态变量"; // 静态变量，默认不序列化（加不加 transient 都一样）

    // 构造器、getter/setter
    public User(String username, String password, int age) {
        this.username = username;
        this.password = password;
        this.age = age;
    }

    @Override
    public String toString() {
        return "User{" +
                "username='" + username + '\'' +
                ", password='" + password + '\'' +
                ", age=" + age +
                ", staticField='" + staticField + '\'' +
                '}';
    }
}

// 测试序列化/反序列化
public class TransientDemo {
    public static void main(String[] args) throws IOException, ClassNotFoundException {
        // 1. 序列化：将 User 对象写入文件
        User user = new User("张三", "123456", 20);
        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("user.txt"));
        oos.writeObject(user);
        oos.close();
        System.out.println("序列化前：" + user); // 输出：User{username='张三', password='123456', age=20, staticField='静态变量'}

        // 2. 修改静态变量（验证静态变量不序列化）
        User.staticField = "修改后的静态变量";

        // 3. 反序列化：从文件恢复 User 对象
        ObjectInputStream ois = new ObjectInputStream(new FileInputStream("user.txt"));
        User deserializedUser = (User) ois.readObject();
        ois.close();
        System.out.println("反序列化后：" + deserializedUser); 
        // 输出：User{username='张三', password='null', age=0, staticField='修改后的静态变量'}
    }
}
```

#### 结果分析：

- `password`（`transient` 修饰）：反序列化后为 `null`（未被保存）；
- `age`（`transient` 修饰的基本类型）：反序列化后为 `0`（未被保存）；
- `username`（无 `transient`）：正常序列化 / 反序列化，值不变；
- `staticField`（静态变量）：反序列化后的值是 “修改后的静态变量”（而非序列化时的 “静态变量”），证明静态变量不参与序列化。

#### 适用场景：

- 敏感数据（如密码、token）：不想在网络传输 / 持久化时泄露；
- 临时数据（如缓存、计算结果）：无需长期保存，反序列化后可重新计算；
- 不可序列化的变量（如 `Thread` 对象、`Socket` 连接）：避免序列化时抛出 `NotSerializableException`。

### 方案 2：重写 `writeObject` 方法（自定义序列化逻辑）

如果需要更灵活的控制（比如某些变量在特定条件下不序列化，或序列化时对数据加密），可以在序列化类中重写 `private void writeObject(ObjectOutputStream out) throws IOException` 方法，手动控制哪些变量写入字节流。

#### 核心原理：

- 当类中存在 `writeObject` 方法时，JVM 会优先调用该方法进行序列化，而非默认的 “全量序列化”；
- 配合 `ObjectOutputStream` 的 `writeObject()`（写入变量）和 `defaultWriteObject()`（写入默认要序列化的变量）实现灵活控制。

#### 代码示例：






```java
class User implements Serializable {
    private static final long serialVersionUID = 1L;
    private String username;
    private String password; // 不加 transient，但想在序列化时忽略
    private int age;

    // 重写 writeObject：自定义序列化逻辑
    private void writeObject(ObjectOutputStream out) throws IOException {
        // 1. 写入默认要序列化的变量（如 username、age）
        out.defaultWriteObject();
        // 2. 不写入 password（相当于忽略该变量，效果等同于加 transient）
        // out.writeObject(password); // 注释掉，不写入 password
    }

    // 重写 readObject：反序列化时需对应 writeObject 的逻辑（否则变量为默认值）
    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
        // 1. 读取默认序列化的变量
        in.defaultReadObject();
        // 2. 不读取 password（反序列化后 password 为 null）
        // this.password = (String) in.readObject();
    }

    // 构造器、toString 等（同上）
}
```

#### 结果：

反序列化后 `password` 为 `null`（未被序列化），效果和加 `transient` 一致，但更灵活（比如可添加条件：`if (age > 18) out.writeObject(password)`，仅成年用户序列化密码）。

#### 适用场景：

- 条件性忽略变量（如某些变量仅在特定场景下需要序列化）；
- 序列化时对数据加工（如密码加密后再序列化，反序列化时解密）。

### 方案 3：实现 `Externalizable` 接口（完全自定义序列化）

`Externalizable` 是 `Serializable` 的子接口，要求类必须实现 `writeExternal(ObjectOutput out)` 和 `readExternal(ObjectInput in)` 两个方法，**完全手动控制序列化 / 反序列化的所有细节**（默认不会序列化任何变量，必须手动写入 / 读取）。

#### 代码示例：






```java
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;

class User implements Externalizable {
    private String username;
    private String password; // 要忽略的变量
    private int age;

    // 注意：实现 Externalizable 必须有无参构造器（反序列化时会调用）
    public User() {}

    public User(String username, String password, int age) {
        this.username = username;
        this.password = password;
        this.age = age;
    }

    // 完全自定义序列化：只写入 username 和 age，忽略 password
    @Override
    public void writeExternal(ObjectOutput out) throws IOException {
        out.writeObject(username); // 写入 username
        out.writeInt(age); // 写入 age
        // 不写入 password，即忽略该变量
    }

    // 完全自定义反序列化：必须和 writeExternal 的顺序一致
    @Override
    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
        this.username = (String) in.readObject(); // 读取 username
        this.age = in.readInt(); // 读取 age
        // 不读取 password，反序列化后为 null
    }

    // toString 方法（同上）
}
```

#### 结果：

反序列化后 `password` 为 `null`，`username` 和 `age` 正常恢复。

#### 特点：

- 灵活性最高，但代码复杂度也最高（需手动处理所有变量的写入 / 读取，包括顺序一致性）；
- 必须提供无参构造器（反序列化时 JVM 会通过无参构造器创建对象，再调用 `readExternal` 赋值）；
- 适用于需要深度定制序列化逻辑的场景（如复杂对象、跨平台序列化）。

## 三、关键补充：序列化版本号（`serialVersionUID`）

在序列化类中，通常会显式声明 `private static final long serialVersionUID`，作用是：

- 唯一标识类的序列化版本：当类的结构发生变化（如新增 / 删除变量、修改父类）时，若 `serialVersionUID` 不变，反序列化仍能兼容旧版本的字节序列（未修改的变量能正常恢复）；
- 若不显式声明，JVM 会根据类的结构（变量、方法、父类等）自动计算一个 `serialVersionUID`，一旦类结构变化，计算结果会改变，导致反序列化时抛出 `InvalidClassException`（“类版本不兼容”）。

#### 建议：

- 所有实现 `Serializable` 的类，都显式声明 `serialVersionUID`（如 `1L`）；
- 类结构发生 “兼容性变化”（如新增可选变量）时，保持 `serialVersionUID` 不变；
- 类结构发生 “不兼容变化”（如删除关键变量、修改变量类型）时，修改 `serialVersionUID`（避免误兼容）。

## 四、常见误区

1. **`transient` 修饰静态变量无效**：静态变量属于类，而非对象，本身不参与序列化，加 `transient` 也不会改变这一点；
2. **`transient` 修饰的变量反序列化后为默认值**：基本类型为 0/false，引用类型为 null，需手动初始化（如在 `readObject` 中赋值）；
3. **被 `transient` 修饰的变量仍可手动序列化**：通过重写 `writeObject` 方法，可强制将 `transient` 变量写入字节流（`transient` 仅影响默认序列化）；
4. **父类未实现 `Serializable`，子类实现时，父类的变量不会被序列化**：若父类需要序列化，需让父类也实现 `Serializable`，或在子类的 `writeObject`/`readObject` 中手动处理父类变量。

## 五、总结

序列化时 “不保存某些数据” 的核心方案：

1. **优先用 `transient`**：简单高效，适合大多数场景（敏感数据、临时数据、不可序列化变量）；
2. **次选重写 `writeObject`**：灵活控制，支持条件性忽略、数据加工；
3. **最后用 `Externalizable`**：完全自定义，适合复杂场景（代码复杂度高，谨慎使用）。

核心原则：根据需求选择方案，优先保证代码简洁性，同时注意序列化的兼容性（显式声明 `serialVersionUID`）和数据安全性（敏感数据务必忽略或加密）。