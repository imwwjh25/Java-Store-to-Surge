秒杀场景的超卖问题，核心矛盾是 **“高并发请求” 与 “库存数据一致性”** 的冲突 —— 短时间内数万 / 数十万请求同时扣减库存，若未做好原子性控制，极易出现 “库存为负” 的超卖问题。解决方案需兼顾 **一致性（不超卖）、高性能（扛住高并发）、高可用（不宕机）**，按 “底层兜底→中间优化→上层防护” 的层级设计，以下是具体落地方案（从简单到复杂，覆盖不同流量规模）：

### 一、核心原则

1. 库存扣减必须保证 **原子性**（要么扣减成功，要么失败，无中间状态）；
2. 尽量将请求拦截在 “上游”（如限流、缓存预扣减），减少数据库压力；
3. 允许 “最终一致性”（秒杀场景下，短期缓存与数据库不一致可接受，最终需对齐）；
4. 避免单点故障和死锁，确保系统高可用。

### 二、具体解决方案（按优先级排序）

#### 1. 底层兜底：数据库层（保证最终一致性，杜绝超卖）

数据库是库存的 “最终数据源”，必须做好兜底，即使缓存失效也不会超卖。

##### （1）乐观锁（推荐，适配中高并发）

- 原理：基于版本号或库存字段本身，实现 “CAS（Compare And Swap）” 机制，仅当库存符合预期时才扣减。

- 实现方式：

    - 方案 1：库存字段 + 版本号 表结构新增```version```字段，扣减时校验版本号，确保并发下仅一个线程成功：


```sql
    -- 扣减库存：仅当库存>0且版本号匹配时执行，返回影响行数
    UPDATE seckill_goods 
    SET stock = stock - 1, version = version + 1 
    WHERE goods_id = ? AND stock > 0 AND version = ?;
```

    

业务逻辑：若影响行数 = 1，扣减成功；若 = 0，扣减失败（库存不足或版本号不匹配），可重试 1-2 次。

- 方案 2：库存字段自校验（无版本号） 简化方案，直接通过库存字段判断，避免版本号维护：

 
    

    

    

    

    

```sql
    UPDATE seckill_goods 
    SET stock = stock - 1 
    WHERE goods_id = ? AND stock > 0;
```

    

核心：利用数据库行锁的原子性，确保 “判断库存 + 扣减” 是一个原子操作。

- 优点：无锁阻塞，并发性能高，适合秒杀高流量；

- 缺点：重试可能导致部分请求失败（需前端友好提示 “手慢了”）。

##### （2）悲观锁（仅适配低并发）

- 原理：扣减库存前先加行锁，阻塞其他线程，确保同一时间仅一个线程操作库存。

- 实现方式：








```sql
  -- 先查询并加行锁（FOR UPDATE），再扣减
  BEGIN;
  SELECT stock FROM seckill_goods WHERE goods_id = ? FOR UPDATE;
  -- 业务层判断库存>0，再执行扣减
  UPDATE seckill_goods SET stock = stock - 1 WHERE goods_id = ?;
  COMMIT;
```



- 优点：逻辑简单，绝对不会超卖；

- 缺点：高并发下锁竞争严重，导致大量请求阻塞、超时，甚至数据库雪崩，不适合秒杀场景。

##### （3）唯一索引防重（兜底方案）

- 原理：通过订单表的唯一索引，杜绝同一用户 / 同一商品的重复下单（间接避免超卖）。

- 实现方式：在订单表```seckill_order```中，给```user_id + goods_id```建立唯一索引：









```sql
  ALTER TABLE seckill_order ADD UNIQUE KEY uk_user_goods (user_id, goods_id);
 ```



- 作用：即使前面的库存控制失效，重复下单时数据库会报唯一索引冲突，拒绝插入订单，避免因重复下单导致的超卖。

#### 2. 中间优化：缓存层（扛高并发，减少数据库压力）

秒杀的核心是 “读多写少”，用 Redis 缓存库存，提前拦截无效请求，仅将有效请求转发到数据库。

##### （1）Redis 预扣减 + Lua 脚本（核心方案）

- 原理：将商品库存提前加载到 Redis（缓存预热），用 Lua 脚本实现 “判断库存 + 扣减库存” 的原子操作，避免并发问题。

- 实现步骤：

    1. 缓存预热：秒杀开始前，将数据库中的库存同步到 Redis，如 `SET seckill:stock:goodsId 100`（100 为库存数）；
    2. 预扣减：用户下单时，先调用 Lua 脚本扣减 Redis 库存，扣减成功再请求数据库创建订单；
    3. 异步同步：订单创建成功后，异步同步数据库库存（最终一致性）；若订单创建失败，回滚 Redis 库存。

- Lua 脚本示例（原子扣减）：










```lua
  -- 传入参数：goodsId（商品ID）
  local stockKey = "seckill:stock:" .. ARGV[1]
  -- 1. 获取当前库存
  local stock = redis.call("GET", stockKey)
  if not stock or tonumber(stock) <= 0 then
      return -1  -- 库存不足，扣减失败
  end
  -- 2. 扣减库存
  redis.call("DECR", stockKey)
  return 1  -- 扣减成功
 ```



- 优点：Redis 单线程执行 Lua 脚本，原子性有保障；Redis 并发性能远超数据库，能扛住每秒 10 万 + 请求；

- 缺点：需处理 Redis 与数据库的一致性（如 Redis 宕机、订单创建失败回滚）。

##### （2）Redis 分布式锁（解决跨节点并发问题）

- 原理：若秒杀系统是集群部署，多个节点可能同时操作 Redis 库存，用分布式锁确保同一商品的库存扣减仅一个节点执行。

- 实现方式：用 Redis Redlock 或基于```SET NX EX```命令实现分布式锁：







```java
  // 加锁：NX（不存在才设置）、EX（过期时间），避免死锁
  Boolean lock = redisTemplate.opsForValue().setIfAbsent("lock:seckill:goodsId", "value", 5, TimeUnit.SECONDS);
  if (Boolean.TRUE.equals(lock)) {
      try {
          // 执行 Lua 脚本扣减库存 + 数据库操作
      } finally {
          // 释放锁（需确保原子性，避免误删他人锁）
          redisTemplate.delete("lock:seckill:goodsId");
      }
  } else {
      // 加锁失败，返回“请求过频”
  }
```



- 优点：解决集群部署下的并发冲突；

- 缺点：需处理锁超时、锁重入、死锁等问题，增加系统复杂度。

#### 3. 上层防护：流量控制（拦截无效请求，减少下游压力）

秒杀超卖的很大原因是 “无效请求过多”（如重复下单、库存已空仍涌入请求），需在网关 / 应用层提前拦截。

##### （1）限流熔断（网关层）

- 原理：限制单位时间内的请求量，避免系统被流量击垮。

- 实现方式：

    - 网关限流：用 Nginx、Gateway 等网关，基于 IP / 用户 ID 限流（如每个 IP 每秒最多 5 次请求）；
    - 应用限流：用 Guava RateLimiter（令牌桶算法），限制应用每秒处理的请求数（如每秒 1000 次）。

- 示例（Guava RateLimiter）：








```java
  // 每秒生成1000个令牌，即每秒最多处理1000个请求
  RateLimiter rateLimiter = RateLimiter.create(1000.0);
  if (!rateLimiter.tryAcquire()) {
      return Result.fail("秒杀太火爆，请稍后再试");
  }
  // 限流通过，执行后续逻辑
 ```



##### （2）防重复下单（应用层）

- 原理：同一用户对同一商品，在秒杀期间只能下单一次，避免重复扣减库存。

- 实现方式：

    - Redis 防重：用户下单前，先判断```seckill:order:userId:goodsId```是否存在，存在则拒绝：


```java
    String orderKey = "seckill:order:" + userId + ":" + goodsId;
    if (Boolean.TRUE.equals(redisTemplate.hasKey(orderKey))) {
        return Result.fail("已下单，请勿重复提交");
    }
    // 下单成功后，设置过期时间（如1小时）
    redisTemplate.opsForValue().set(orderKey, "1", 1, TimeUnit.HOURS);
  ```



- 前端防重：按钮点击后置灰，禁止重复点击；请求加唯一标识（如 UUID），后端去重。

##### （3）库存预热与熔断降级

- 库存预热：秒杀开始前，将商品库存、状态等数据加载到 Redis，避免秒杀开始后大量请求穿透到数据库；
- 熔断降级：当数据库 / Redis 压力达到阈值（如 CPU 使用率 80%），自动拒绝新请求，返回 “系统繁忙”，避免系统崩溃。

#### 4. 兜底方案：最终一致性校验

即使前面的控制都失效，也需通过 “最终校验” 确保不超卖：

- 定时任务对账：秒杀结束后，对比 Redis 库存与数据库库存，若不一致，以数据库为准修正 Redis 库存；
- 订单状态校验：对未支付的订单，设置超时自动取消（如 15 分钟），并回滚库存（Redis + 数据库）；
- 库存兜底校验：创建订单时，最后再校验一次数据库库存，确保 `stock > 0`，避免极端情况下的超卖。

### 三、秒杀超卖解决方案最佳实践（高并发场景）

推荐组合方案：**流量控制 + Redis 预扣减（Lua 脚本） + 数据库乐观锁 + 最终一致性校验**

1. 网关层：Nginx 限流（IP 维度），拦截大部分无效请求；
2. 应用层：Guava 限流 + Redis 防重复下单，进一步过滤无效请求；
3. 缓存层：Redis 预热库存 + Lua 脚本原子扣减，扛住高并发预扣减；
4. 数据库层：乐观锁扣减库存 + 唯一索引防重，确保最终数据一致性；
5. 兜底层：定时任务对账 + 超时订单回滚，修正异常数据。

### 总结

秒杀超卖的核心是 “原子性控制” 和 “流量分层拦截”：

- 低并发场景：仅用「数据库乐观锁 + 唯一索引」即可满足需求；
- 中高并发场景：必须引入「Redis 预扣减 + Lua 脚本」扛高并发，配合流量控制减少下游压力；
- 超大并发场景：需叠加「网关限流 + 分布式锁 + 熔断降级」，确保系统高可用。

所有方案的核心目标都是：**在保证不超卖的前提下，最大化系统的并发处理能力**。
