1. 任务重要性不同
   核心业务任务：例如支付、订单提交等，这类任务不允许丢失，通常会搭配CallerRunsPolicy（调用者线程执行）或自定义策略（如持久化到队列）。CallerRunsPolicy会让提交任务的主线程亲自执行任务，虽然可能阻塞主线程，但避免了任务丢失，适合必须处理的关键操作。
   非核心任务：例如日志收集、数据统计等，这类任务允许临时丢失，可使用DiscardPolicy（直接丢弃）或DiscardOldestPolicy（丢弃队列中最旧的任务），避免因非核心任务阻塞核心流程。
2. 任务特性不同
   CPU 密集型任务：线程池核心线程数通常设置为 CPU 核心数，若任务堆积，可能是系统过载，此时使用AbortPolicy（抛出异常）可快速失败，避免资源耗尽。
   IO 密集型任务：线程池核心线程数较大，任务等待时间长，若队列满，可通过CallerRunsPolicy缓冲压力，或自定义策略将任务暂存到磁盘，待系统空闲时重试。
3. 系统资源限制不同
   资源敏感型线程池：例如操作数据库连接的线程池，受限于数据库连接数，若任务溢出，使用AbortPolicy并配合监控告警，可及时发现连接泄露或配置不合理问题。
   资源宽松型线程池：例如处理本地文件的线程池，资源限制较松，可使用DiscardOldestPolicy优先处理新任务，适合时效性强的场景。
4. 业务容错策略不同
   高可用场景：对任务丢失零容忍，可自定义拒绝策略（如将任务存入 Redis 队列），并启动单独线程消费队列，确保最终一致性。
   高性能场景：优先保证响应速度，允许少量任务丢失，使用DiscardPolicy减少系统开销。
   示例场景
   假设一个电商系统：

订单线程池：处理下单流程，使用CallerRunsPolicy，确保订单不丢失，即使短暂阻塞用户请求。
日志线程池：异步记录操作日志，使用DiscardOldestPolicy，优先记录最新日志，避免因日志堆积影响核心流程。

