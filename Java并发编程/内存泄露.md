内存泄漏（Memory Leak）的核心是：**程序中已不再使用的对象，因仍被错误地持有引用，导致垃圾回收器（GC）无法回收其占用的内存，最终造成内存逐渐耗尽、应用性能下降甚至 OOM（OutOfMemoryError）崩溃**。简单说就是 “内存占了不用，还放不出来”。

## 一、内存泄漏的本质：引用未释放

Java 中对象的回收完全依赖 “引用可达性”—— 若对象从 “GC 根节点”（如线程栈变量、静态变量、JNI 引用等）出发，存在一条或多条引用链可达，则 GC 认为该对象 “仍在使用”，不会回收；反之则会回收。

内存泄漏的本质就是：**本应被回收的对象，因存在 “无效引用链”（程序逻辑上已不需要，但引用未断开），导致 GC 无法识别其 “无用”，从而长期占用内存**。

## 二、常见的内存泄漏场景（附代码示例）

以下是开发中最容易触发内存泄漏的场景，覆盖 “集合未清理”“资源未关闭”“生命周期不匹配” 等核心类型：

### 1. 静态集合（如 static List/Map）未清理引用

**原因**：静态集合的生命周期与应用一致（JVM 不退出，集合就不销毁），若向静态集合中添加对象后，未在使用完后移除，这些对象会被静态集合永久持有，无法回收。**示例**：








```java
public class StaticCollectionLeak {
    // 静态 List：生命周期与应用一致
    private static final List<Object> STATIC_LIST = new ArrayList<>();

    public void addData(Object data) {
        STATIC_LIST.add(data); // 向静态集合添加对象
    }

    // 问题：未提供“移除数据”的方法，添加的对象会被永久持有
    public static void main(String[] args) {
        StaticCollectionLeak demo = new StaticCollectionLeak();
        for (int i = 0; i < 100000; i++) {
            demo.addData(new byte[1024 * 1024]); // 每次添加 1MB 对象
        }
        // 即使后续不再使用这些 byte[]，静态 List 仍持有引用，GC 无法回收
        // 随着添加次数增加，内存会逐渐耗尽，最终 OOM
    }
}
```

### 2. ThreadLocal 未手动 remove（高频场景）

**原因**：`ThreadLocal` 用于存储 “线程私有数据”，其底层是通过 “线程的 `ThreadLocalMap`” 实现的 ——`ThreadLocalMap` 的 key 是 `ThreadLocal` 实例（弱引用），value 是存储的数据（强引用）。

- 若 `ThreadLocal` 实例被回收（如方法执行完，局部变量 `ThreadLocal` 出栈），`ThreadLocalMap` 的 key 会变成 “弱引用垃圾”，但 value 仍被强引用持有（形成 “key 为 null，value 非 null” 的无效 entry）；
- 若线程是 “线程池线程”（如 Tomcat 线程池、线程池核心线程），线程生命周期长，这些无效 entry 会长期占用内存，导致泄漏。

**示例**：





```java
public class ThreadLocalLeak {
    // ThreadLocal 作为局部变量，方法执行完后会被回收
    public void processRequest() {
        ThreadLocal<byte[]> threadLocal = new ThreadLocal<>();
        // 向 ThreadLocal 存入大对象
        threadLocal.set(new byte[1024 * 1024]);

        // 业务逻辑处理...

        // 问题：未调用 threadLocal.remove()，value 会被线程的 ThreadLocalMap 永久持有
        // 若线程是线程池线程（长期存活），value 无法回收，导致内存泄漏
    }

    public static void main(String[] args) {
        // 模拟线程池（核心线程长期存活）
        ExecutorService executor = Executors.newFixedThreadPool(5);
        ThreadLocalLeak demo = new ThreadLocalLeak();
        for (int i = 0; i < 1000; i++) {
            executor.submit(demo::processRequest);
        }
    }
}
```

**解决**：使用 `ThreadLocal` 后，必须在 `finally` 块中调用 `remove()`，确保 value 被释放：











```java
try {
    threadLocal.set(data);
    // 业务逻辑
} finally {
    threadLocal.remove(); // 强制清理，避免泄漏
}
```

### 3. 资源未关闭（如 IO 流、Socket、数据库连接）

**原因**：Java 中的 IO 流（如 `InputStream`/`OutputStream`）、网络连接（`Socket`）、数据库连接（`Connection`）等 “外部资源”，底层不仅占用 JVM 内存，还持有操作系统资源（如文件句柄、网络端口）。若未调用 `close()` 关闭，这些资源的 “包装对象”（如 `FileInputStream`）会被 JVM 认为 “仍在使用”（引用未断开），无法回收，同时操作系统资源也会被耗尽。

**示例**：











```java
public class ResourceLeak {
    public void readFile(String path) {
        FileInputStream in = null;
        try {
            in = new FileInputStream(path); // 打开文件流，持有文件句柄
            byte[] buffer = new byte[1024];
            in.read(buffer); // 读取文件
            // 问题：未调用 in.close()，FileInputStream 对象无法回收，文件句柄也未释放
        } catch (IOException e) {
            e.printStackTrace();
        }
        // 即使方法执行完，in 仍持有引用（局部变量出栈，但操作系统资源未释放）
    }
}
```

**解决**：使用 `try-with-resources`（Java 7+）自动关闭资源，或在 `finally` 块中手动 `close()`。

### 4. 监听器 / 回调未注销

**原因**：若向框架 / 组件注册了监听器（如 GUI 监听器、Spring 事件监听器）或回调函数，但在对象销毁前未注销，框架会继续持有监听器的引用，导致监听器对象及其关联的对象无法回收。

**示例**：








```java
public class ListenerLeak {
    public void registerListener() {
        // 向某个框架注册监听器
        EventFramework.registerListener(new MyListener());
        // 问题：未调用 EventFramework.unregisterListener() 注销
        // 即使 ListenerLeak 对象销毁，MyListener 仍被框架持有，无法回收
    }

    // 自定义监听器
    private static class MyListener implements EventListener {
        // 监听器逻辑...
    }
}
```

### 5. 集合中的对象 “自引用” 或 “循环引用”

**原因**：若集合中的对象存在 “循环引用”（如 A 引用 B，B 引用 A），且集合本身未被清理，这些循环引用的对象会被集合持有，导致 GC 无法回收（即使它们逻辑上已无用）。

**示例**：











```java
public class CircularRefLeak {
    public static void main(String[] args) {
        List<Node> nodeList = new ArrayList<>();
        // 创建循环引用的对象
        Node a = new Node();
        Node b = new Node();
        a.next = b; // A 引用 B
        b.prev = a; // B 引用 A
        nodeList.add(a); // 集合持有 A 的引用
        nodeList.add(b); // 集合持有 B 的引用

        // 问题：即使后续不再使用 a 和 b，nodeList 仍持有引用，循环引用的对象无法回收
        // 若 nodeList 是静态集合，泄漏会更严重
    }

    private static class Node {
        Node next;
        Node prev;
    }
}
```

### 6. 缓存未设置过期策略或未清理

**原因**：若使用缓存（如 `HashMap` 手动实现的缓存）时，只向缓存中添加数据，未设置 “过期清理” 或 “容量上限”，缓存会无限增长，最终导致内存泄漏。

**示例**：







```java
public class CacheLeak {
    // 手动实现的缓存，无过期策略
    private static final Map<String, Object> CACHE = new HashMap<>();

    public void addToCache(String key, Object value) {
        CACHE.put(key, value); // 只添加，不清理
    }

    // 问题：缓存无限增长，即使 value 逻辑上已无用（如用户登录信息过期），仍被持有
    // 长期运行后，CACHE 会占用大量内存，导致泄漏
}
```

**解决**：使用有过期策略的缓存（如 Guava Cache、Caffeine Cache），或手动实现 “LRU 淘汰机制”。

### 7. 线程未正确关闭（如 daemon 线程未停止）

**原因**：若创建的线程未设置为 “守护线程（daemon）”，且线程未正常终止（如线程内有无限循环），线程会一直存活，其持有的对象（如线程局部变量、业务对象）也无法回收，导致内存泄漏。

**示例**：









```java
public class ThreadLeak {
    public void startLeakyThread() {
        Thread thread = new Thread(() -> {
            while (true) { // 无限循环，线程永远不终止
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });
        // 问题：未设置为 daemon 线程，主线程退出后，该线程仍存活
        // 线程持有的所有对象（如 lambda 中的引用）无法回收
        thread.start();
    }
}
```

**解决**：

- 给线程设置明确的终止条件（如通过 `volatile` 变量控制循环退出）；
- 若线程是 “辅助线程”，设置为守护线程（`thread.setDaemon(true)`），主线程退出后会自动终止。

## 三、内存泄漏的危害与排查

### 1. 危害

- 短期：应用内存占用逐渐升高，GC 频繁触发（“Full GC” 次数增加），CPU 利用率飙升，响应变慢；
- 长期：内存耗尽，触发 `OutOfMemoryError`，应用崩溃。

### 2. 排查工具

- JDK 自带工具 ：

    - `jmap`：导出堆内存快照（`jmap -dump:format=b,file=heap.hprof <pid>`）；
    - `jhat`：分析堆快照（`jhat heap.hprof`，通过浏览器查看泄漏对象）；
    - `jstat`：监控 GC 情况（`jstat -gc <pid> 1000`，查看 Full GC 频率和内存占用）。

- 第三方工具 ：

    - MAT（Memory Analyzer Tool）：专业堆分析工具，自动识别内存泄漏点（如 “Leak Suspects” 报告）；
    - VisualVM：集成 jmap、jstat 功能，可视化监控内存和 GC。

## 四、核心总结

1. **内存泄漏本质**：无用对象的引用未断开，GC 无法回收；

2. **高频场景**：静态集合未清理、ThreadLocal 未 remove、资源未关闭、监听器未注销、缓存无过期策略；

3. 预防核心：

    - 明确对象的生命周期，使用完后及时断开引用（如 `list.clear()`、`threadLocal.remove()`）；
    - 优先使用 “自动资源管理” 机制（如 try-with-resources）；
    - 避免使用无界静态集合，缓存需设置过期 / 淘汰策略；

4. **排查关键**：通过堆快照工具定位 “长期存活的无用对象”，追溯其引用链，找到未释放的引用源头。

简单说：内存泄漏的核心是 “该放的没放”，开发中只要注意 “用完即清理”，就能避免绝大多数场景。