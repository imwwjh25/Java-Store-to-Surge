# TCP 的 backlog 是什么？backlog 满了之后发生了什么？

TCP 的 `backlog` 是 **服务器端监听套接字（`listen()` 函数的参数）维护的 “半连接队列 + 全连接队列” 的总容量上限**，核心作用是限制 “正在建立连接” 和 “已建立连接但未被应用处理” 的连接总数，避免服务器被海量连接压垮。

要理解 `backlog`，需先明确 TCP 三次握手的连接状态流转，再拆解其背后的两个关键队列：

## 一、先搞懂：TCP 连接建立的两个核心队列

服务器调用 `listen(port, backlog)` 后，会维护两个队列（不同操作系统实现略有差异，但核心逻辑一致）：

| 队列类型                  | 作用（连接状态）                                             | 触发场景                                                   |
| ------------------------- | ------------------------------------------------------------ | ---------------------------------------------------------- |
| 半连接队列（SYN 队列）    | 存储 “已接收客户端 SYN 包，但未完成三次握手” 的连接（状态：`SYN_RCVD`） | 客户端发送 `SYN` → 服务器回复 `SYN+ACK` 后，连接进入该队列 |
| 全连接队列（Accept 队列） | 存储 “三次握手完成，已建立 TCP 连接，但应用层未调用 `accept()` 接收” 的连接（状态：`ESTABLISHED`） | 客户端回复 `ACK` 后，连接从半连接队列移入该队列            |

### 关键：backlog 的实际含义（OS 差异）

- **早期 Linux（2.2 之前）**：`backlog` 直接等于 “半连接队列容量”；
- **现代 Linux（2.2 之后）**：`backlog` 是 “半连接队列容量 + 全连接队列容量” 的上限（具体分配由内核参数 `net.ipv4.tcp_max_syn_backlog` 和 `net.core.somaxconn` 共同限制，`backlog` 不能超过 `somaxconn`，默认 128）；
- 其他 OS（如 Windows）：`backlog` 主要限制 “全连接队列容量”，半连接队列有独立内核参数控制。

本质上，`backlog` 是服务器对 “待处理连接” 的总 “缓冲池大小”，避免连接无限制堆积。

## 二、backlog 满了之后：新连接会被拒绝

当 `backlog` 对应的两个队列总容量达到上限（半连接队列满 + 全连接队列满）时，服务器会直接拒绝新的客户端连接，具体行为分两种场景：

### 场景 1：半连接队列满（客户端刚发 SYN，三次握手未完成）

此时服务器收到客户端的 `SYN` 包后，**不会回复 `SYN+ACK`**（即 “静默丢弃” 该 SYN 包），不会发送 `RST` 包（避免客户端快速重试）。

- 客户端行为：
  1. 客户端发送 `SYN` 后，启动 “SYN 重传计时器”（默认超时时间 1 秒）；
  2. 超时后未收到 `SYN+ACK`，会重新发送 `SYN`（重传次数由内核参数控制，如 Linux 默认 5 次）；
  3. 若所有重传都未收到响应，客户端会抛出 “连接超时” 错误（如 `Connection timed out`）。
- 为什么静默丢弃而非发 RST？避免客户端快速感知 “连接被拒” 后频繁重试，进一步加重服务器负担；静默丢弃让客户端自然超时，间接 “限流”。

### 场景 2：全连接队列满（三次握手完成，连接已建立）

此时服务器已完成三次握手（状态 `ESTABLISHED`），但全连接队列已满，应用层未调用 `accept()` 接收连接：

- 服务器行为：

  - 现代 Linux：默认丢弃客户端后续发送的数据（如```ACK```或业务数据），或根据内核参数```net.ipv4.tcp_abort_on_overflow```决定：

    - `tcp_abort_on_overflow=0`（默认）：静默丢弃，客户端会超时重传；
    - `tcp_abort_on_overflow=1`：服务器发送 `RST` 包给客户端，直接拒绝连接。

- 客户端行为：

  - 若服务器发 `RST`：客户端立即抛出 “连接被拒绝” 错误（如 `Connection refused`）；
  - 若服务器静默丢弃：客户端发送的数据超时未被确认，会重传数据，最终超时失败。

### 关键现象：

- 服务器端：`netstat -an | grep :port` 会看到大量 `SYN_RCVD`（半连接队列满）或 `ESTABLISHED`（全连接队列满）状态的连接；
- 客户端：连接超时（半连接队列满）或连接被拒（全连接队列满且 `tcp_abort_on_overflow=1`）；
- 应用层：服务器 `accept()` 调用无法获取新连接，客户端请求无法被处理。

## 三、延伸：如何合理设置 backlog？

`backlog` 并非越大越好（过大可能导致服务器资源浪费），需结合服务器处理能力（`accept()` 调用频率、业务处理速度）和预期并发量设置：

1. **核心原则**：
   - `backlog` 应大于 “峰值并发连接数 - 应用处理能力”，避免队列频繁满；
   - 不能超过内核参数 `net.core.somaxconn`（Linux 默认 128，高并发场景需调整为 1024 或更高）。
2. **Linux 内核参数配合**：
   - `net.core.somaxconn`：全连接队列的最大容量上限，`backlog` 不能超过该值；
   - `net.ipv4.tcp_max_syn_backlog`：半连接队列的最大容量（默认 128，高并发场景调整为 1024+）；
   - `net.ipv4.tcp_syncookies`：开启 SYN Cookie（默认开启），当半连接队列满时，用 Cookie 代替半连接队列存储连接信息，避免 SYN 洪水攻击。
3. **应用层优化**：
   - 提高 `accept()` 调用频率（如使用 IO 多路复用 `epoll` + 线程池，避免单线程阻塞在 `accept()`）；
   - 减少单个连接的处理时间（优化业务逻辑，避免长时间阻塞），让全连接队列快速清空。

## 四、总结

1. **backlog 是什么**：服务器监听套接字的 “半连接队列 + 全连接队列” 总容量上限，限制待处理连接数；

2. backlog 满了之后：

   - 半连接队列满：静默丢弃客户端 SYN 包，客户端连接超时；
   - 全连接队列满：默认静默丢弃，或发送 RST 包拒绝连接，客户端超时或直接报错；

3. **核心作用**：保护服务器，避免海量连接堆积导致资源耗尽；

4. **优化建议**：结合内核参数和应用层处理能力，合理设置 `backlog`，避免过小导致连接频繁被拒，或过大浪费资源。
