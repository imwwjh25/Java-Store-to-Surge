
## 一、先明确核心前提：MySQL 的索引是 “磁盘索引”

MySQL 的表数据和索引默认存储在磁盘上（而非内存），索引设计的核心目标是：**最小化磁盘 IO 次数**（磁盘 IO 是毫秒级，内存操作是纳秒级，差距 100 万倍）。

任何索引结构想要适配 MySQL，必须解决两个关键问题：

1. 如何让 “一次磁盘 IO” 加载尽可能多的有效数据（利用磁盘 “按页读取” 的特性：磁盘 IO 不是按字节读，而是按 “页” 读，InnoDB 默认页大小 16KB）；
2. 如何减少 “查找目标数据” 所需的 IO 次数（即降低索引的 “高度”）。

B + 树和跳表都能支持 “一次加载大量数据”（跳表的节点也可以按页组织），但在上述核心目标的延伸需求（范围查询、事务、数据有序性）上，差距明显。

## 二、MySQL 选择 B + 树的核心原因（B + 树的 4 大优势）

B + 树是 “多路平衡查找树”，其结构设计完全为磁盘 IO 优化，刚好匹配 MySQL 的需求：

### 1. 高度极低，磁盘 IO 次数最少（核心优势）

B + 树是 “多路” 树（而非二叉树），每个节点可以存储多个索引项（InnoDB 的 16KB 页，能存数百个索引项），导致树的高度极低：

- 假设每个节点存储 100 个索引项（实际 InnoDB 中，主键索引节点能存更多，二级索引也能存几十到上百个）：
    - 3 层 B + 树：可索引 `100 * 100 * 100 = 100万` 条数据；
    - 4 层 B + 树：可索引 `100^4 = 1亿` 条数据；
    - 5 层 B + 树：可索引 `100^5 = 100亿` 条数据。

意味着：**即使是 100 亿条数据，查找一个目标值最多只需 5 次磁盘 IO**（每次读一个节点页），这是磁盘场景下的最优查找效率。

而跳表的 “层高” 是动态的（基于概率随机生成），虽然平均查找复杂度也是 O (log n)，但跳表的 “层” 对应的是 “索引层级”，而非 “磁盘页层级”：

- 跳表的每个节点通常只存 1 个索引项（若要按页组织，需要额外设计，且灵活性差）；
- 要达到和 B + 树相同的 IO 次数，跳表需要更高的 “索引层级”，但磁盘 IO 是按页读，跳表的高层级索引可能分散在不同页中，导致多此 IO。

### 2. 所有数据集中在叶子节点，范围查询效率拉满

B + 树的结构特点：

- 非叶子节点只存 “索引项 + 子节点指针”，不存数据（主键索引的叶子节点存完整行数据，二级索引存主键 ID）；
- 所有叶子节点通过 “双向链表” 串联，且按索引顺序排序。

这个设计让范围查询（如`WHERE id BETWEEN 100 AND 200`、`ORDER BY`、`GROUP BY`）效率极高：

1. 先通过 B + 树的非叶子节点，快速定位到范围的起始叶子节点（如 id=100）；
2. 沿着叶子节点的双向链表，依次遍历到范围的结束节点（如 id=200），无需回退上层节点。

**范围查询的 IO 次数 = 定位起始节点的 IO 次数 + 遍历叶子节点的 IO 次数**（遍历叶子节点时，因链表连续，磁盘可预读相邻页，进一步减少 IO）。

而跳表的范围查询：

- 跳表的节点也是有序的，但没有 “叶子节点链表” 的设计，需要从起始节点开始，按 “下一层” 指针逐节点遍历；
- 跳表的节点可能分散在不同磁盘页中，遍历过程中需要频繁换页，IO 次数远高于 B + 树；
- 尤其是大范围查询（如查询前 1000 条数据），跳表的遍历效率会显著低于 B + 树。

### 3. 节点结构紧凑，磁盘页利用率极高

B + 树的非叶子节点只存 “索引项 + 指针”，不存数据，因此每个磁盘页（16KB）能容纳的索引项数量极多：

- 例如，InnoDB 的主键索引（INT 类型，4 字节）+ 指针（6 字节），每个索引项仅 10 字节，16KB 页能存 `16*1024 / 10 ≈ 1638` 个索引项；
- 二级索引（如 VARCHAR (20) 的字段，假设平均长度 10 字节）+ 主键（4 字节），每个索引项 14 字节，16KB 页能存 `16*1024 /14 ≈ 1170` 个索引项。

节点越紧凑，树的高度越低，IO 次数越少 —— 这是 B + 树比其他树结构（如 B 树、二叉树）更优的关键。

而跳表的节点需要存储多个 “层指针”（每个层对应一个指针）：

- 一个跳表节点可能需要存储 10 个以上的指针（取决于层高），每个指针 8 字节（64 位系统），仅指针就占用 80 字节；
- 若再加上索引项和数据，每个节点的体积会远大于 B + 树的索引项，导致每个磁盘页能容纳的跳表节点数量极少，树的高度增加，IO 次数增多。

### 4. 适配 InnoDB 的事务和 MVCC 机制

InnoDB 的事务（ACID）和 MVCC（多版本并发控制）依赖 “聚簇索引” 和 “数据有序性”：

- B + 树的主键索引是 “聚簇索引”，叶子节点直接存储完整行数据，且数据按主键有序排列；
- MVCC 通过 “版本链”（每行数据的隐藏字段）实现，而有序的聚簇索引能让事务在读取数据时，快速定位到目标行的历史版本；
- 锁机制（如行锁、间隙锁）也依赖 B + 树的有序性，通过锁定 “索引范围” 来实现并发控制。

跳表若要支持事务和 MVCC，需要额外设计 “聚簇存储” 和 “有序锁定” 机制，而 B + 树的结构天然适配这些需求，无需额外复杂设计。

## 三、跳表不行吗？跳表的适用场景与局限

跳表并非 “不好”，而是**适用场景和 MySQL 的核心需求不匹配**：

### 跳表的优势（适合内存场景）

1. 插入 / 删除效率高：跳表是 “概率平衡” 结构，插入 / 删除时无需像 B + 树那样进行 “旋转调整” 来维持平衡，平均复杂度 O (log n)，且实现简单；
2. 适合内存数据库：若数据全在内存中（无磁盘 IO 瓶颈），跳表的查找、插入、删除效率与 B + 树接近，且实现更简单（如 Redis 的有序集合 ZSET，就是用跳表实现的）。

### 跳表在 MySQL 场景下的核心局限

1. 磁盘 IO 效率低：节点体积大，页利用率低，树的高度高，IO 次数多；
2. 范围查询效率差：无叶子节点链表，遍历过程中换页频繁；
3. 不适配聚簇索引：跳表无法像 B + 树那样将数据和索引融合成聚簇索引，导致数据存储分散，查询时需要额外回表（二级索引的问题）；
4. 事务和锁支持复杂：跳表的有序性不如 B + 树稳定，实现间隙锁、MVCC 等机制会更复杂，性能也不如 B + 树。

## 四、B + 树 vs 跳表：核心维度对比

| 对比维度         | B + 树                              | 跳表                                     |
| ---------------- | ----------------------------------- | ---------------------------------------- |
| 磁盘 IO 效率     | 极高（节点紧凑，高度低，IO 次数少） | 较低（节点体积大，页利用率低）           |
| 范围查询         | 最优（叶子节点双向链表，支持预读）  | 一般（需逐节点遍历，换页频繁）           |
| 插入 / 删除      | 稳定 O (log n)（需平衡调整）        | 平均 O (log n)（实现简单，无调整）       |
| 节点利用率       | 极高（仅存索引项 + 指针）           | 较低（需存多个层指针）                   |
| 事务 / MVCC 适配 | 天然适配（聚簇索引 + 有序性）       | 需额外设计，复杂度高                     |
| 适用场景         | 磁盘数据库（MySQL、Oracle）         | 内存数据库 / 组件（Redis ZSET、LevelDB） |

## 五、总结：为什么 MySQL 不用跳表？

跳表能 “一次加载大量磁盘数据”（通过按页组织节点），但在 MySQL 的核心需求场景下，B + 树的综合表现更优：

1. 磁盘 IO 是 MySQL 的性能瓶颈，B + 树的 “低高度、高页利用率” 能最小化 IO 次数；
2. 范围查询是 MySQL 的高频场景（排序、分组、区间查询），B + 树的叶子链表设计效率远超跳表；
3. InnoDB 的事务、MVCC、聚簇索引机制，与 B + 树的结构天然契合，而跳表需要额外适配，成本高、性能差。

简单说：**跳表适合内存场景，B + 树适合磁盘场景**——MySQL 是磁盘数据库，所以选择 B + 树；而 Redis（内存数据库）的有序集合选择跳表，正是因为跳表在内存中实现简单、效率不逊于 B + 树。