# TreeMap 底层实现、有序性原理与使用场景

TreeMap 是 Java 集合框架中 **有序的键值对（Key-Value）映射** 实现，底层基于 **红黑树（Red-Black Tree）**（一种自平衡的二叉搜索树），其核心特性是 **“键的有序性”**（默认自然排序或自定义排序），适用于需要按键有序访问、范围查询的场景。

## 一、底层实现核心：红黑树（自平衡二叉搜索树）

TreeMap 不依赖哈希表，而是通过红黑树组织数据，红黑树的特性直接决定了 TreeMap 的功能和性能：

### 1. 红黑树的核心特性（保证自平衡）

红黑树是二叉搜索树（BST）的变种，额外满足 5 条规则，确保树的高度始终接近 `log2(n)`（n 为元素个数），避免退化为链表：

1. 每个节点要么是红色，要么是黑色；
2. 根节点必须是黑色；
3. 所有叶子节点（NIL 节点，空节点）都是黑色；
4. 若一个节点是红色，其两个子节点必须是黑色（父子节点不能同时为红）；
5. 从任意节点到其所有叶子节点的路径，黑色节点的数量相同（“黑高” 一致）。

这些规则强制红黑树 **自平衡**：插入 / 删除元素时，若破坏规则，会通过 **变色、左旋、右旋** 调整树结构，使树的高度保持在 `O(log n)`，确保查询、插入、删除的时间复杂度均为 `O(log n)`。

### 2. TreeMap 与红黑树的映射关系

TreeMap 中每个键值对（`Entry<K,V>`）对应红黑树的一个节点，节点包含以下核心字段：

- `K key`：键（有序的核心，用于比较大小）；
- `V value`：值；
- `Entry<K,V> left/right`：左 / 右子节点（二叉搜索树的左右子树）；
- `Entry<K,V> parent`：父节点（便于树的调整）；
- `boolean color`：节点颜色（红 / 黑，用于自平衡）。

此外，TreeMap 还维护了两个关键属性：

- `Comparator<? super K> comparator`：自定义比较器（若为 `null`，则使用键的自然排序，即 `K` 实现 `Comparable` 接口）；
- `Entry<K,V> root`：红黑树的根节点（入口节点）。

## 二、有序性的实现原理：基于比较器的二叉搜索

TreeMap 的 “有序性” 本质是 **红黑树的二叉搜索特性 + 比较器的排序规则**，核心流程如下：

### 1. 排序规则的确定（自然排序 vs 自定义排序）

TreeMap 的键必须支持比较，否则插入元素时会抛出 `ClassCastException`，排序规则二选一：

- **自然排序**：若 `comparator == null`，要求键 `K` 必须实现 `Comparable<K>` 接口，调用 `key.compareTo(otherKey)` 比较大小（如 `Integer` 按数值排序、`String` 按字典序排序）；
- **自定义排序**：若指定 `comparator`（如 `new TreeMap<>(Comparator.reverseOrder())`），则通过 `comparator.compare(key, otherKey)` 定义排序规则（无需键实现 `Comparable`）。

### 2. 二叉搜索特性：保证中序遍历有序

二叉搜索树的核心规则是：**左子树所有节点的键 < 当前节点的键 < 右子树所有节点的键**。TreeMap 的 “有序遍历” 本质是对红黑树进行 **中序遍历**（左子树 → 当前节点 → 右子树），遍历结果会严格遵循比较器定义的排序规则。

示例：TreeMap 存储 `{3,1,4,2}`，按自然排序的中序遍历结果为 `1→2→3→4`，与 `keySet()`、`entrySet()` 迭代顺序一致。

### 3. 插入 / 查询时的有序维护

- 插入元素 ：

    1. 按比较器规则找到插入位置（遵循二叉搜索树逻辑：比当前节点小则走左子树，大则走右子树）；
    2. 插入新节点（默认红色），若破坏红黑树规则，触发自平衡调整（变色、旋转）；
    3. 调整后仍保持二叉搜索特性，中序遍历有序。

- 查询元素 ：

    1. 按比较器规则从根节点开始遍历（比当前节点小则查左子树，大则查右子树）；
    2. 找到匹配键则返回值，未找到返回 `null`；
    3. 因树自平衡，查询路径长度为 `O(log n)`，效率稳定。

## 三、核心特性与性能对比

### 1. 核心特性

| 特性       | 说明                                                         |
| ---------- | ------------------------------------------------------------ |
| 有序性     | 键按比较规则有序，支持正序 / 逆序遍历、范围查询（如 `subMap()`、`headMap()`） |
| 键唯一性   | 键不能重复（重复键会覆盖旧值，基于比较器判断 `key1 == key2`） |
| 键非空     | 键不能为 `null`（HashMap 键可空），否则抛出 `NullPointerException` |
| 线程不安全 | 非线程安全，多线程并发读写需手动加锁（如 `Collections.synchronizedMap()`） |
| 性能       | 查询、插入、删除均为 `O(log n)`（红黑树自平衡保证）          |

### 2. 与 HashMap 的性能对比（关键差异）

| 操作               | TreeMap（红黑树）  | HashMap（哈希表）    | 备注                     |
| ------------------ | ------------------ | -------------------- | ------------------------ |
| 插入 / 删除 / 查询 | `O(log n)`         | `O(1)`（理想）       | HashMap 哈希冲突少时更快 |
| 有序遍历           | 支持（高效）       | 不支持（无序）       | TreeMap 核心优势         |
| 范围查询           | 支持（`O(log n)`） | 不支持（需手动排序） | TreeMap 独有关键功能     |
| 键是否可空         | 不可空             | 可空（1 个）         | HashMap 更灵活           |
| 线程安全           | 不安全             | 不安全               | 均需额外处理并发         |

## 四、典型使用场景

TreeMap 的核心价值是 **“有序性” 和 “范围查询”**，适合以下场景：

### 1. 需按键有序访问的场景

- 示例：存储学生成绩（键为成绩 `Integer`，值为学生信息），按成绩升序 / 降序遍历；

- 代码示例：




  ```java
  // 自定义排序：按成绩降序
  TreeMap<Integer, String> scoreMap = new TreeMap<>(Comparator.reverseOrder());
  scoreMap.put(95, "张三");
  scoreMap.put(88, "李四");
  scoreMap.put(98, "王五");
  // 遍历结果：98→王五，95→张三，88→李四（降序）
  for (Map.Entry<Integer, String> entry : scoreMap.entrySet()) {
      System.out.println(entry.getKey() + ":" + entry.getValue());
  }
  ```



### 2. 范围查询场景（核心场景）

需要查询 “键在某个区间内的所有元素”，如：

- 查询成绩 ≥80 且 ≤90 的学生；
- 查询字典序介于 "A" 和 "C" 之间的字符串键值对。

代码示例（范围查询）：







```java
TreeMap<Integer, String> scoreMap = new TreeMap<>();
scoreMap.put(80, "甲");
scoreMap.put(85, "乙");
scoreMap.put(90, "丙");
scoreMap.put(95, "丁");

// 1. 查询键 ≤90 的元素（headMap：包含90）
Map<Integer, String> lowScoreMap = scoreMap.headMap(90, true); 
// 结果：80→甲，85→乙，90→丙

// 2. 查询键 ≥85 且 ≤95 的元素（subMap：闭区间）
Map<Integer, String> midScoreMap = scoreMap.subMap(85, true, 95, true);
// 结果：85→乙，90→丙，95→丁

// 3. 查询最大/最小键
Integer maxScore = scoreMap.lastKey(); // 95
Integer minScore = scoreMap.firstKey(); // 80
```

### 3. 排序映射场景

需要将映射关系按键排序后输出，如生成有序报表、排序的配置项等。

### 4. 避免使用场景

- 不需要有序性的场景（优先用 HashMap，效率更高）；
- 高频插入 / 删除且无需排序（HashMap 哈希冲突少时性能更优）；
- 键需要为 `null` 的场景（HashMap 支持）。

## 五、关键注意事项（避坑指南）

1. **键必须支持比较**：要么实现 `Comparable` 接口，要么指定 `Comparator`，否则插入元素抛出 `ClassCastException`；
2. **比较器与 `equals()` 一致性**：建议比较器的结果与 `key.equals()` 一致（即 `comparator.compare(a,b) == 0` 时，`a.equals(b) == true`），否则会出现 “键不重复但 `equals()` 认为重复” 的矛盾（如 TreeMap 中 `a` 和 `b` 视为不同键，但 `a.equals(b)` 为 `true`）；
3. **线程安全问题**：多线程并发读写时，需用 `Collections.synchronizedMap(new TreeMap<>())` 或 `ConcurrentSkipListMap`（JDK 1.6+，并发版有序映射，性能更优）；
4. **范围查询的边界处理**：`headMap()`、`tailMap()`、`subMap()` 方法默认是 “左闭右开” 区间（如 `headMap(90)` 表示键 <90），可通过重载方法指定是否包含边界（如 `headMap(90, true)` 包含 90）。

## 六、核心总结

1. **底层实现**：基于红黑树（自平衡二叉搜索树），确保插入 / 删除 / 查询的时间复杂度为 `O(log n)`；
2. **有序性原理**：通过 “二叉搜索树的中序遍历 + 比较器（自然排序 / 自定义排序）” 实现键的有序性；
3. **核心优势**：键有序、支持范围查询、性能稳定（无哈希冲突导致的性能退化）；
4. **使用场景**：需按键有序访问、范围查询的场景（如排序报表、区间统计）；
5. **对比 HashMap**：牺牲部分插入 / 查询效率，换取有序性和范围查询能力。

简单说：TreeMap 是 “有序的 Map”，红黑树保证了有序性和高效性，核心价值在于 “按键排序” 和 “范围查询”。