### 一、MySQL 什么时候加间隙锁（Gap Lock）

间隙锁是 InnoDB 存储引擎在 **可重复读（RR）隔离级别** 下的核心锁机制（Read Committed 隔离级别默认禁用），目的是 **防止幻读**，仅在「范围查询 / 非唯一索引等值查询」时触发，具体场景如下：

#### 1. 核心前提

- 存储引擎：仅 InnoDB（MyISAM 等不支持事务的引擎无间隙锁）；
- 隔离级别：必须是 **RR（可重复读）**（RC 级别下，InnoDB 会关闭间隙锁，仅用记录锁）；
- 索引类型：依赖 **B+ 树索引**（无索引时会退化为表锁，不存在 “间隙” 概念）。

#### 2. 触发间隙锁的具体场景

间隙锁的核心是「锁定索引之间的空白区间」，避免其他事务插入新行，触发场景分两类：

##### （1）范围查询（最典型场景）

对索引列进行 **范围查询**（如 `>`、`<`、`BETWEEN AND`），且使用「当前读」（加锁查询 / 写操作）时，会锁定查询范围覆盖的「记录 + 间隙」（即临键锁 Next-Key Lock，间隙锁 + 记录锁的组合）。

- 示例：表```user(id int, age int, 索引 idx_age(age))```，数据```age: 18, 22, 25```，间隙为```(-∞,18)、(18,22)、(22,25)、(25,+∞)```；







  ```sql
  -- 范围查询 + 当前读，触发临键锁（包含间隙锁）
  SELECT * FROM user WHERE age BETWEEN 20 AND 30 FOR UPDATE;
  ```

锁定范围：```(22,25)```间隙 +```(25,+∞)```间隙 +```age=22、25```记录 → 阻止其他事务插入```age=23、26```等符合范围的新行。

##### （2）非唯一索引等值查询（无匹配记录时）

对 **非唯一索引列** 进行等值查询，若查询条件无匹配记录，InnoDB 会锁定「该条件对应的间隙」，防止后续插入匹配记录（避免幻读）。

- 示例：同上表，查询```age=23```（无匹配记录）：









  ```sql
  -- 非唯一索引等值查询 + 无匹配记录 + 当前读，触发间隙锁
  SELECT * FROM user WHERE age=23 FOR UPDATE;
  ```
锁定范围：```(22,25)```间隙 → 阻止其他事务插入```age=23```的新行（否则下次查询会出现幻读）。

##### （3）非唯一索引等值查询（有匹配记录时）

若等值查询有匹配记录，InnoDB 会使用「临键锁」（记录锁 + 相邻间隙锁），既锁定匹配记录，也锁定相邻间隙，防止插入 “相邻的符合条件记录”。

- 示例：查询```age=22```（有匹配记录）：
```sql
ELECT * FROM user WHERE age=22 FOR UPDATE;```锁定范围：```(18,22)```间隙 +```age=22```记录 +``` (22,25)```间隙 → 阻止插入```age=21、23```等记录。
```

#### 3. 不触发间隙锁的场景

- 唯一索引等值查询（如主键、唯一键）：仅锁定目标记录（记录锁），不锁间隙（InnoDB 优化，因唯一索引确保无重复记录，无需防插入）；
- Read Committed（RC）隔离级别：禁用间隙锁，仅用记录锁；
- 快照读（普通 `SELECT`）：不加锁，自然无间隙锁；
- 无索引查询：退化为表锁，无 “间隙” 概念。

### 二、MySQL 的 redo log 和 undo log 什么时候记录

redo log（重做日志）和 undo log（回滚日志）是 InnoDB 事务 ACID 特性的核心保障，记录时机与「事务执行流程」强绑定，具体如下：

#### 1. redo log（重做日志）：崩溃恢复的核心

redo log 记录「数据页的物理修改」（如 “将 id=1 的行 age 改为 25”），目的是 **崩溃后恢复未刷盘的事务**（确保持久性），记录时机是「事务执行过程中，数据页修改时实时记录」。

##### （1）记录时机

- 触发条件：每次修改数据页（如 `INSERT`/`UPDATE`/`DELETE`）时，先写 redo log，再修改内存中的数据页（即 “WAL 机制”：Write-Ahead Logging）；
- 具体流程：
    1. 事务执行 `UPDATE user SET age=25 WHERE id=1`；
    2. InnoDB 先将 “id=1 的 age 从 20 改为 25” 的物理修改，写入 redo log buffer（内存缓冲区）；
    3. 再修改内存中的数据页（Buffer Pool）；
    4. 事务提交时，将 redo log buffer 中的日志刷到磁盘（redo log file），确保崩溃后可恢复。

##### （2）关键特点

- 顺序写：redo log 是环形文件，顺序写入，性能极高；
- 不随事务回滚删除：即使事务回滚，redo log 仍保留（回滚由 undo log 负责），崩溃恢复时会通过 undo log 撤销无效修改。

#### 2. undo log（回滚日志）：事务回滚的核心

undo log 记录「数据修改前的逻辑状态」（如 “id=1 的 age 原本是 20”），目的是 **事务回滚时恢复数据**（确保原子性），记录时机是「事务执行修改操作前，先记录原始状态」。

##### （1）记录时机

- 触发条件：每次执行 `INSERT`/`UPDATE`/`DELETE` 前，先记录 undo log，再执行修改操作；

- 分操作类型的记录逻辑：

  | 操作类型 | undo log 记录内容                                   | 回滚时执行逻辑     |
    | -------- | --------------------------------------------------- | ------------------ |
  | INSERT   | 记录插入行的主键信息                                | 删除该主键对应的行 |
  | UPDATE   | 记录修改列的原始值（如 age 从 20 改为 25，记录 20） | 将列值恢复为原始值 |
  | DELETE   | 记录删除行的完整数据                                | 重新插入该行数据   |

- 具体流程：

    1. 事务执行 `UPDATE user SET age=25 WHERE id=1`；
    2. InnoDB 先记录 undo log：“id=1 的 age 原始值为 20”；
    3. 再修改内存数据页中的 age 为 25；
    4. 若事务执行 `ROLLBACK`，则通过 undo log 将 age 恢复为 20；
    5. 事务提交后，undo log 不会立即删除，会被放入 “undo 日志链表”，后续由 purge 线程异步清理（释放空间）。

##### （2）关键特点

- 逻辑日志：记录 “修改前的状态”，而非物理修改，支持回滚；
- 事务隔离：MVCC（多版本并发控制）依赖 undo log 实现快照读（读取历史版本数据）。

### 面试总结（直接背）

#### 1. 间隙锁触发条件

- 引擎 + 隔离级别：InnoDB + RR（可重复读）；
- 索引：必须有 B+ 树索引（无索引退化为表锁）；
- 操作：范围查询（`>`/`<`/`BETWEEN`）或非唯一索引等值查询（含当前读，如 `FOR UPDATE`）。

#### 2. redo log 记录时机

- 事务执行过程中，**修改数据页前**（WAL 机制），实时记录数据页的物理修改；
- 事务提交时，将 redo log buffer 刷到磁盘，确保持久性。

#### 3. undo log 记录时机

- 事务执行 `INSERT`/`UPDATE`/`DELETE` 前，先记录数据的「原始逻辑状态」；
- 用于事务回滚和 MVCC 快照读，事务提交后异步清理。
