## [阿里钉钉文档协同 Java二面 5.10](https://www.nowcoder.com/discuss/618544524373004288?sourceSSR=users)


### 1. Java 中 int 多少字节？Java 有几种基本类型？



- **int 字节数**：4 字节（32 位），取值范围 `-2³¹ ~ 2³¹-1`（-2147483648 ~ 2147483647）。

- Java 基本类型（8 种，分 4 类）

  ：

  | 类型分类 | 具体类型 | 字节数                            | 取值范围 / 说明                             |
    | -------- | -------- | --------------------------------- | ------------------------------------------- |
  | 整数型   | byte     | 1                                 | -128 ~ 127                                  |
  |          | short    | 2                                 | -32768 ~ 32767                              |
  |          | int      | 4                                 | 见上                                        |
  |          | long     | 8                                 | -2⁶³ ~ 2⁶³-1                                |
  | 浮点型   | float    | 4                                 | 单精度，精度约 6-7 位小数                   |
  |          | double   | 8                                 | 双精度，精度约 15-17 位小数（默认浮点类型） |
  | 字符型   | char     | 2                                 | Unicode 编码，0 ~ 65535（无负数）           |
  | 布尔型   | boolean  | 无明确规定（JVM 实现通常 1 字节） | true/false（不能用 0/1 替代）               |

- 补充：基本类型的包装类（如 Integer、Boolean）是引用类型，默认值为 null。

### 2. ArrayList 和 LinkedList 区别？



核心区别：**底层数据结构不同**，导致操作效率、内存占用差异，本质是「数组 vs 链表」的区别。

| 维度                   | ArrayList                                                    | LinkedList                                         |
| ---------------------- | ------------------------------------------------------------ | -------------------------------------------------- |
| 底层结构               | 动态数组（Object []）                                        | 双向链表（JDK 1.7+ 无循环）                        |
| 访问效率（get/set）    | O (1)（随机访问，直接通过索引定位）                          | O (n)（需遍历链表查找节点）                        |
| 增删效率（add/remove） | 尾部增删 O (1)；中间增删 O (n)（需移动后续元素）             | 任意位置增删 O (1)（找到节点后，仅改指针）         |
| 内存占用               | 连续内存，浪费少量预留空间（扩容时）                         | 非连续内存，每个节点额外存储前后指针（内存开销大） |
| 线程安全               | 不安全（多线程操作需手动加锁 / 用 Collections.synchronizedList） | 不安全（同上）                                     |
| 适用场景               | 频繁查询、少量增删（如数据展示、分页查询）                   | 频繁增删、少量查询（如队列、栈操作）               |

- 补充：ArrayList 扩容机制（默认初始容量 10，扩容时按 1.5 倍扩容，拷贝旧数组到新数组）。

### 3. HashMap 冲突解决？



HashMap 核心是「数组 + 链表 / 红黑树」，冲突解决分 3 个层面：

1. 冲突预防

   ：通过「扰动函数（hash 算法）」让 key 的哈希值分布更均匀，减少冲突概率。

    - JDK 8 哈希算法：`(key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16)`（高 16 位与低 16 位异或，增强低位随机性）。

2. 冲突解决

   ：

    - 拉链法（核心）：数组每个位置（桶）存储一个链表，冲突的 key 会被加到链表尾部。
    - 红黑树优化（JDK 8+）：当链表长度超过阈值（默认 8），且数组容量 ≥ 64 时，链表转为红黑树（查询效率从 O (n) 提升到 O (log n)）；当链表长度 ≤ 6 时，红黑树转回链表（减少红黑树维护开销）。

3. **扩容缓解冲突**：当数组使用率（负载因子，默认 0.75）达到阈值，数组容量翻倍（扩容为 2 倍），重新计算所有 key 的哈希值并迁移到新数组（rehash），分散冲突节点。

### 4. OOM 的原理？



- **OOM（OutOfMemoryError）定义**：JVM 堆、方法区、栈等内存区域中，申请的内存超过了该区域的最大限制，且无法通过垃圾回收释放足够内存时抛出的异常。

- 核心原理

  ：

    1. 内存分配需求 > 内存可用空间（或内存限制）；
    2. 垃圾回收器（GC）无法回收足够的 “无用内存”（如内存泄漏导致对象长期存活，或大对象直接占满内存）。

- 常见 OOM 场景

  ：

    - 堆 OOM（最常见）：创建大量对象（如循环创建对象且不释放），堆内存不足（`-Xms`/`-Xmx` 限制）；
    - 方法区 OOM（JDK 8 后为元空间）：加载大量类（如动态代理、Spring 大量 Bean），元空间内存不足（`-XX:MetaspaceSize`/`-XX:MaxMetaspaceSize`）；
    - 栈 OOM（StackOverflowError 严格不算 OOM，但常被关联）：递归调用过深（栈帧过多），或线程栈太小（`-Xss` 限制）；
    - 直接内存 OOM：使用 NIO 的 DirectByteBuffer 分配大量直接内存（不受堆限制，但受物理内存限制）。

### 5. JVM 组成部分？



JVM 核心由 **5 大组件** 组成，协同完成类加载、内存管理、执行字节码：

1. **类加载子系统**：负责加载 `.class` 文件到内存（加载、验证、准备、解析、初始化），依赖类加载器（Bootstrap/Extension/System/WebApp）和双亲委派模型；

2. 运行时数据区（内存区域）

   ：JVM 内存核心，分为：

    - 线程共享区：堆（对象存储）、方法区（元空间，存储类信息、常量、静态变量）；
    - 线程私有区：程序计数器（PC，记录当前线程执行位置）、虚拟机栈（栈帧，存储局部变量、方法调用）、本地方法栈（Native 方法调用）；

3. 执行引擎

   ：负责执行字节码，核心组件：

    - 解释器（逐行解释字节码，启动快、执行慢）；
    - 即时编译器（JIT，热点代码编译为机器码，执行快）；
    - 垃圾回收器（GC，回收堆 / 方法区的无用对象，释放内存）；

4. **本地方法接口（JNI）**：连接 Java 代码和 Native 代码（C/C++），如 `System.currentTimeMillis()` 底层调用 Native 方法；

5. **虚拟机栈（补充）**：每个线程对应一个虚拟机栈，每个方法调用对应一个栈帧（入栈 / 出栈），存储局部变量表、操作数栈、方法返回地址等。

### 6. volatile 关键字原理？



volatile 是 Java 轻量级同步关键字，核心作用：**保证可见性、禁止指令重排序，不保证原子性**。

- 原理（底层依赖 CPU 内存屏障）

  ：

    1. **可见性**：当一个线程修改 volatile 变量时，JVM 会强制将该变量的修改写入主内存，并使其他线程的工作内存中该变量的缓存失效，后续读取需从主内存重新加载（避免 “缓存一致性问题”）；
    2. **禁止指令重排序**：JVM 会为 volatile 变量添加「内存屏障」（CPU 指令），阻止其前后的指令被重排序（如 DCL 单例中，volatile 防止 `instance = new Singleton()` 被拆分为 “分配内存→初始化对象→赋值引用” 的重排序，避免拿到未初始化的对象）；

- **局限性**：不保证原子性（如 `volatile int i = 0; i++` 仍会有线程安全问题，需配合 synchronized 或 AtomicInteger）；

- **适用场景**：状态标记（如 `volatile boolean flag = false;`）、双重检查锁定（DCL）单例。

### 7. InnoDB 用的什么结构？InnoDB 数据页大小？



- InnoDB 核心结构

  ：

    1. 索引结构：

       B+ 树

       （聚簇索引 + 辅助索引）；

        - 聚簇索引：以主键为索引键，叶子节点存储完整数据行（表数据即索引，索引即数据）；
        - 辅助索引：叶子节点存储主键值（查询时需通过主键回表查询完整数据）；

    2. 存储结构：表空间 → 段（Segment）→ 区（Extent，64 个连续数据页）→ 数据页（Page）→ 行（Row）。

- **InnoDB 数据页大小**：默认 **16KB**（可通过 `innodb_page_size` 配置，支持 4KB/8KB/16KB/32KB/64KB，但需在初始化数据库时指定，后续不可修改）。

### 8. 数据表可以存多少索引？索引越多越好吗？



- 数据表最多索引数

  ：

    - MySQL 中，单表索引数无明确上限，但受限于存储引擎和表结构：
        - InnoDB 单表索引数建议不超过 10 个（过多会导致优化器选择困难、写入性能下降）；
        - 每个索引的字段数最多 16 个（`innodb_max_index_columns` 配置，默认 16）。

- 索引不是越多越好

  ：

    - 弊端 1：占用大量存储空间（索引本质是 B+ 树，每个索引都需要独立的存储空间）；
    - 弊端 2：降低写入性能（INSERT/UPDATE/DELETE 时，需同步维护所有相关索引的 B+ 树结构，索引越多，维护开销越大）；
    - 弊端 3：优化器选择负担（索引过多时，MySQL 优化器可能选错索引，导致查询效率下降）。

### 9. 不在乎空间大小，索引越多越好吗？



- 依然不好！核心问题不在 “空间”，而在 “写入性能” 和 “优化器效率”：
    1. 写入维护开销：即使不在乎空间，每次写入数据（如新增商品）都要更新所有索引的 B+ 树（调整节点、分裂页、平衡树结构），索引越多，写入耗时越长（如 10 个索引的表，写入速度可能是 2 个索引表的 1/5）；
    2. 优化器误判风险：索引过多时，优化器需要遍历所有可能的索引组合，选择最优执行计划，可能因统计信息不准或组合过多导致选错索引（如明明用辅助索引更快，却选了聚簇索引）；
- 结论：索引应 “按需创建”，只保留高频查询的字段组合（如查询条件、排序字段、分组字段），冗余索引必须删除。

### 10. 频繁更改的数据加的索引，是主动维护还是自动维护？



- 自动维护

  ：开发者无需手动干预，MySQL 存储引擎（如 InnoDB）会在数据发生变更（INSERT/UPDATE/DELETE）时，

  自动更新相关索引的 B+ 树结构

  ：

    - 例如：修改某行的 `name` 字段（该字段是辅助索引），InnoDB 会自动找到该索引对应的 B+ 树节点，删除旧值对应的条目，插入新值对应的条目，并维持 B+ 树的平衡性（如页分裂、页合并）；

- 补充：维护开销是 “自动” 的，但代价是写入性能下降（频繁更改的数据，索引维护成本更高，因此这类字段应尽量少建索引）。

### 11. 索引使用不当会失效，用强制索引（FORCE INDEX）不就行了吗？



- 不推荐！强制索引是 “治标不治本”，甚至可能导致更差的性能：
    1. 索引失效的本质是 “查询条件与索引不匹配”（如函数操作索引字段、隐式类型转换），此时索引本身无法高效过滤数据，强制使用会导致：
        - 全索引扫描（而非索引范围扫描），效率可能比全表扫描还低（如索引字段是字符串，查询时用数字匹配，隐式转换导致失效，强制索引后需扫描整个索引树）；
    2. 优化器的动态调整能力丧失：MySQL 优化器会根据数据分布（如字段基数、数据量）动态选择最优索引，强制索引会忽略优化器的判断（如后续数据分布变化，原强制索引不再适合，需手动修改 SQL）；
- 正确做法：优化查询 SQL 和索引设计（如避免函数操作索引字段、显式类型转换），让优化器自然选择合适的索引；仅在优化器明确误判（如统计信息过时）时，临时用强制索引，并及时更新统计信息（`ANALYZE TABLE`）。

### 12. 索引失效场景（is not null、in、or）？



#### （1）`select id from t where col is not null` 会失效吗？



- 不一定失效

  ，取决于字段是否为「稀疏字段」（大部分值为 null）：

    - 若字段非稀疏（大部分值非 null）：索引失效，优化器会选择全表扫描（因为 `is not null` 过滤后的数据量太大，索引扫描不如全表扫描高效）；
    - 若字段是稀疏（大部分值为 null，少量非 null）：索引有效，优化器会通过索引快速定位非 null 的数据（B+ 树会存储 null 值，可快速过滤）；

- 核心原因：索引的价值是 “过滤大量数据”，若查询条件无法有效过滤（返回数据占比 > 20%），优化器会放弃索引。

#### （2）`select id from t where col in (...)` 会失效吗？



- 一般不失效

  ，

  ```
  in
  ```



是索引友好的操作：

- 原理：`in` 本质是多个 `or` 条件的集合，MySQL 优化器会将 `in` 转换为 “索引范围扫描”（如 `col in (1,2,3)` 会扫描索引中 1、2、3 对应的节点）；

- 失效场景：`in` 后面的取值过多（如超过 1000 个值），或字段基数极低（如性别字段，只有男 / 女），优化器可能认为索引扫描效率低，选择全表扫描；

- 补充：`not in` 可能失效（尤其是非主键索引），因为 `not in` 过滤后的数据量可能过大，建议用 `left join ... is null` 替代。

#### （3）`select id from t where col1 = ? or col2 = ?` 会失效吗？



- 取决于是否有联合索引

  ：

    - 若 col1 和 col2 是独立的单字段索引：索引失效，优化器会选择全表扫描（因为 `or` 连接两个独立索引，优化器无法同时利用两个索引，需扫描两个索引后合并结果，效率不如全表扫描）；
    - 若有联合索引 `(col1, col2)` 或 `(col2, col1)`：索引有效（仅当查询条件匹配联合索引的前缀时）；
    - 若 col1 是主键 / 唯一索引：`or` 后的条件可能利用索引（优化器会选择主键索引扫描 + 其他条件过滤）；

- 优化方案：将 `or` 拆分为两个 `union all` 查询（如 `select id from t where col1 = ? union all select id from t where col2 = ?`），分别利用两个单字段索引，效率更高。

### 13. Spring、SpringMVC、SpringBoot 关系？



核心关系：**Spring 是基础核心，SpringMVC 是 Spring 的 Web 子框架，SpringBoot 是 Spring 的 “脚手架”（简化配置）**，三者一脉相承，不是替代关系。

- Spring

  ：

    - 核心定位：IoC（控制反转）和 AOP（面向切面编程）容器，管理 Bean 的创建、依赖注入、生命周期；
    - 作用：解耦业务组件，提供事务管理、数据访问、缓存等核心功能，是整个生态的基础。

- SpringMVC

  ：

    - 核心定位：基于 Spring 的 Web 框架，处理 HTTP 请求（MVC 模式）；
    - 作用：封装 Servlet，提供 DispatcherServlet（前端控制器）、HandlerMapping（处理器映射）、ViewResolver（视图解析器）等组件，简化 Web 开发（如 Controller 层开发）；
    - 依赖：必须基于 Spring 容器，Bean（如 Controller、Service）由 Spring 管理。

- SpringBoot

  ：

    - 核心定位：Spring 的 “自动配置 + starter 依赖” 脚手架，简化 Spring 应用的搭建和部署；
    - 核心特性：自动配置（无需手动写 XML 或 JavaConfig）、starter 依赖（如 `spring-boot-starter-web` 包含 SpringMVC + Tomcat）、嵌入式服务器（Tomcat/Jetty）、Actuator 监控；
    - 依赖：内置 Spring 和 SpringMVC（若引入 `spring-boot-starter-web`），本质是对 Spring 生态的封装，让开发者 “开箱即用”。

### 14. 秒杀场景：Redis 集群仅支持几万 QPS，如何应对几十万请求？



除了消息队列削峰，核心思路是 **“多层限流 + 缓存前置 + 业务优化”**，形成 “流量拦截漏斗”：

#### （1）前端限流（最外层拦截）



- 按钮置灰：秒杀开始后，按钮置灰，防止用户重复点击（避免无效请求）；
- 验证码 / 滑动验证：秒杀前要求用户输入验证码或完成滑动验证，过滤机器人请求（减少 50% 以上无效流量）；
- 前端限流：限制单个用户单位时间内的请求次数（如 10 秒内最多 3 次请求）。

#### （2）接入层限流（Nginx 层面）



- Nginx 限流：用 `ngx_http_limit_req_module` 模块，限制单 IP 单位时间内的请求数（如 1 秒内最多 5 次），直接拦截超量请求（返回 503）；
- 静态资源缓存：将秒杀页面的 CSS、JS、图片等静态资源缓存到 CDN，减少回源请求。

#### （3）应用层限流（服务端）



- 接口限流：用 Guava RateLimiter（令牌桶算法）或 Sentinel，限制单个服务实例的 QPS（如 1 万 QPS），超量请求返回 “秒杀拥挤”；
- 分布式限流：用 Redis + Lua 脚本，实现全集群统一限流（如整个集群最多 5 万 QPS），避免单实例限流不均衡。

#### （4）缓存前置优化（减轻 Redis 压力）



- 本地缓存：将秒杀商品的静态信息（如商品 ID、库存数）缓存到应用服务器本地（如 Caffeine），用户请求先查本地缓存，再查 Redis（减少 80% Redis 访问）；
- 热点 Key 分片：将秒杀商品的库存 Key 拆分为多个子 Key（如 `stock_1001_0` ~ `stock_1001_9`），分散到 Redis 集群不同节点，避免单节点压力过大。

#### （5）业务层优化（减少无效请求）



- 库存预扣减：Redis 中预扣减库存（如 `decr stock_1001`），预扣减失败直接返回 “已售罄”，避免无效请求穿透到数据库；
- 防止超卖：Redis 预扣减 + 数据库最终一致性校验（用乐观锁 `where id = ? and stock > 0`）；
- 异步化处理：消息队列不仅削峰，还能异步处理订单创建、库存扣减、物流通知等流程，提升响应速度。

#### （6）数据库优化



- 分库分表：将订单表、库存表分库分表（如按商品 ID 哈希分片），分散数据库压力；
- 库存表行锁优化：用主键更新库存（`update stock set num = num -1 where id = ? and num > 0`），避免表锁，提升并发更新能力。

### 15. 上一问除了消息队列削峰、异步，还有啥办法？



承接上一题，核心补充：**多层限流（前端 / Nginx / 应用层）、本地缓存、热点 Key 分片、分布式限流、业务过滤（验证码 / 预扣减）**。

- 关键逻辑：流量是 “层层递减” 的，最外层（前端 / Nginx）拦截大部分无效流量，中间层（应用层 / Redis）拦截剩余流量，最后只有少量有效流量到达数据库，避免任何一层被压垮。

### 16. Nginx 是单线程还是多线程？为什么能处理上万并发？



- Nginx 线程模型

  ：默认是「单进程 + 多线程」（Linux 下），或「多进程 + 多线程」，核心是



IO 多路复用（epoll）



机制，而非依赖多线程数量。

- 单进程模式：一个主进程（管理配置、信号）+ 多个工作进程（每个工作进程是单线程，处理请求）；
- 多线程模式：部分版本支持工作进程内启用多线程，但核心仍是 IO 多路复用。

- 为什么能处理上万并发？核心是 “非阻塞 IO + IO 多路复用”

  ：

    1. **非阻塞 IO**：Nginx 对所有网络请求采用非阻塞模式，当一个请求发起后，不会等待后端响应（如 Redis / 数据库），而是继续处理其他请求，直到后端响应就绪；
    2. **IO 多路复用（epoll）**：用 epoll 机制（Linux 内核提供），一个线程可以同时监听成千上万个网络连接（文件描述符），当某个连接的 IO 事件（如数据到达、连接关闭）就绪时，epoll 会通知 Nginx 处理，避免线程阻塞在单个连接上；
    3. **轻量级进程 / 线程**：工作进程是轻量级的，每个进程 / 线程占用内存少（通常每个工作进程占用几 MB 内存），可以启动多个工作进程（如等于 CPU 核心数），充分利用多核资源；
    4. **事件驱动模型**：Nginx 基于事件驱动（Event-Driven），所有请求都由事件触发，没有多余的线程切换开销（区别于 Tomcat 的 “一个请求一个线程” 模型，线程切换开销大，并发量受限）。

- 对比 Tomcat：Tomcat 默认是 “BIO 模型”（一个请求一个线程），线程数量有限（默认 200 左右），并发量受限；而 Nginx 一个工作线程可处理成千上万的连接，因此并发能力远超 Tomcat。