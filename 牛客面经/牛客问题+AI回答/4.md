## [京东 java 一面 60min](https://www.nowcoder.com/feed/main/detail/9e28b7609d03434ab119ce8ee7191755?sourceSSR=users)



### 1. synchronized 与 ReentrantLock 实现对比



| 维度     | synchronized                                                 | ReentrantLock（JUC）                                |
| -------- | ------------------------------------------------------------ | --------------------------------------------------- |
| 实现方式 | JVM 层面的内置锁（字节码指令 `monitorenter/monitorexit`）    | 基于 AQS（AbstractQueuedSynchronizer）的 API 层面锁 |
| 锁类型   | 可重入、非公平锁（默认）；JDK 6 后支持公平锁（极少用）       | 可重入、支持公平 / 非公平锁（构造函数指定）         |
| 灵活度   | 低（仅支持代码块 / 方法锁）                                  | 高（可中断锁、超时锁、条件变量 `Condition`）        |
| 释放方式 | 自动释放（异常 / 方法结束）                                  | 必须手动释放（`finally` 中调用 `unlock()`）         |
| 性能     | JDK 6 锁升级后（偏向锁→轻量级锁→重量级锁），性能接近 ReentrantLock | 并发高时性能稳定，公平锁性能略差（排队开销）        |
| 适用场景 | 简单并发场景（如单例、简单方法同步）                         | 复杂并发场景（如超时等待、多条件唤醒、中断需求）    |

### 2. synchronized 与 ReentrantLock 底层原理（操作系统 + 锁升级）



#### （1）synchronized 底层原理 + 锁升级（JDK 6+）



- **核心逻辑**：基于 **对象头（Mark Word）** 和 **监视器锁（Monitor）** 实现，锁升级是 “按需升级”（从乐观锁到悲观锁，减少开销）。

- **对象头 Mark Word 结构**：存储锁状态、HashCode、偏向线程 ID 等，是锁升级的关键载体。

- 锁升级流程

  （重点！）：

    1. **无锁状态**：对象刚创建，Mark Word 存储 HashCode，无锁竞争。

    2. 偏向锁

       ：单线程多次获取锁时，直接在 Mark Word 记录偏向线程 ID，

       无 CAS 操作

       ，开销极低。

        - 触发条件：单线程重复进入同步块。
        - 撤销条件：有其他线程竞争时，暂停偏向线程，升级为轻量级锁。

    3. 轻量级锁

       ：多线程交替获取锁（无激烈竞争），通过

       CAS 修改 Mark Word

       实现 “自旋锁”，避免操作系统内核态切换。

        - 原理：线程获取锁时，将 Mark Word 复制到线程栈的 “锁记录（Lock Record）”，再用 CAS 把 Mark Word 改为锁记录指针。
        - 撤销条件：自旋超过阈值（默认 10 次）或多个线程同时竞争，升级为重量级锁。

    4. 重量级锁

       ：激烈竞争时，依赖

       操作系统的互斥量（Mutex）

       实现，线程竞争失败会进入

       阻塞状态（内核态）

       ，开销最大。

        - 底层：Monitor 是操作系统级别的 “对象监视器”，包含等待队列（EntryList）、拥有者线程、等待队列（WaitSet），竞争失败的线程会被阻塞并放入 EntryList。

#### （2）ReentrantLock 底层原理



- 核心：基于

  AQS（抽象队列同步器）

    -

  CAS

  实现，AQS 是一个 “双向链表 + 状态变量” 的同步框架。

    - AQS 核心属性：`state`（锁状态，0 = 空闲，>0 = 持有，支持重入）、`head/tail`（等待队列的头尾节点）。
    - 非公平锁（默认）：线程获取锁时先 CAS 抢锁，失败再入队；公平锁：先检查队列是否有等待线程，有则入队，无则 CAS 抢锁。
    - 可重入：获取锁时判断当前线程是否为持有线程，若是则 `state++`，释放时 `state--` 直到 0。
    - 条件变量 `Condition`：基于 AQS 的等待队列实现，支持 “分组唤醒”（区别于 synchronized 的 `wait()/notify()` 随机唤醒）。

#### 操作系统层面差异



- synchronized 重量级锁：依赖 OS 的 **Mutex（互斥量）**，线程阻塞 / 唤醒需切换内核态（开销大）。
- ReentrantLock：基于用户态的 CAS + 自旋，仅在竞争激烈时才可能触发阻塞（依赖 AQS 的 LockSupport.park ()，底层是 OS 的 pthread_mutex）。

### 3. 垃圾收集器（面试官口误纠正后的核心题）



JVM 垃圾收集器（基于 HotSpot）按 “分代” 和 “并发特性” 分类，核心常用收集器如下：

| 收集器                 | 分代类型                         | 回收算法           | 并发特性           | STW 情况                         | 适用场景                             |
| ---------------------- | -------------------------------- | ------------------ | ------------------ | -------------------------------- | ------------------------------------ |
| Serial（串行收集器）   | 新生代                           | 复制算法           | 单线程             | 全程 STW（停顿时间长）           | 单 CPU、客户端应用（如桌面 APP）     |
| Serial Old             | 老年代                           | 标记 - 整理算法    | 单线程             | 全程 STW（停顿时间长）           | 客户端应用、低内存场景               |
| ParNew（并行收集器）   | 新生代                           | 复制算法           | 多线程             | 全程 STW（停顿比 Serial 短）     | 多 CPU、服务端应用（配合 CMS）       |
| Parallel Scavenge      | 新生代                           | 复制算法           | 多线程             | 全程 STW（停顿可控）             | 追求高吞吐量（计算密集型）           |
| Parallel Old           | 老年代                           | 标记 - 整理算法    | 多线程             | 全程 STW（停顿比 Serial Old 短） | 配合 Parallel Scavenge，高吞吐量场景 |
| CMS（并发标记清除）    | 老年代                           | 标记 - 清除算法    | 并发（大部分阶段） | 初始标记 / 重新标记 STW（短）    | 追求低延迟（如 Web 应用）            |
| G1（垃圾优先）         | 混合分代（逻辑分代，物理不分代） | 复制 + 标记 - 整理 | 并发（大部分阶段） | 初始标记 / 重新标记 STW（短）    | 大内存（>4G）、低延迟 + 高吞吐量     |
| ZGC/Shenandoah（补充） | 不分代                           | 标记 - 复制（ZGC） | 几乎全程并发       | STW 极短（毫秒级）               | 超大内存（>16G）、核心业务           |

### 4. 垃圾收集器对比（重点：Serial/Parrel/CMS/G1）



#### （1）Serial vs Parallel（串行 vs 并行）



- 核心区别：

  线程数

  和

  STW 时间

  。

    - Serial：单线程回收，STW 时间长（比如 1G 内存可能停顿几百毫秒），但开销小（无线程切换）。
    - Parallel（ParNew/Parallel Scavenge）：多线程回收，STW 时间大幅缩短（比如 1G 内存停顿几十毫秒），适合多 CPU 服务器。
    - 补充：Parallel Scavenge 是 “吞吐量优先” 收集器，支持 “自适应调节”（自动调整堆大小、晋升阈值等），而 ParNew 是为了配合 CMS 设计的（CMS 只能用 ParNew/Serial 作为新生代收集器）。

#### （2）CMS vs G1



| 维度     | CMS                                                          | G1                                                         |
| -------- | ------------------------------------------------------------ | ---------------------------------------------------------- |
| 分代模型 | 老年代收集器（需配合 ParNew/Serial）                         | 混合分代（逻辑分代：Eden/Survivor/Old，物理不分代）        |
| 回收算法 | 标记 - 清除（会产生内存碎片）                                | 标记 - 整理（老年代）+ 复制（新生代 / 混合回收），无碎片   |
| 并发特性 | 并发标记 / 并发清除（仅初始标记 / 重新标记 STW）             | 初始标记 / 重新标记 / 筛选回收 STW（筛选回收可并行）       |
| 内存管理 | 固定区域大小（Eden/Old 区比例固定）                          | 动态区域大小（Region，2MB~32MB），可灵活调整回收范围       |
| 停顿控制 | 低延迟，但无法预测（可能出现 “Concurrent Mode Failure” 导致 Full GC） | 可预测停顿（通过 `-XX:MaxGCPauseMillis` 指定目标停顿时间） |
| 适用内存 | 中小内存（<8G）                                              | 大内存（>4G，推荐 8G+）                                    |
| 缺点     | 内存碎片、CPU 占用高（并发阶段占用 CPU 资源）、Full GC 代价大 | 复杂度高、小内存场景开销比 CMS 略高                        |

#### （3）核心结论



- 追求吞吐量：Parallel Scavenge + Parallel Old。
- 追求低延迟（Web 应用）：CMS（中小内存）或 G1（大内存）。
- 客户端 / 低内存：Serial + Serial Old。

### 5. G1 的分代模式与 STW 影响



#### （1）G1 的分代模式（逻辑分代，物理不分代）



- 核心设计：将堆内存划分为

  多个大小相等的独立 Region（区域）

  ，每个 Region 可动态扮演 Eden/Survivor/Old/Humongous（大对象区）角色。

    - 逻辑分代：保留新生代（Eden+Survivor）和老年代概念，但物理上没有固定的 Eden/Old 区，Region 角色可动态切换。
    - 大对象处理：超过 Region 大小 50% 的对象放入 Humongous Region，直接晋升为老年代（避免复制开销）。
    - 回收目标：优先回收 “垃圾比例高” 的 Region（Garbage-First），通过 “混合回收（Mixed GC）” 同时回收新生代 + 部分老年代 Region。

#### （2）对 STW 的影响



G1 的 STW 仅发生在 3 个阶段，且停顿时间**可预测、可控制**：

1. **初始标记（Initial Mark）**：标记 GC Roots 直接关联的对象，STW 时间极短（毫秒级）。
2. **重新标记（Remark）**：修正并发标记阶段因线程运行导致的 “漏标” 对象，STW 时间比 CMS 短（通过 “SATB（原始快照）” 算法优化，减少重新标记工作量）。
3. **筛选回收（Live Data Counting and Evacuation）**：筛选出垃圾比例高的 Region，将存活对象复制到空 Region（复制算法），此阶段可并行执行，STW 时间可通过 `-XX:MaxGCPauseMillis` 控制（默认 200ms）。

- 优势：通过 “动态 Region + 混合回收”，避免了 CMS 的内存碎片和 Full GC 风险，同时 STW 时间更可控，适合大内存场景。
- 注意：若 `-XX:MaxGCPauseMillis` 设置过严（如 10ms），可能导致 G1 频繁触发回收，反而降低吞吐量。

### 6. Redis 底层数据结构（SDS、ZipList、SkipList）



Redis 对外提供的 5 种数据类型（string/hash/list/set/zset），底层依赖 “底层数据结构” 实现，核心 3 种如下：

#### （1）SDS（简单动态字符串）—— 实现 string 类型



- 替代 C 语言原生字符串（char []），解决 C 字符串 “长度计算 O (n)、缓冲区溢出、不可修改” 等问题。

- 结构（Redis 3.2+ 优化为柔性数组）：

  c

  运行

  ```
  struct __attribute__ ((__packed__)) sdshdr8 {
      uint8_t len;    // 已使用字节数（O(1)获取长度）
      uint8_t alloc;  // 总分配字节数（不含头部和null终止符）
      unsigned char flags; // 类型标记（sdshdr8/16/32/64）
      char buf[];     // 柔性数组，存储字符串内容
  };
  ```



- 核心优势：

    1. 长度计算 O (1)（len 字段直接记录）。
    2. 空间预分配：扩容时额外分配 1~2 倍空间（避免频繁扩容）。
    3. 惰性释放：缩短字符串时不立即回收空间，仅修改 len（后续可复用）。
    4. 二进制安全：不依赖 null 终止符，可存储图片、视频等二进制数据。

#### （2）ZipList（压缩列表）—— 实现 hash/list/zset（小数据场景）



- 定义：紧凑的顺序存储结构，用于存储 “少量、小尺寸” 的键值对 / 元素（如 hash 的 field-value 少且小，list 元素少且小），目的是**节省内存**。
- 结构：由多个 “entry（元素）” 和 “zlbytes（总长度）、zltail（尾元素偏移）、zllen（元素个数）、zlend（结束标记）” 组成。
- 优势：内存紧凑（无指针开销），遍历快；缺点：插入 / 删除元素时需 “移动后续元素”，时间复杂度 O (n)，大数据量时性能差。
- 升级条件：当元素个数超过 `hash-max-ziplist-entries`（默认 512）或元素大小超过 `hash-max-ziplist-value`（默认 64 字节），自动升级为 HashTable（hash）/LinkedList（list）/SkipList（zset）。

#### （3）SkipList（跳表）—— 实现 zset（有序集合）



- 定义：多层有序链表，是 “平衡树” 的高效替代方案，支持 O (log n) 的插入、删除、查找。
- 结构：
    - 底层是一个有序链表（最下层）。
    - 每个节点有多个 “索引层”，上层索引是下层的 “稀疏采样”（如每 2 个节点取一个上层索引）。
    - 查找时从最上层索引开始，快速跳过无效节点，最终落到最下层链表找到目标。
- 核心优势：
    1. 插入 / 删除无需旋转（区别于红黑树），实现简单。
    2. 并发性能好（红黑树需全局锁，跳表可局部锁）。
- Redis 中的优化：
    - 每个节点存储 `score`（分数）和 `member`（成员），按 score 排序。
    - 同一 score 的节点按 member 字典序排序。
    - 索引层数随机生成（1~32 层，遵循幂次定律，避免层级过高）。

### 7. Redis 热 Key 问题（生产环境实践）



#### （1）什么是热 Key？



- 定义：某一个 Key 的访问频率极高（如每秒上万次），导致 Redis 单节点 CPU 使用率飙升（甚至 100%），成为系统瓶颈。
- 场景：秒杀活动的商品 Key、热门新闻的阅读量 Key、高频查询的缓存 Key（如用户信息、商品详情）。

#### （2）生产环境遇到的情况（举例）



- 业务场景：电商秒杀，某商品 ID 为`goods_1001`的 Key，秒杀开始后每秒访问量达 5 万 +，单 Redis 节点 CPU 飙升至 95%，导致其他 Key 查询超时。
- 数据比例：热 Key 占总 Key 数的 0.1% 以下，但贡献了 80% 以上的访问量。

#### （3）解决方案（从易到难）



1. 本地缓存（多级缓存）

   ：

    - 思路：将热 Key 缓存到应用服务器的本地缓存（如 Caffeine、Guava Cache），减少 Redis 访问次数。
    - 注意：本地缓存需设置较短过期时间（如 1 分钟），避免数据不一致；结合 “主动更新”（如 Redis 数据更新时，通过消息队列通知应用更新本地缓存）。

2. Key 分片（分散压力）

   ：

    - 思路：将一个热 Key 拆分为多个子 Key（如`goods_1001_0`~`goods_1001_9`），分散到多个 Redis 节点。
    - 实现：应用层通过哈希取模（如`hash(member) % 10`）选择子 Key，查询时随机选择一个子 Key，更新时同步所有子 Key。

3. Redis 集群扩容 / 主从分离

   ：

    - 思路：热 Key 所在的主节点压力大，可增加从节点，将读请求分流到从节点（读写分离）。
    - 注意：需解决主从同步延迟问题（如允许少量脏读，或使用 Redis Cluster 的就近访问）。

4. 禁用缓存穿透 / 雪崩的兜底方案

   ：

    - 热 Key 过期时，避免 “缓存击穿”（大量请求穿透到 DB）：设置互斥锁（如 Redis 的 SETNX），只有一个线程去 DB 加载数据并更新缓存，其他线程等待。
    - 淘汰策略：热 Key 场景下，避免使用`volatile-lru`（可能淘汰热 Key），推荐使用`noeviction`（不淘汰，内存满时返回错误）或`allkeys-lru`（淘汰所有 Key 中最近最少使用的，需确保热 Key 访问频繁不被淘汰）。

5. 终极方案：业务优化

   ：

    - 若热 Key 是统计类数据（如阅读量），可采用 “异步更新”（本地累计 + 定时批量同步到 Redis），减少实时写请求。
    - 避免使用过大的 Value（如 10KB 以上），拆分 Value 为多个小 Key，减少单次请求的 CPU 开销。

### 8. Tomcat 加载一个包的完整过程（类加载机制）



Tomcat 的类加载是 “打破双亲委派模型” 的典型实现，核心目标是：**隔离不同 Web 应用的类（避免类冲突）**，同时支持热部署。

#### 完整流程（以加载一个 Web 应用的`com.example.Demo.class`为例）



1. 类加载器层次结构（从父到子）

   ：

    - Bootstrap ClassLoader（启动类加载器）：JVM 内置，加载`JAVA_HOME/lib`下的核心类（如`rt.jar`）。
    - Extension ClassLoader（扩展类加载器）：加载`JAVA_HOME/lib/ext`下的扩展类。
    - System ClassLoader（应用类加载器）：加载`classpath`下的类（如 Tomcat 自身的核心类）。
    - **Catalina ClassLoader**：加载 Tomcat 服务器自身的类（如`org.apache.catalina.*`），隔离 Web 应用。
    - **Shared ClassLoader**：加载所有 Web 应用共享的类（如第三方依赖`spring-core.jar`，可配置`shared.loader`）。
    - **WebApp ClassLoader**：每个 Web 应用独有的类加载器，加载`WEB-INF/classes`和`WEB-INF/lib`下的类。
    - **Jsp ClassLoader**：每个 JSP 页面的类加载器，支持 JSP 热部署（修改 JSP 后重新编译，销毁旧 ClassLoader，创建新的）。

2. 加载过程（打破双亲委派，“先子后父”）

   ：

    - 步骤 1：WebApp ClassLoader 收到类加载请求（加载`com.example.Demo`）。
    - 步骤 2：先检查自身的 “已加载类缓存”，若已加载直接返回。
    - 步骤 3：若未加载，优先加载`WEB-INF/classes`下的类（自己的类），再加载`WEB-INF/lib`下的 Jar 包中的类。
    - 步骤 4：若自身未找到，委托给父类加载器（Shared → Catalina → System → Extension → Bootstrap）。
    - 步骤 5：若所有父类加载器都未找到，抛出`ClassNotFoundException`。

3. 关键特性

   ：

    - 隔离性：每个 Web 应用的 WebApp ClassLoader 独立，避免不同应用的同名类冲突（如 A 应用的`com.example.User`和 B 应用的`com.example.User`互不影响）。
    - 热部署：修改 Web 应用的类后，Tomcat 会销毁旧的 WebApp ClassLoader，创建新的，重新加载类（无需重启服务器）。
    - 共享性：Shared ClassLoader 加载的类可被所有 Web 应用共享，减少内存占用。

### 9. Servlet 底层原理 + Spring 对 Servlet 的封装



#### （1）Servlet 底层原理（承接请求的完整过程）



Servlet 是 Java EE 定义的 “服务器端组件规范”，用于处理 HTTP 请求，核心依赖 **Tomcat（Servlet 容器）** 实现。

##### 核心流程（Tomcat 处理 HTTP 请求）：



1. Tomcat 启动初始化

   ：

    - 加载`web.xml`或注解（`@WebServlet`）配置的 Servlet 类，创建 Servlet 实例（默认单例，线程不安全）。
    - 调用 Servlet 的`init(ServletConfig)`方法初始化（仅执行一次），初始化 ServletConfig（参数配置）和 ServletContext（应用上下文）。

2. 接收请求

   ：

    - Tomcat 的`Connector`（连接器）监听端口（默认 8080），接收客户端 HTTP 请求，解析请求行、请求头、请求体，封装为`HttpServletRequest`对象。
    - `Connector`将请求交给`Engine`（引擎）→`Host`（虚拟主机）→`Context`（Web 应用）→`Wrapper`（Servlet 包装器）。

3. 处理请求

   ：

    - `Wrapper`调用 Servlet 的`service(ServletRequest req, ServletResponse resp)`方法。
    - `service`方法根据请求方式（GET/POST/PUT/DELETE），分发到对应的`doGet()`/`doPost()`等方法。
    - 开发者在`doGet()`/`doPost()`中处理业务逻辑，通过`HttpServletResponse`设置响应头、响应体。

4. 响应结果

   ：

    - Tomcat 将`HttpServletResponse`对象转换为 HTTP 响应报文，返回给客户端。

5. 销毁

   ：

    - Tomcat 关闭或 Web 应用卸载时，调用 Servlet 的`destroy()`方法（仅执行一次），释放资源。

##### 核心接口 / 类：



- `Servlet`：核心接口（`init()`/`service()`/`destroy()`）。
- `GenericServlet`：抽象类，实现`Servlet`接口，简化配置（提供`getServletConfig()`/`getServletContext()`）。
- `HttpServlet`：抽象类，继承`GenericServlet`，封装 HTTP 请求处理（`service()`方法分发请求）。
- `ServletContext`：Web 应用全局上下文，共享应用级数据（如全局配置、资源路径）。
- `ServletConfig`：单个 Servlet 的配置信息（如`web.xml`中`<init-param>`）。

#### （2）Spring 对 Servlet 的封装（Spring MVC 核心）



Spring MVC 本质是 “基于 Servlet 的 MVC 框架”，通过 **DispatcherServlet（前端控制器）** 封装 Servlet，简化开发。

##### 核心封装逻辑：



1. DispatcherServlet：统一入口

   ：

    - DispatcherServlet 是一个`HttpServlet`子类，所有 HTTP 请求都先经过它（`web.xml`中配置`<url-pattern>/`）。
    - 替代了传统 Servlet 的 “一个功能一个 Servlet”，统一接收请求、分发处理。

2. 初始化阶段（IOC 容器初始化）

   ：

    - DispatcherServlet 初始化时，会创建 Spring MVC 的 IOC 容器（`WebApplicationContext`），并关联根 IOC 容器（`ApplicationContext`，由`ContextLoaderListener`创建）。
    - 加载 Spring MVC 配置（如`spring-mvc.xml`），初始化核心组件：`HandlerMapping`（处理器映射）、`HandlerAdapter`（处理器适配器）、`ViewResolver`（视图解析器）等。

3. 请求处理流程（封装 Servlet 的 service 方法）

   ：

    - 步骤 1：DispatcherServlet 接收请求，通过`HandlerMapping`根据请求 URL 找到对应的处理器（Controller 的方法，如`@RequestMapping("/user")`）。
    - 步骤 2：通过`HandlerAdapter`调用处理器方法（参数绑定、数据转换、校验），执行业务逻辑。
    - 步骤 3：处理器返回`ModelAndView`（模型数据 + 视图名称），DispatcherServlet 调用`ViewResolver`解析视图名称，得到具体视图（如 JSP、JSON）。
    - 步骤 4：渲染视图（将模型数据填充到视图），通过`HttpServletResponse`返回响应。

4. 核心封装点

   ：

    - 隐藏 Servlet 的底层细节（如`doGet()`/`doPost()`、请求参数解析），开发者只需关注 Controller 方法和业务逻辑。
    - 提供灵活的扩展点（如拦截器`HandlerInterceptor`、参数绑定`Converter`、异常处理器`HandlerExceptionResolver`）。
    - 整合 Spring IOC 容器，支持依赖注入（如 Controller 中注入 Service）。

### 10. 常用哈希算法（实际应用场景）



哈希算法是 “将任意长度数据映射为固定长度哈希值” 的算法，核心特性：不可逆、雪崩效应（输入微小变化导致哈希值大幅变化）。

| 哈希算法   | 输出长度 | 特点                         | 实际应用场景                                    |
| ---------- | -------- | ---------------------------- | ----------------------------------------------- |
| MD5        | 128 位   | 速度快，碰撞风险低（非加密） | 文件校验（如下载文件校验和）、数据指纹          |
| SHA-1      | 160 位   | 比 MD5 安全，已被破解        | 早期版本 Git 提交校验（现已弃用）               |
| SHA-256    | 256 位   | 安全强度高，速度较慢         | 区块链（比特币）、HTTPS 证书签名、数据加密校验  |
| SHA-512    | 512 位   | 安全强度极高，速度慢         | 高安全性场景（如金融数据校验）                  |
| CRC32      | 32 位    | 速度极快，碰撞风险高         | 网络数据传输校验（如 TCP 校验和）、文件快速校验 |
| MurmurHash | 32/64 位 | 速度极快，分布均匀           | Redis 哈希槽计算、Hadoop 数据分片、Guava 缓存   |

- 注意：MD5/SHA-1 不适合加密场景（可被碰撞攻击），仅用于校验；加密场景需用 SHA-256 及以上。

### 11. 常用加密算法（分类 + 应用）



加密算法分 **对称加密** 和 **非对称加密**，核心用于数据保密、身份认证。

#### （1）对称加密（加密解密用同一密钥）



- 特点：速度快、加密强度高，适合大数据量加密。
- 常用算法：
    - AES（高级加密标准）：128/192/256 位密钥，替代 DES，是目前最常用的对称加密算法。
        - 应用场景：HTTPS 传输层加密（TLS 协议）、敏感数据存储（如数据库密码加密）、文件加密（如压缩包密码）。
    - DES：56 位密钥，安全性低，已淘汰。
    - 3DES：DES 的改进版，三次加密，安全性一般，兼容旧系统。
    - RC4：流加密，速度快，已被破解，不推荐。

#### （2）非对称加密（加密解密用不同密钥：公钥 + 私钥）



- 特点：速度慢、安全性高，适合小数据量加密（如密钥交换、签名）。
- 常用算法：
    - RSA：密钥长度 1024/2048/4096 位，应用最广泛。
        - 应用场景：HTTPS 证书（公钥加密会话密钥，私钥解密）、数字签名（私钥签名，公钥验签）、SSH 登录。
    - ECC（椭圆曲线加密）：相同安全强度下，密钥长度比 RSA 短（如 256 位 ECC≈3072 位 RSA），速度快。
        - 应用场景：移动设备（如手机支付）、物联网设备（资源受限场景）。

#### （3）哈希 + 加密（签名算法）



- HMAC（哈希消息认证码）：如 HMAC-MD5、HMAC-SHA256，结合哈希算法和密钥，用于验证数据完整性和身份认证（如接口签名）。
- 应用场景：API 接口防篡改（客户端用密钥计算 HMAC，服务端验证 HMAC 是否一致）。

### 12. 二叉树前序 / 中序 / 后序遍历（递归 + 迭代实现）



#### 定义（以根节点遍历顺序划分）



- 前序遍历（根→左→右）：先访问根节点，再递归遍历左子树，最后递归遍历右子树。
- 中序遍历（左→根→右）：先递归遍历左子树，再访问根节点，最后递归遍历右子树。
- 后序遍历（左→右→根）：先递归遍历左子树，再递归遍历右子树，最后访问根节点。

#### 递归实现（简单直观）



java

运行

```
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(int x) { val = x; }
}

// 前序遍历
public void preOrder(TreeNode root) {
    if (root == null) return;
    System.out.print(root.val + " "); // 根
    preOrder(root.left); // 左
    preOrder(root.right); // 右
}

// 中序遍历
public void inOrder(TreeNode root) {
    if (root == null) return;
    inOrder(root.left); // 左
    System.out.print(root.val + " "); // 根
    inOrder(root.right); // 右
}

// 后序遍历
public void postOrder(TreeNode root) {
    if (root == null) return;
    postOrder(root.left); // 左
    postOrder(root.right); // 右
    System.out.print(root.val + " "); // 根
}
```



#### 迭代实现（面试常考，用栈模拟递归）



java

运行

```
import java.util.Stack;
import java.util.ArrayList;
import java.util.List;

// 前序遍历（栈：根→右→左，出栈顺序为根→左→右）
public List<Integer> preOrderIter(TreeNode root) {
    List<Integer> res = new ArrayList<>();
    if (root == null) return res;
    Stack<TreeNode> stack = new Stack<>();
    stack.push(root);
    while (!stack.isEmpty()) {
        TreeNode node = stack.pop();
        res.add(node.val);
        if (node.right != null) stack.push(node.right); // 右子树先入栈（后出）
        if (node.left != null) stack.push(node.left); // 左子树后入栈（先出）
    }
    return res;
}

// 中序遍历（栈：左→根→右，先压左子树，再访问根，最后压右子树）
public List<Integer> inOrderIter(TreeNode root) {
    List<Integer> res = new ArrayList<>();
    Stack<TreeNode> stack = new Stack<>();
    TreeNode curr = root;
    while (curr != null || !stack.isEmpty()) {
        while (curr != null) { // 压入所有左子树
            stack.push(curr);
            curr = curr.left;
        }
        curr = stack.pop(); // 访问根节点
        res.add(curr.val);
        curr = curr.right; // 处理右子树
    }
    return res;
}

// 后序遍历（栈：左→右→根，用两个栈或标记法）
public List<Integer> postOrderIter(TreeNode root) {
    List<Integer> res = new ArrayList<>();
    if (root == null) return res;
    Stack<TreeNode> stack = new Stack<>();
    TreeNode prev = null; // 标记已访问的节点
    while (root != null || !stack.isEmpty()) {
        while (root != null) { // 压入所有左子树
            stack.push(root);
            root = root.left;
        }
        root = stack.peek();
        // 右子树为空或已访问，访问根节点
        if (root.right == null || root.right == prev) {
            res.add(root.val);
            stack.pop();
            prev = root;
            root = null; // 避免重复压入左子树
        } else {
            root = root.right; // 处理右子树
        }
    }
    return res;
}
```



### 总结



这篇面试题覆盖了后端 “核心基础知识 + 生产实践”，回答时需注意：

1. 底层原理要 “点到为止”（如 AQS 不用深讲链表结构，锁升级讲清流程即可）；
2. 生产问题要结合实际场景（如热 Key、GC 选择）；
3. 基础算法要熟练掌握递归 + 迭代实现（面试常考手写）。