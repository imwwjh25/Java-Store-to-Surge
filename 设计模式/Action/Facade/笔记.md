### 一、为什么需要外观模式？

先看痛点场景：

- 你开发一个电商下单系统，下单流程涉及多个子系统：库存检查（Inventory）、支付处理（Payment）、物流创建（Logistics）、订单记录（Order）；
- 客户端（如前端）若直接调用这些子系统，需要了解每个子系统的接口、调用顺序、异常处理，代码复杂且耦合度高；
- 若子系统接口变更（如支付接口升级），所有客户端代码都需要修改。

外观模式的解决思路：创建一个`OrderFacade`外观类，封装所有下单子步骤，客户端只需调用`facade.createOrder()`即可完成下单，无需关注内部子系统。

### 二、外观模式的核心结构

外观模式包含 2 个核心角色（可选 1 个辅助角色）：

1. **外观类（Facade）**：核心角色，封装子系统的调用逻辑，提供统一的对外接口；
2. **子系统（Subsystem）**：多个独立的功能模块（如库存、支付、物流），实现具体业务逻辑；
3. **客户端（Client）**：仅调用外观类的接口，无需直接操作子系统（可选：可绕过外观类直接调用子系统）。

### 三、完整代码实现（电商下单场景）

#### 1. 子系统（Subsystem）










```
// 子系统1：库存检查
public class InventorySystem {
    // 检查商品库存是否充足
    public boolean checkStock(String productId, int quantity) {
        System.out.println("检查商品[" + productId + "]库存，数量：" + quantity);
        // 模拟库存充足
        return true;
    }

    // 扣减库存
    public void deductStock(String productId, int quantity) {
        System.out.println("扣减商品[" + productId + "]库存，数量：" + quantity);
    }
}

// 子系统2：支付处理
public class PaymentSystem {
    // 处理支付
    public boolean processPayment(String userId, double amount) {
        System.out.println("用户[" + userId + "]支付金额：" + amount + "元");
        // 模拟支付成功
        return true;
    }
}

// 子系统3：物流创建
public class LogisticsSystem {
    // 创建物流订单
    public String createLogistics(String orderId, String address) {
        String logisticsNo = "LOG" + System.currentTimeMillis();
        System.out.println("创建物流订单[" + logisticsNo + "]，收货地址：" + address);
        return logisticsNo;
    }
}

// 子系统4：订单记录
public class OrderSystem {
    // 创建订单
    public String createOrder(String userId, String productId, int quantity) {
        String orderId = "ORD" + System.currentTimeMillis();
        System.out.println("创建订单[" + orderId + "]，用户：" + userId + "，商品：" + productId);
        return orderId;
    }

    // 更新订单状态
    public void updateOrderStatus(String orderId, String status) {
        System.out.println("更新订单[" + orderId + "]状态为：" + status);
    }
}
```

#### 2. 外观类（Facade）







```
// 下单外观类：封装所有子系统调用逻辑
public class OrderFacade {
    // 持有所有子系统对象（可通过构造器注入，此处简化）
    private InventorySystem inventory = new InventorySystem();
    private PaymentSystem payment = new PaymentSystem();
    private LogisticsSystem logistics = new LogisticsSystem();
    private OrderSystem order = new OrderSystem();

    /**
     * 统一的下单接口：客户端只需调用此方法
     * @param userId 用户ID
     * @param productId 商品ID
     * @param quantity 购买数量
     * @param amount 支付金额
     * @param address 收货地址
     * @return 订单ID
     */
    public String createOrder(String userId, String productId, int quantity, double amount, String address) {
        try {
            // 1. 检查库存
            if (!inventory.checkStock(productId, quantity)) {
                throw new RuntimeException("库存不足");
            }

            // 2. 创建订单
            String orderId = order.createOrder(userId, productId, quantity);

            // 3. 处理支付
            if (!payment.processPayment(userId, amount)) {
                throw new RuntimeException("支付失败");
            }

            // 4. 扣减库存
            inventory.deductStock(productId, quantity);

            // 5. 创建物流
            logistics.createLogistics(orderId, address);

            // 6. 更新订单状态为已下单
            order.updateOrderStatus(orderId, "已下单");

            System.out.println("下单成功，订单ID：" + orderId);
            return orderId;
        } catch (Exception e) {
            System.out.println("下单失败：" + e.getMessage());
            return null;
        }
    }
}
```

#### 3. 客户端使用示例











```
public class FacadePatternDemo {
    public static void main(String[] args) {
        // 客户端只需创建外观类，调用统一接口
        OrderFacade orderFacade = new OrderFacade();

        // 下单：只需传入必要参数，无需关注内部子系统
        String orderId = orderFacade.createOrder(
                "U123456",  // 用户ID
                "P789",     // 商品ID
                2,          // 购买数量
                199.8,      // 支付金额
                "北京市朝阳区XX路XX号" // 收货地址
        );

        System.out.println("客户端获取到的订单ID：" + orderId);
    }
}
```

**输出结果**：








```
检查商品[P789]库存，数量：2
创建订单[ORD1739876543210]，用户：U123456，商品：P789
用户[U123456]支付金额：199.8元
扣减商品[P789]库存，数量：2
创建物流订单[LOG1739876543211]，收货地址：北京市朝阳区XX路XX号
更新订单[ORD1739876543210]状态为：已下单
下单成功，订单ID：ORD1739876543210
客户端获取到的订单ID：ORD1739876543210
```

### 四、外观模式的扩展：多外观类

如果子系统复杂，可根据不同业务场景创建多个外观类，比如：

- `OrderCreateFacade`：负责下单；
- `OrderQueryFacade`：负责查询订单；
- `OrderCancelFacade`：负责取消订单。

示例（订单查询外观类）：







```
public class OrderQueryFacade {
    private OrderSystem order = new OrderSystem();
    private LogisticsSystem logistics = new LogisticsSystem();

    // 统一查询订单详情（封装订单+物流查询）
    public void queryOrderDetail(String orderId) {
        System.out.println("===== 订单详情 =====");
        // 模拟查询订单基本信息
        System.out.println("订单[" + orderId + "]：状态=已下单，金额=199.8元");
        // 模拟查询物流信息
        System.out.println("物流信息：LOG1739876543211，状态=待揽收");
    }
}

// 客户端使用
public class MultiFacadeDemo {
    public static void main(String[] args) {
        OrderQueryFacade queryFacade = new OrderQueryFacade();
        queryFacade.queryOrderDetail("ORD1739876543210");
    }
}
```

### 五、外观模式的核心特点

#### 优点：

1. **简化调用**：客户端只需调用一个接口，无需了解子系统的复杂逻辑和调用顺序；
2. **降低耦合**：客户端与子系统解耦，子系统接口变更只需修改外观类，无需修改客户端；
3. **隔离变化**：子系统的内部实现变化（如支付接口升级），对客户端透明；
4. **按需访问**：客户端可绕过外观类，直接调用子系统（灵活度高）；
5. **符合迪米特法则**：客户端只需与外观类交互，减少与多个子系统的交互。

#### 缺点：

1. **外观类可能变臃肿**：若子系统过多，外观类会承担大量调用逻辑，违反 “单一职责原则”；
2. **扩展受限**：若需要定制化调用子系统（如部分下单流程跳过物流），外观类的统一接口可能无法满足；
3. **可能隐藏性能问题**：外观类封装的流程可能包含不必要的子系统调用，需谨慎设计。

### 六、外观模式 vs 中介者模式（易混淆的区别）

两者都有 “封装交互” 的特点，但核心目标不同：






|   维度   |               外观模式               |                   中介者模式                   |
| :------: | :----------------------------------: | :--------------------------------------------: |
| 核心目标 |     简化客户端对**子系统**的访问     |         协调多个**对等对象**之间的交互         |
| 交互方向 |   客户端 → 外观类 → 子系统（单向）   |           多个对象 ↔ 中介者（双向）            |
| 适用场景 |     子系统复杂，客户端需统一入口     |         多个对象耦合严重，交互逻辑复杂         |
|   示例   | 电商下单、JDBC 封装（DriverManager） | 聊天室（中介者协调用户消息发送）、GUI 组件交互 |

### 总结

1. **核心思想**：外观模式为复杂子系统提供统一的访问入口，核心是 “简化调用、隔离复杂度”；

2. 适用场景 ：

    - 子系统接口多、调用逻辑复杂，需要简化客户端调用；
    - 希望降低客户端与子系统的耦合，便于子系统升级 / 替换；
    - 开发第三方 SDK 时，提供简洁的对外 API（隐藏内部复杂逻辑）；



3. 实现关键 ：

    - 外观类持有子系统对象，封装调用逻辑（包括顺序、异常处理）；
    - 外观类提供 “粗粒度” 接口，客户端无需关注 “细粒度” 的子系统接口；
    - 可创建多个外观类适配不同业务场景，避免单个外观类臃肿；



4. 经典案例 ：

    - Java 的`JDBC`（`DriverManager`作为外观类，封装数据库连接的复杂步骤）；
    - Spring 的`JdbcTemplate`（封装 JDBC 的增删改查逻辑）；
    - 操作系统的 API（如 Windows 的 API 封装底层硬件交互）。