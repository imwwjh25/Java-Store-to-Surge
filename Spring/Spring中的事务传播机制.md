Spring 事务传播机制是**多个有事务的方法嵌套调用时，定义子事务如何与父事务交互**的规则（比如子事务是否复用父事务、是否独立提交 / 回滚等），核心解决 “嵌套事务的边界与协同” 问题。它通过`Propagation`枚举类定义，共 7 种传播行为，我们结合 “父方法 A（有事务）调用子方法 B” 的场景，逐一拆解：

### 一、先明确两个基础概念

在理解传播机制前，需先区分两个角色：

- **父事务**：外层方法 A 的事务（调用方）。

- 子事务 ：内层方法 B 的事务（被调用方）。



传播机制的核心是 “子事务如何处理与父事务的关系”，所有行为都围绕 “是否新建事务”“是否参与父事务”“回滚 / 提交是否影响彼此” 展开。

### 二、7 种传播行为的具体含义（按常用程度排序）

#### 1. REQUIRED（默认）：“有则复用，无则新建”

- **规则**：若父事务存在，子事务直接复用父事务（子方法 B 不新建事务，与 A 共用一个事务）；若父事务不存在（如 A 无事务），子事务新建一个独立事务。

- 提交 / 回滚影响 ：

    - 子方法 B 回滚：整个父事务（A+B）都会回滚（即使 B 后续 A 没有异常）。
    - 父方法 A 回滚：子事务（B）也会跟着回滚（共用一个事务上下文）。

- **典型场景**：最常用，适合 “子操作必须与父操作在同一事务” 的场景（如 “创建订单（A）” 调用 “扣减库存（B）”，两者必须同时成功或同时失败）。

- 示例 ：










  ```java
  @Transactional(propagation = Propagation.REQUIRED) // 父方法A
  public void createOrder() {
      // 1. 保存订单（父事务逻辑）
      orderDao.save(order);
      // 2. 调用子方法B（扣库存），复用A的事务
      stockService.deductStock(); // B的传播行为也是REQUIRED
  }
  ```



#### 2. SUPPORTS：“有则复用，无则无事务”

- **规则**：若父事务存在，子事务复用父事务；若父事务不存在，子方法 B 不使用任何事务（以 “无事务” 方式执行）。

- 提交 / 回滚影响 ：

    - 子方法 B 在父事务中时，回滚会导致父事务整体回滚；
    - 子方法 B 无事务时，自身操作无事务保护（如数据库默认 “自动提交”，B 执行后立即生效，无法回滚）。

- **典型场景**：适合 “子操作可选事务” 的场景（如 “查询订单详情（A 有事务）” 调用 “记录操作日志（B）”，日志记录可复用事务，也可无事务）。

#### 3. MANDATORY：“有则复用，无则报错”

- **规则**：强制要求父事务必须存在，子事务复用父事务；若父事务不存在（A 无事务），直接抛出`IllegalTransactionStateException`异常（“没有事务可用，无法执行”）。
- **核心目的**：确保子方法 B “必须在事务中执行”，不允许无事务运行（防止子操作脱离事务保护）。
- **典型场景**：适合 “子操作必须依赖父事务” 的场景（如 “确认支付（B）” 必须依赖 “创建支付单（A）” 的事务，若 A 无事务，B 不允许执行）。

#### 4. REQUIRES_NEW：“无论有无，都新建独立事务”

- **规则**：无论父事务是否存在，子方法 B 都会新建一个**完全独立**的事务（与父事务隔离，有自己的事务上下文）。

- 提交 / 回滚影响 ：

    - 子事务 B 的提交 / 回滚与父事务 A 完全独立：B 提交后，即使 A 后续回滚，B 的操作也不会回滚；B 回滚，也不会导致 A 回滚（除非 B 抛出异常被 A 捕获后，A 主动回滚）。
    - 父事务在调用 B 时，会先 “暂停”（父事务的操作暂时不提交），直到 B 的独立事务完成，再继续执行父事务。

- **典型场景**：适合 “子操作必须独立提交，不受父事务影响” 的场景（如 “订单支付失败（A 回滚）” 调用 “记录失败日志（B）”，日志必须保存，不能因 A 回滚而丢失）。

- 示例 ：







  ```java
  @Transactional(propagation = Propagation.REQUIRED) // 父方法A
  public void payOrder() {
      try {
          // 1. 支付逻辑（父事务），假设执行失败
          paymentDao.pay(orderId);
      } catch (Exception e) {
          // 2. 调用子方法B（记录日志），新建独立事务
          logService.recordFailLog(); // B的传播行为是REQUIRES_NEW
          throw e; // A回滚，但B的日志已提交
      }
  }
  ```



#### 5. NOT_SUPPORTED：“无论有无，都无事务”

- **规则**：无论父事务是否存在，子方法 B 都**不使用任何事务**（强制以 “无事务” 方式执行）；若父事务存在，调用 B 前会先暂停父事务，待 B 执行完后再恢复父事务。

- 提交 / 回滚影响 ：

    - 子方法 B 的操作无事务保护（执行后立即生效，无法回滚）。
    - 父事务恢复后，其提交 / 回滚与 B 无关（B 的操作已独立生效）。

- **典型场景**：适合 “子操作不需要事务，且不希望影响父事务” 的场景（如 “更新用户信息（A 有事务）” 调用 “同步数据到 Elasticsearch（B）”，ES 同步无需事务，且即使同步失败，也不影响用户信息的更新）。

#### 6. NEVER：“有则报错，无则无事务”

- **规则**：强制要求父事务**不存在**，子方法 B 以 “无事务” 方式执行；若父事务存在（A 有事务），直接抛出`IllegalTransactionStateException`异常（“不允许在事务中执行”）。
- **核心目的**：确保子方法 B “绝对不参与任何事务”，防止被父事务意外影响。
- **典型场景**：适合 “子操作必须无事务” 的场景（如 “读取静态配置（B）”，配置读取无需事务，且不允许因父事务回滚而重复读取）。

#### 7. NESTED：“有则嵌套，无则新建”

- **规则**：若父事务存在，子事务以 “嵌套事务” 方式依赖父事务（子事务是父事务的 “子节点”，有自己的保存点）；若父事务不存在，子事务新建独立事务。

- 关键区别于 REQUIRES_NEW ：

    - NESTED 的子事务是 “父事务的一部分”，父事务回滚时，子事务会跟着回滚；但子事务回滚时，只会回滚到自己的 “保存点”，不会影响父事务的其他逻辑（父事务可继续执行）。
    - REQUIRES_NEW 的子事务是 “完全独立”，父回滚不影响子，子回滚不影响父。

- 提交 / 回滚影响 ：

    - 子方法 B 回滚：仅回滚 B 的操作，父事务（A）可继续执行后续逻辑（如 A 捕获 B 的异常，跳过 B，继续保存其他数据）。
    - 父方法 A 回滚：子事务（B）会跟着回滚（因嵌套在父事务中）。

- **典型场景**：适合 “子操作失败不影响父操作整体，但父操作失败需连带子操作回滚” 的场景（如 “批量导入数据（A）” 调用 “导入单条数据（B）”，某一条 B 失败时，仅回滚该条，其他数据继续导入；若 A 整体失败，所有 B 的导入都会回滚）。

### 三、关键对比：易混淆的 3 种传播行为

实际使用中，`REQUIRED`、`REQUIRES_NEW`、`NESTED`最易混淆，我们用一张表明确差异：

| 传播行为     | 是否复用父事务 | 子回滚对父的影响   | 父回滚对子的影响 | 核心特点               |
| ------------ | -------------- | ------------------ | ---------------- | ---------------------- |
| REQUIRED     | 是             | 父随子回滚         | 子随父回滚       | 共用一个事务，命运绑定 |
| REQUIRES_NEW | 否（新建）     | 父不回滚           | 子不回滚         | 完全独立，互不影响     |
| NESTED       | 是（嵌套）     | 父不回滚（仅子回） | 子随父回滚       | 子依赖父，父不依赖子   |

### 四、使用注意事项

1. **传播机制仅对 “Spring 管理的事务” 有效**：若子方法 B 未加`@Transactional`，则无论父事务如何，B 都以 “无事务” 方式执行（传播机制不生效）。
2. **异常传播会影响事务回滚**：即使子方法 B 的传播行为是`REQUIRES_NEW`，若 B 抛出未捕获的异常，父事务 A 仍会感知并可能回滚（需 A 主动捕获 B 的异常，才能实现 “子回滚不影响父”）。
3. **数据库支持是前提**：`NESTED`依赖数据库的 “保存点（Savepoint）” 功能（如 MySQL、PostgreSQL 支持），若数据库不支持保存点，`NESTED`会降级为`REQUIRED`。