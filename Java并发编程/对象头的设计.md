针对 **32 位 HotSpot JVM**（虽然现在主流是 64 位，但嵌入式 / 老旧环境仍会用到），我会精准拆解 `Mark Word` 32 位下锁升级的**每一位布局**，核心逻辑和 64 位一致，但字段位数按比例缩减，重点标注「32 位专属的位范围 + 字段对应关系」，确保你能直接对应到具体位置。

### 一、32 位 Mark Word 核心前提

1. 总长度：32 位（4 字节），比 64 位少一半，字段位数大幅压缩；
2. 锁状态标记规则（和 64 位一致，核心不变）：
    - 偏向锁标识位（biased_lock）：1 位；
    - 锁标记位（lock_flag）：2 位；
    - 组合规则：
        - 无锁：biased_lock=0 + lock_flag=01；
        - 偏向锁：biased_lock=1 + lock_flag=01；
        - 轻量级锁：lock_flag=00；
        - 重量级锁：lock_flag=10；
        - GC 标记：lock_flag=11（忽略）。

### 二、32 位 Mark Word 逐状态位布局（精准到每一位）

以下按「比特位从高位到低位（31→0）」划分，这是 HotSpot 源码中 32 位 Mark Word 的**标准布局**（参考`markOop.hpp`）：

#### 1. 状态 1：无锁（unlocked）

| 比特位范围（31→0） | 字段名      | 位数 | 含义说明                           |
| ------------------ | ----------- | ---- | ---------------------------------- |
| 31 ~ 25            | hashcode    | 7    | 对象哈希值（高 7 位）              |
| 24 ~ 18            | hashcode    | 7    | 对象哈希值（中 7 位）              |
| 17 ~ 13            | hashcode    | 5    | 对象哈希值（低 5 位）              |
| 12 ~ 8             | age         | 5    | 对象分代年龄（0~31，和 64 位一致） |
| 7                  | biased_lock | 1    | 偏向锁标识位（0 = 未开启）         |
| 6 ~ 5              | unused      | 2    | 未使用（固定为 0）                 |
| 4 ~ 1              | unused      | 4    | 未使用（固定为 0）                 |
| 0                  | lock_flag   | 1    | 锁标记位（无锁 = 1，组合后 01）    |

✅ 简化易记版（32 位无锁）：

plaintext











```plaintext
[ 哈希值(19位) | 分代年龄(5位) | 偏向锁标识(1位=0) | 锁标记位(2位=01) ]
```

（19 位哈希 = 7+7+5，是 32 位下能存储的最大哈希长度，避免溢出）

#### 2. 状态 2：偏向锁（biased locked）

偏向锁会覆盖无锁时的哈希值字段，存储线程 ID（32 位下线程 ID 长度压缩）：

| 比特位范围（31→0） | 字段名      | 位数 | 含义说明                        |
| ------------------ | ----------- | ---- | ------------------------------- |
| 31 ~ 16            | threadID    | 16   | 持有偏向锁的线程 ID（低 16 位） |
| 15 ~ 13            | epoch       | 3    | 偏向锁时间戳（批量重偏向用）    |
| 12 ~ 8             | age         | 5    | 对象分代年龄（不变）            |
| 7                  | biased_lock | 1    | 偏向锁标识位（1 = 开启）        |
| 6 ~ 5              | unused      | 2    | 未使用                          |
| 4 ~ 1              | unused      | 4    | 未使用                          |
| 0                  | lock_flag   | 1    | 锁标记位（01）                  |

✅ 简化易记版（32 位偏向锁）：

plaintext











```plaintext
[ 线程ID(16位) | epoch(3位) | 分代年龄(5位) | 偏向锁标识(1位=1) | 锁标记位(2位=01) ]
```

👉 关键：32 位系统中线程 ID 通常是 32 位，但 Mark Word 仅能存低 16 位 —— 因为高 16 位在进程内是固定的，低 16 位已足够区分线程。

#### 3. 状态 3：轻量级锁（lightweight locked）

轻量级锁下，Mark Word 几乎全存「锁记录指针」（32 位指针），仅保留锁标记位：

| 比特位范围（31→0） | 字段名             | 位数 | 含义说明                        |
| ------------------ | ------------------ | ---- | ------------------------------- |
| 31 ~ 2             | ptr_to_lock_record | 30   | 指向线程栈中 Lock Record 的指针 |
| 1 ~ 0              | lock_flag          | 2    | 锁标记位（00）                  |

✅ 简化易记版（32 位轻量级锁）：

plaintext











```plaintext
[ 锁记录指针(30位) | 锁标记位(2位=00) ]
```

👉 补充：32 位系统的指针本身是 32 位，但 Mark Word 用低 2 位存标记位，因此指针只占高 30 位（指针地址是 4 字节对齐的，低 2 位恒为 0，不影响指针有效性）。

#### 4. 状态 4：重量级锁（heavyweight locked）

重量级锁存储「监视器（Monitor）指针」，布局和轻量级锁类似：

| 比特位范围（31→0） | 字段名                     | 位数 | 含义说明            |
| ------------------ | -------------------------- | ---- | ------------------- |
| 31 ~ 2             | ptr_to_heavyweight_monitor | 30   | 指向 Monitor 的指针 |
| 1 ~ 0              | lock_flag                  | 2    | 锁标记位（10）      |

✅ 简化易记版（32 位重量级锁）：

plaintext











```plaintext
[ 监视器指针(30位) | 锁标记位(2位=10) ]
```

### 三、32 位 Mark Word 核心总结表（锁状态 + 关键位）

| 锁状态   | biased_lock（位 7） | lock_flag（位 1-0） | 核心存储内容                              | 总位数匹配（32 位）                                      |
| -------- | ------------------- | ------------------- | ----------------------------------------- | -------------------------------------------------------- |
| 无锁     | 0                   | 01                  | 哈希值 (19 位)+ 年龄 (5 位)               | 19+5+1+2=27？补：19+5+1（偏向）+2（标记）+5（unused）=32 |
| 偏向锁   | 1                   | 01                  | 线程 ID (16 位)+epoch (3 位)+ 年龄 (5 位) | 16+3+5+1+2+5=32                                          |
| 轻量级锁 | -（失效）           | 00                  | 锁记录指针 (30 位)                        | 30+2=32                                                  |
| 重量级锁 | -（失效）           | 10                  | 监视器指针 (30 位)                        | 30+2=32                                                  |
| GC 标记  | -                   | 11                  | 无（仅标记回收）                          | 32 位全为标记态                                          |

### 四、32 位 vs 64 位 Mark Word 核心差异

| 维度         | 32 位 JVM          | 64 位 JVM          |
| ------------ | ------------------ | ------------------ |
| 总长度       | 32 位（4 字节）    | 64 位（8 字节）    |
| 哈希值存储   | 19 位（压缩）      | 55 位（完整）      |
| 线程 ID 存储 | 16 位（低 16 位）  | 33 位（低 33 位）  |
| 指针长度     | 30 位（高 30 位）  | 62 位（高 62 位）  |
| 核心逻辑     | 锁升级规则完全一致 | 锁升级规则完全一致 |

### 五、关键补充（32 位专属注意点）

1. 哈希值压缩：32 位 Mark Word 仅能存 19 位哈希值，因此对象调用`hashCode()`后，哈希值会被截断存储（但不影响唯一性，因为 19 位已能覆盖大部分场景）；
2. 指针对齐：32 位系统的内存地址是 4 字节（32 位）对齐的，因此指针的低 2 位恒为 0，这也是为什么能把低 2 位拿出来存锁标记位 —— 不会破坏指针的有效性；
3. 偏向锁限制：32 位 JVM 的偏向锁同样默认开启（JDK6+），但因线程 ID 仅存 16 位，若进程内线程数超过 2^16（65536），偏向锁会自动失效，直接升级为轻量级锁；
4. 实战场景：32 位 JVM 仅用于内存≤4GB 的环境（如老旧服务器、嵌入式设备），现代服务器 / PC 均为 64 位，理解 32 位布局主要是应对面试 / 老旧系统维护。

### 可视化对比（32 位 vs 64 位 偏向锁）

plaintext











```plaintext
// 32位偏向锁
32-bit: [ 线程ID(16) | epoch(3) | 年龄(5) | biased_lock(1=1) | lock_flag(2=01) ]

// 64位偏向锁
64-bit: [ 线程ID(33) | epoch(3) | 年龄(5) | biased_lock(1=1) | lock_flag(2=01) | 未使用(10) ]
```

如果需要验证 32 位 Mark Word 的源码（比如`markOop.hpp`中 32 位的定义），或者想了解「32 位下偏向锁撤销的具体流程」，可以随时说！
