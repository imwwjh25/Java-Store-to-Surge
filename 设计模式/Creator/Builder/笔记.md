### 一、为什么需要建造者模式？

先看一个痛点场景：创建一个`Computer`对象，它有 CPU、内存、硬盘、显卡、系统等多个属性，部分可选。如果用传统方式：

- 多参数构造器：`new Computer("i9", 32, 1000, "RTX4090", "Windows11")`，参数顺序易混、可选参数处理麻烦；
- set 方法：创建后逐个 set，对象可能处于 “半初始化” 状态，线程不安全。

建造者模式能完美解决这些问题，让对象创建过程清晰、可控、安全。

### 二、建造者模式的核心结构

建造者模式包含 4 个核心角色（以创建电脑为例）：

1. **产品（Product）**：需要构建的复杂对象（如`Computer`）；
2. **抽象建造者（Creator.Builder）**：定义构建产品的抽象步骤（如设置 CPU、内存等）；
3. **具体建造者（Concrete Creator.Builder）**：实现抽象建造者的步骤，完成具体产品的构建；
4. **指挥者（Director）**：可选角色，统一控制构建流程（如 “游戏本”“办公本” 的固定配置）。

### 三、完整代码实现（两种常见写法）

#### 写法 1：标准建造者（带 Director，适合复杂构建流程）










```
// 1. 产品类：复杂对象（Computer）
class Computer {
    // 必选属性
    private String cpu;
    private int memory;
    // 可选属性
    private int hardDisk;
    private String graphicsCard;
    private String os;

    // 私有构造：只能通过Builder创建
    private Computer(ComputerBuilder builder) {
        this.cpu = builder.cpu;
        this.memory = builder.memory;
        this.hardDisk = builder.hardDisk;
        this.graphicsCard = builder.graphicsCard;
        this.os = builder.os;
    }

    // 2. 内部建造者类（具体建造者）
    public static class ComputerBuilder {
        // 必选属性（构造器强制传入）
        private String cpu;
        private int memory;
        // 可选属性（默认值）
        private int hardDisk = 512;
        private String graphicsCard = "集成显卡";
        private String os = "Windows10";

        // 必选属性构造器
        public ComputerBuilder(String cpu, int memory) {
            this.cpu = cpu;
            this.memory = memory;
        }

        // 分步设置可选属性（返回this，支持链式调用）
        public ComputerBuilder hardDisk(int hardDisk) {
            this.hardDisk = hardDisk;
            return this;
        }

        public ComputerBuilder graphicsCard(String graphicsCard) {
            this.graphicsCard = graphicsCard;
            return this;
        }

        public ComputerBuilder os(String os) {
            this.os = os;
            return this;
        }

        // 构建产品
        public Computer build() {
            // 可选：校验参数合法性
            if (memory < 8) {
                throw new IllegalArgumentException("内存不能小于8G");
            }
            return new Computer(this);
        }
    }

    // 重写toString，方便查看结果
    @Override
    public String toString() {
        return "Computer{" +
                "cpu='" + cpu + '\'' +
                ", memory=" + memory + "G" +
                ", hardDisk=" + hardDisk + "G" +
                ", graphicsCard='" + graphicsCard + '\'' +
                ", os='" + os + '\'' +
                '}';
    }
}

// 3. 指挥者（可选）：封装固定构建流程
class ComputerDirector {
    // 构建游戏本（固定高配）
    public Computer buildGameComputer() {
        return new Computer.ComputerBuilder("i9-14900K", 64)
                .hardDisk(2000)
                .graphicsCard("RTX4090")
                .os("Windows11")
                .build();
    }

    // 构建办公本（固定低配）
    public Computer buildOfficeComputer() {
        return new Computer.ComputerBuilder("i5-13400", 16)
                .hardDisk(1000)
                .graphicsCard("集成显卡")
                .os("Windows10")
                .build();
    }
}

// 4. 使用示例
public class BuilderPatternDemo {
    public static void main(String[] args) {
        // 方式1：手动构建（自定义配置）
        Computer customComputer = new Computer.ComputerBuilder("i7-13700", 32)
                .hardDisk(1000)
                .graphicsCard("RTX4070")
                .build();
        System.out.println("自定义电脑：" + customComputer);

        // 方式2：通过指挥者构建（固定配置）
        ComputerDirector director = new ComputerDirector();
        Computer gameComputer = director.buildGameComputer();
        System.out.println("游戏本：" + gameComputer);

        Computer officeComputer = director.buildOfficeComputer();
        System.out.println("办公本：" + officeComputer);
    }
}
```

#### 写法 2：简化建造者（无 Director，日常开发最常用）

日常开发中，指挥者（Director）常被省略，直接通过链式调用构建对象，更简洁：







```
// 简化版：无Director，直接链式构建
class User {
    private String username; // 必选
    private String password; // 必选
    private String email;    // 可选
    private int age;         // 可选

    private User(UserBuilder builder) {
        this.username = builder.username;
        this.password = builder.password;
        this.email = builder.email;
        this.age = builder.age;
    }

    public static class UserBuilder {
        private String username;
        private String password;
        private String email = "default@xxx.com";
        private int age = 18;

        public UserBuilder(String username, String password) {
            this.username = username;
            this.password = password;
        }

        public UserBuilder email(String email) {
            this.email = email;
            return this;
        }

        public UserBuilder age(int age) {
            this.age = age;
            return this;
        }

        public User build() {
            return new User(this);
        }
    }

    @Override
    public String toString() {
        return "User{" +
                "username='" + username + '\'' +
                ", email='" + email + '\'' +
                ", age=" + age +
                '}';
    }
}

// 使用示例
public class SimpleBuilderDemo {
    public static void main(String[] args) {
        User user = new User.UserBuilder("zhangsan", "123456")
                .email("zhangsan@xxx.com")
                .age(25)
                .build();
        System.out.println(user);
        // 输出：User{username='zhangsan', email='zhangsan@xxx.com', age=25}
    }
}
```

### 四、建造者模式的核心特点

#### 优点：

1. **可读性高**：链式调用（`builder.xxx().xxx().build()`）清晰展示对象配置，比多参数构造器易读；
2. **可控性强**：分步构建，可在`build()`方法中校验参数合法性，避免创建无效对象；
3. **线程安全**：对象创建完成前不可变（构造器私有，属性无 set 方法），多线程下安全；
4. **灵活性高**：同样的构建步骤可创建不同配置的对象，适配不同场景。

#### 缺点：

1. 代码冗余：需要编写额外的 Creator.Builder 类，简单对象使用会增加代码量；
2. 适用范围有限：仅适合**属性多、部分可选、构建逻辑复杂**的对象，简单对象（如只有 2 个属性）无需使用。

### 五、建造者模式 vs 工厂模式（核心区别）

很多新手会混淆两者，核心差异在于：








|    维度    |               建造者模式                | 工厂模式（简单 / 工厂方法 / 抽象工厂） |
| :--------: | :-------------------------------------: | :------------------------------------: |
|  核心目标  | 分步构建**复杂对象**（关注 “如何构建”） | 快速创建**产品实例**（关注 “创建谁”）  |
|  构建过程  |        分步、可控（多步骤配置）         |          一步到位（直接创建）          |
| 产品多样性 | 同一产品的不同配置（如高配 / 低配电脑） |  不同类型的产品（如奔驰 / 宝马汽车）   |
|  适用场景  |         对象属性多、可选参数多          |       产品类型固定，创建逻辑统一       |

### 总结

1. **核心思想**：建造者模式通过 “分步构建 + 链式调用” 解决复杂对象的创建问题，分离构建过程与产品表示；
2. **适用场景**：对象属性多（≥3 个）、部分可选、需要校验参数，或需要创建不同配置的同类型对象（如不同配置的电脑、用户）；
3. **使用技巧**：日常开发中优先使用 “简化版建造者（无 Director）”，仅在构建流程固定且复杂时（如不同类型的产品模板）引入 Director；
4. **关键区别**：和工厂模式相比，建造者关注 “怎么造”（分步配置），工厂模式关注 “造什么”（直接创建）。