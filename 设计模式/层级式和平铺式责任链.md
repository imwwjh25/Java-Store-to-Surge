你提到的 “平等处理者” 是责任链模式中一个非常关键的细分场景（也叫 “平铺式责任链”），核心是**链中的所有处理者地位平等，请求会被所有匹配的处理者处理（而非仅第一个匹配的）** —— 这和之前讲的 “层级式责任链（审批流程）” 是完全不同的逻辑，也是很多人使用责任链时容易混淆的点。

简单说：

- 层级式责任链：**请求被第一个匹配的处理者处理后终止**（如退款审批，谁有权谁批，批完就结束）；
- 平等式责任链：**请求会遍历所有处理者，符合条件的都处理，不终止**（如请求过滤器，日志、校验、限流都要执行）。

### 一、平等处理者的核心特点（对比层级式）




|   维度   |           层级式责任链（不平等）           |               平等式责任链（平铺式）               |
| :------: | :----------------------------------------: | :------------------------------------------------: |
| 处理逻辑 | 处理者判断→能处理则处理 + 终止，不能则传递 | 处理者判断→能处理则处理 + 继续传递，不能则直接传递 |
| 处理结果 |            仅一个处理者处理请求            |              多个处理者可处理同一请求              |
| 核心目标 |             找 “唯一” 的处理者             |            让 “所有匹配” 的处理者都执行            |
| 典型场景 |             审批流程、权限分配             |               过滤器、拦截器、中间件               |

### 二、平等处理者的代码实现（请求过滤器场景）

以 “接口请求过滤器链” 为例（日志记录→参数校验→限流控制，三个平等处理者都要执行）：

#### 1. 抽象处理者（调整传递逻辑）










```
// 抽象过滤器（平等处理者的核心：处理后必须传递，不终止）
public abstract class RequestFilter {
    protected RequestFilter nextFilter;

    public void setNextFilter(RequestFilter nextFilter) {
        this.nextFilter = nextFilter;
    }

    /**
     * 处理请求（核心：无论当前处理者是否处理，都要传递给下一个）
     * @param request 请求对象
     */
    public void handleRequest(Request request) {
        // 1. 当前处理者的核心逻辑（符合条件则处理）
        doFilter(request);
        // 2. 必须传递给下一个（平等处理者的关键：不终止）
        if (nextFilter != null) {
            nextFilter.handleRequest(request);
        }
    }

    // 抽象方法：具体过滤逻辑
    protected abstract void doFilter(Request request);
}
```

#### 2. 具体平等处理者







```
// 处理者1：日志记录过滤器（所有请求都处理）
public class LogFilter extends RequestFilter {
    @Override
    protected void doFilter(Request request) {
        System.out.println("【日志过滤器】记录请求：" + request.getUri() + "，时间：" + System.currentTimeMillis());
    }
}

// 处理者2：参数校验过滤器（仅POST请求处理）
public class ParamFilter extends RequestFilter {
    @Override
    protected void doFilter(Request request) {
        if ("POST".equals(request.getMethod())) {
            System.out.println("【参数过滤器】校验POST请求参数：" + request.getParams());
            if (request.getParams() == null || request.getParams().isEmpty()) {
                throw new RuntimeException("POST请求参数不能为空");
            }
        }
    }
}

// 处理者3：限流过滤器（所有请求都处理）
public class RateLimitFilter extends RequestFilter {
    private int maxCount = 100; // 最大请求数
    private int currentCount = 0; // 当前请求数

    @Override
    protected void doFilter(Request request) {
        currentCount++;
        if (currentCount > maxCount) {
            throw new RuntimeException("【限流过滤器】请求超过阈值，拒绝访问");
        }
        System.out.println("【限流过滤器】当前请求数：" + currentCount + "，阈值：" + maxCount);
    }
}

// 请求对象
public class Request {
    private String uri;
    private String method;
    private Map<String, String> params;

    // 构造器、getter/setter
    public Request(String uri, String method, Map<String, String> params) {
        this.uri = uri;
        this.method = method;
        this.params = params;
    }

    public String getUri() { return uri; }
    public String getMethod() { return method; }
    public Map<String, String> getParams() { return params; }
}
```

#### 3. 客户端使用（构建平等链）





```
public class FilterChainDemo {
    public static void main(String[] args) {
        // 1. 创建平等处理者
        RequestFilter logFilter = new LogFilter();
        RequestFilter paramFilter = new ParamFilter();
        RequestFilter rateLimitFilter = new RateLimitFilter();

        // 2. 构建链：日志→参数→限流（所有都要执行）
        logFilter.setNextFilter(paramFilter);
        paramFilter.setNextFilter(rateLimitFilter);

        // 3. 发起POST请求（三个过滤器都会执行）
        Map<String, String> params = new HashMap<>();
        params.put("userId", "123");
        Request request = new Request("/api/pay", "POST", params);
        logFilter.handleRequest(request);

        /* 输出结果（所有处理者都执行）：
        【日志过滤器】记录请求：/api/pay，时间：1740456789000
        【参数过滤器】校验POST请求参数：{userId=123}
        【限流过滤器】当前请求数：1，阈值：100
        */
    }
}
```

### 三、平等处理者的核心问题（你关注的重点）

平等处理者虽然灵活，但实际使用中容易踩坑，核心问题集中在 3 点：

#### 1. 「强制全链路执行」导致的性能问题

- **问题表现**：即使请求已经不符合后续处理者的条件（如参数校验失败），仍会继续传递给下一个处理者，做无意义的执行；

- **示例**：参数校验过滤器抛出 “参数为空” 异常后，限流过滤器仍会执行（统计请求数），但此时请求已无意义；

- 避坑方法 ：

    - 给请求添加 “终止标记”：处理者可设置`request.setTerminated(true)`，后续处理者先判断标记，若终止则直接跳过；
    - 异常中断：核心处理者（如参数校验）抛出异常后，客户端捕获异常并终止链的执行。



#### 2. 「处理顺序」敏感问题

- **问题表现**：平等处理者看似 “平等”，但执行顺序直接影响结果，顺序错误会导致逻辑异常；

- **示例**：若把 “限流过滤器” 放在 “日志过滤器” 前，限流计数后日志未记录，导致限流数据和日志数据不一致；

- 避坑方法 ：

    - 文档明确标注处理者的执行顺序（如 “日志→参数→限流”）；
    - 用工厂模式封装链的构建，避免客户端随意调整顺序；
    - 对顺序敏感的处理者，在类上添加`@Order`注解（如 Spring 的`@Order`），按注解排序构建链。



#### 3. 「重复处理」问题

- **问题表现**：多个平等处理者的职责边界模糊，导致同一逻辑被重复处理（如两个过滤器都校验同一参数）；

- **示例**：参数过滤器和业务过滤器都校验 “userId” 是否为空，导致重复校验、代码冗余；

- 避坑方法 ：

    - 明确每个处理者的 “单一职责”（如日志只记录、参数只校验、限流只计数）；
    - 核心逻辑抽离：将重复的校验逻辑封装为工具类，处理者调用工具类而非重复编写。



### 四、平等处理者 vs 层级处理者（核心区别总结）








| 问题 / 特点  |            层级处理者            |               平等处理者               |
| :----------: | :------------------------------: | :------------------------------------: |
| 执行终止条件 |   第一个匹配的处理者处理后终止   | 遍历完所有处理者才终止（除非手动中断） |
|  处理者数量  |      通常较少（3~5 个层级）      |         可较多（如多个过滤器）         |
|  顺序重要性  |        重要（层级不能乱）        |   极重要（顺序错误直接导致逻辑异常）   |
|   性能影响   | 链越长，找到匹配处理者的耗时越长 |       链越长，全链路执行耗时越长       |
|   核心风险   |       请求落空（无人处理）       |  无意义执行（参数校验失败仍执行后续）  |

### 总结

1. 平等处理者是责任链的 “不纯实现”，核心是**请求遍历所有处理者，符合条件的都处理，不终止**，典型场景是过滤器、拦截器；

2. 平等处理者的核心问题是：**全链路执行导致的性能损耗、顺序敏感、重复处理**；

3. 避坑关键：

    - 给请求加 “终止标记”，避免无意义执行；
    - 封装链的构建逻辑，固定执行顺序；
    - 严格遵守 “单一职责”，避免重复处理；



4. 选型建议：

    - 需 “找唯一处理者” 用层级式（如审批）；
    - 需 “所有匹配者都处理” 用平等式（如过滤器）；
    - 平等式链的长度建议控制在 5 个以内，避免性能问题。