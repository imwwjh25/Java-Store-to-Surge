Spring 中的循环依赖指的是两个或多个 Bean 之间相互引用（如 A 依赖 B，B 依赖 A），形成闭环。Spring 提供了一套机制解决大部分循环依赖问题，但也存在无法解决的场景。下面详细说明：

### 一、Spring 如何解决循环依赖？

Spring 解决循环依赖的核心是**三级缓存**和**提前暴露半成品 Bean**，仅适用于**单例 Bean** 和**setter 注入**的场景。具体流程如下：

#### 1. 三级缓存的作用

Spring 通过三个缓存（Map）存储 Bean 的不同状态，实现循环依赖的处理：

- **一级缓存（singletonObjects）**：存储完全初始化完成的单例 Bean（可直接使用）。
- **二级缓存（earlySingletonObjects）**：存储提前暴露的 “半成品” Bean（已实例化，但未完成属性注入和初始化）。
- **三级缓存（singletonFactories）**：存储 Bean 的工厂对象（`ObjectFactory`），用于在需要时生成半成品 Bean 的代理对象（若有 AOP 增强）。

#### 2. 解决循环依赖的步骤（以 A 依赖 B，B 依赖 A 为例）

1. **实例化 A**：
    - Spring 首先创建 A 的实例（调用构造方法），但不注入属性，也不执行初始化方法（此时 A 是半成品）。
    - 将 A 的工厂对象（`ObjectFactory`）放入三级缓存（`singletonFactories`），用于后续生成 A 的半成品或代理对象。
2. **A 注入 B 时发现依赖**：
    - A 需要注入 B，但 B 尚未创建，Spring 开始实例化 B。
3. **实例化 B**：
    - 同理，创建 B 的实例（半成品），将 B 的工厂对象放入三级缓存。
4. **B 注入 A 时获取半成品 A**：
    - B 需要注入 A，Spring 从一级缓存查找 A（未找到），再从二级缓存查找（未找到），最后从三级缓存获取 A 的工厂对象。
    - 通过工厂对象生成 A 的半成品（若 A 需要 AOP 代理，则此时生成代理对象），将 A 从三级缓存移至二级缓存（`earlySingletonObjects`）。
    - B 成功注入 A 的半成品，完成自身的属性注入和初始化，成为完全初始化的 Bean，放入一级缓存（`singletonObjects`）。
5. **A 完成初始化**：
    - B 已存在于一级缓存，A 成功注入 B，完成自身的属性注入和初始化，成为完全初始化的 Bean，放入一级缓存，并从二级缓存移除。

#### 核心逻辑：

通过三级缓存提前暴露 Bean 的半成品，允许依赖方先引用未完全初始化的对象，待被依赖方完全初始化后，再完成自身的初始化。这一过程依赖于**Bean 的实例化（构造方法）和初始化（属性注入、init 方法）分离**的设计。

### 二、Spring 无法解决的循环依赖场景

并非所有循环依赖都能被 Spring 解决，以下场景会导致循环依赖失败：

#### 1. 构造器注入的循环依赖

若循环依赖中的 Bean 通过**构造器注入**相互依赖（如 A 的构造器需要 B，B 的构造器需要 A），Spring 无法解决，会抛出 `BeanCurrentlyInCreationException`。

**原因**：构造器注入要求在实例化阶段就传入依赖对象（即 “先有依赖，才能实例化自身”）。而 Spring 解决循环依赖的前提是 “先实例化，再注入依赖”，但构造器注入颠倒了这个顺序 ——A 实例化需要 B，B 实例化需要 A，形成 “鸡生蛋、蛋生鸡” 的死锁，三级缓存无法介入（因为实例化尚未完成，无法生成半成品）。

#### 2. 非单例 Bean 的循环依赖

若循环依赖的 Bean 是**原型（prototype）作用域**（每次请求创建新实例），Spring 无法解决，会抛出异常。

**原因**：原型 Bean 不存入三级缓存，每次注入都会创建新实例。例如 A（原型）依赖 B（原型），B 又依赖 A（原型），会导致无限创建 A 和 B 的新实例，最终触发循环依赖异常。Spring 对原型 Bean 的循环依赖直接禁止，因为无法通过缓存复用实例。

#### 3. 没有提前暴露半成品的场景

若 Bean 的初始化过程中手动破坏了提前暴露机制（如通过 `@PostConstruct` 等初始化方法引入循环依赖），可能导致解决失败。

**原因**：`@PostConstruct` 方法在属性注入后执行，若此时在方法中引入新的循环依赖（如 A 的 `@PostConstruct` 调用 B，B 又依赖 A），此时 A 虽已实例化，但尚未完全初始化，且三级缓存可能已被清理，导致依赖无法注入。

### 三、总结

- **能解决的场景**：单例 Bean + setter 注入（或字段注入）的循环依赖，核心依赖三级缓存和提前暴露半成品 Bean。

- 不能解决的场景 ：

    1. 构造器注入的循环依赖（实例化阶段依赖，无法提前暴露）；
    2. 原型（prototype）Bean 的循环依赖（无缓存复用，无限创建实例）；
    3. 初始化阶段（如 `@PostConstruct`）引入的循环依赖（破坏提前暴露机制）。

本质原因是：Spring 解决循环依赖的基础是 “实例化与初始化分离” 和 “单例缓存复用”，而上述场景违背了这两个前提。实际开发中，应尽量避免循环依赖，若无法避免，优先使用 setter 注入（而非构造器注入），并确保 Bean 为单例。