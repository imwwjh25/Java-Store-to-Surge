###  扫码登录系统设计（完整方案）

扫码登录的核心是 **“三端联动”**（PC 端、手机端、服务端），通过「临时二维码 ID 作为纽带」，实现 “PC 端发起请求→手机端确认→服务端同步状态” 的闭环，核心目标是安全、高效、无感知登录。以下是落地性极强的设计方案：

#### 一、核心架构（三端角色与交互流程）

| 端角色           | 核心职责                                      | 关键动作                                           |
| ---------------- | --------------------------------------------- | -------------------------------------------------- |
| PC 端（待登录）  | 发起登录请求、展示二维码、轮询登录状态        | 生成二维码、定时请求服务端查询状态、登录成功后跳转 |
| 手机端（已登录） | 扫描二维码、确认登录意愿                      | 扫码解析信息、调用 APP 登录态、向服务端确认登录    |
| 服务端           | 生成临时二维码 ID、存储三端关联关系、同步状态 | 生成唯一二维码 ID、维护状态缓存、推送登录结果      |

#### 二、完整交互流程（ step-by-step ）

1. **PC 端发起登录请求**：
    - 用户打开 PC 端应用（如微信 PC 版、电商网站），点击 “扫码登录”；
    - PC 端向服务端发送 `GET /api/login/qrcode` 请求，携带 PC 端设备标识（如设备 ID、浏览器 UA）。
2. **服务端生成二维码**：
    - 服务端生成 **唯一临时二维码 ID**（如 `qrcode_12345678`，有效期 5 分钟）；
    - 关联信息存储：在 Redis 中创建键值对 `qrcode:12345678 → {status: "pending", deviceId: "pc_xxx", createTime: 1699999999}`（`status` 包括 `pending`（待扫码）、`scanned`（已扫码）、`confirmed`（已确认）、`expired`（已过期））；
    - 生成二维码内容：将 `二维码 ID + PC 端设备标识` 拼接为 URL（如 `https://xxx.com/login/confirm?qrId=qrcode_12345678&deviceId=pc_xxx`），通过二维码生成库（如 ZXing）转为图片，返回给 PC 端。
3. **PC 端展示二维码并轮询状态**：
    - PC 端渲染二维码，同时启动 **定时轮询**（如每 1 秒），向服务端发送 `GET /api/login/qrcode/status?qrId=qrcode_12345678`；
    - 轮询时携带 `qrId`，服务端查询 Redis 中该 ID 的状态，返回 `pending`/`scanned`/`confirmed`/`expired`。
4. **手机端扫码并确认登录**：
    - 用户用已登录的手机 APP 扫描 PC 端二维码，解析出 `qrId` 和 `deviceId`；
    - 手机 APP 向服务端发送 `POST /api/login/confirm` 请求，携带参数：`qrId=qrcode_12345678`、`phoneToken=xxx`（手机端已登录的会话 Token）、`deviceId=pc_xxx`；
    - 服务端验证 `phoneToken` 有效性（确认手机端已登录），通过后更新 Redis 状态：`qrcode:12345678 → {status: "confirmed", userId: 1001, pcToken: "pc_token_xxx"}`（`pcToken` 是为 PC 端生成的登录会话 Token）。
5. **PC 端感知登录成功并跳转**：
    - PC 端下一次轮询时，服务端返回 `status: "confirmed"` 和 `pcToken`；
    - PC 端存储 `pcToken` 到 Cookie 或 LocalStorage，后续请求携带该 Token 标识登录状态；
    - PC 端跳转至登录后的首页，扫码登录流程结束。

#### 三、关键设计细节（安全 + 体验）

1. **二维码有效期**：设置 5 分钟过期（Redis 键设置过期时间），避免二维码被复用；

2. **防重复扫码**：手机端扫码后，服务端将状态更新为 `scanned`，PC 端轮询时显示 “已扫码，请在手机端确认”，避免重复扫码；

3. 安全校验 ：

    - 手机端确认时，服务端验证 `phoneToken` 有效性（如是否在有效期、是否绑定设备）；
    - 禁止跨设备复用：`deviceId` 与 `qrId` 绑定，避免二维码被其他 PC 端复用；

4. **降级方案**：二维码过期后，PC 端自动刷新生成新二维码；轮询失败时（如网络中断），提示用户重新发起登录。

### 5. 二维码 ID 的核心作用

二维码 ID 是扫码登录系统的 **“核心纽带”**，所有三端交互都围绕它展开，具体作用：

1. **唯一标识登录请求**：每个 PC 端发起的登录请求对应一个唯一二维码 ID，服务端通过该 ID 区分不同的登录会话（如同时有 100 个用户扫码登录，通过二维码 ID 定位到各自的状态）；
2. **存储关联关系**：服务端通过二维码 ID 关联 PC 端设备标识（`deviceId`）、手机端用户 ID（`userId`）、登录状态（`pending/scanned/confirmed`），形成 “PC 端→用户→状态” 的映射；
3. **安全校验载体**：二维码 ID 是临时、一次性的，仅用于本次登录，避免永久凭证泄露（相比直接在二维码中存储用户 Token 更安全）；
4. **状态同步钥匙**：PC 端通过二维码 ID 轮询状态，手机端通过二维码 ID 确认登录，服务端通过二维码 ID 更新和查询状态，三端通过它实现 “无直接通信” 的同步。

### 6. 三端的串联方式（核心是 “二维码 ID + 服务端缓存”）

三端本身不直接通信（PC 端和手机端无直接网络连接），完全通过 **“服务端作为中间枢纽”** 串联，核心串联逻辑：

1. **串联媒介**：二维码 ID（唯一临时标识）+ 服务端缓存（Redis）；

2. 串联流程 ：

    - PC 端→服务端：通过二维码 ID 发起 “生成二维码” 和 “查询状态” 请求，将 PC 端设备信息与二维码 ID 绑定；
    - 手机端→服务端：通过扫码解析的二维码 ID，将手机端登录态（`phoneToken`）与二维码 ID 绑定；
    - 服务端→三端：通过二维码 ID 关联 PC 端设备、手机端用户，更新状态后同步给 PC 端（轮询响应）和手机端（确认结果）；

3. **本质**：二维码 ID 是 “临时会话 ID”，服务端缓存是 “会话状态存储中心”，三端通过该 ID 向服务端读写状态，实现间接串联。

### 7. PC 端感知登录状态的两种核心方式

PC 端无法主动接收服务端推送（除非用 WebSocket），主流采用 **“轮询”** 或 **“WebSocket 推送”** 两种方式，前者简单通用，后者实时性更高：

#### 方式 1：定时轮询（最常用，兼容性强）

- 原理：PC 端生成二维码后，启动定时器（如每 1 秒），向服务端发送 HTTP/HTTPS 请求，查询当前二维码 ID 的登录状态；

- 流程：

    1. PC 端用 `setInterval`（前端）或定时任务（后端渲染场景），每秒调用 `GET /api/login/qrcode/status?qrId=xxx`；

    2. 服务端查询 Redis 中该```qrId```的状态：

     - 若为 `pending`：返回 “未扫码”，PC 端继续轮询；
     - 若为 `scanned`：返回 “已扫码，请在手机端确认”，PC 端更新 UI 提示；
     - 若为 `confirmed`：返回 “登录成功”+ `pcToken`，PC 端存储 Token 并跳转；
     - 若为 `expired`：返回 “二维码已过期”，PC 端刷新生成新二维码；

- 优点：实现简单，无兼容性问题（支持所有浏览器 / PC 应用）；

- 缺点：有轻微延迟（最长 1 秒），存在无效请求（如二维码未被扫码时的轮询），但可通过调整轮询间隔（如前 30 秒 1 秒 / 次，后 2 分半 2 秒 / 次）优化。

#### 方式 2：WebSocket 推送（实时性高，适用于高体验场景）

- 原理：PC 端生成二维码时，与服务端建立 WebSocket 长连接，服务端状态变化时主动推送结果给 PC 端，无需 PC 端主动查询；
- 流程：
    1. PC 端发起登录请求，生成二维码后，建立 WebSocket 连接（如 `wss://xxx.com/login/ws?qrId=xxx`）；
    2. 服务端通过 WebSocket 连接，实时推送状态：
        - 手机端扫码后，服务端推送 `{"status": "scanned"}`；
        - 手机端确认登录后，服务端推送 `{"status": "confirmed", "pcToken": "xxx"}`；
        - 二维码过期后，服务端推送 `{"status": "expired"}`；
    3. PC 端接收推送后，即时更新 UI 或跳转；
- 优点：实时性强（状态变化立即感知），无无效请求，节省带宽；
- 缺点：实现稍复杂（需处理 WebSocket 连接断开重连），部分老旧环境（如旧浏览器）不支持。

#### 主流选择

- 大多数场景（如微信 PC 版、淘宝 PC 端）采用 **定时轮询**（1 秒间隔），兼顾简单性和体验；
- 高体验要求场景（如企业办公系统、直播平台）采用 **WebSocket 推送**，减少延迟。

### 核心总结

1. 扫码登录的核心是 “二维码 ID 作为临时纽带 + 服务端缓存存储状态”；
2. 三端通过服务端串联，无直接通信，依赖二维码 ID 读写状态；
3. PC 端通过 “定时轮询” 或 “WebSocket 推送” 感知登录状态，前者通用，后者实时。