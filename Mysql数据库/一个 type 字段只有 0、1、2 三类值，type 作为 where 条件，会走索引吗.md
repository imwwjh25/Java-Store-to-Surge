结论：**不一定走索引，核心取决于「数据分布」和「查询返回行数占比」**——`type` 只有 0、1、2 三个值（低基数），若查询返回行数超过表总行数的 10%-20%（优化器阈值），MySQL 会放弃索引走全表扫描；只有返回行数较少时，才会走索引。

### 一、关键前提：索引生效的核心逻辑

MySQL 优化器选择「走索引」还是「全表扫描」，本质是「成本计算」：

- 走索引成本：先查索引树（找到匹配的 `type` 对应的物理地址）→ 再回表查数据（聚簇索引），需多次随机 IO；
- 全表扫描成本：顺序扫描全表，直接读取数据，仅需一次顺序 IO。

对于低基数列（如 `type` 仅 3 个值），若某类值占比极高（如 `type=0` 占 80% 数据），查询 `type=0` 时，走索引的随机 IO 成本会高于全表扫描的顺序 IO 成本，优化器会放弃索引；若某类值占比极低（如 `type=2` 仅占 5%），走索引成本更低，会触发索引扫描。

### 二、具体场景拆解（是否走索引）

假设表 `t` 有 100 万行数据，`type` 取值 0（80 万行）、1（15 万行）、2（5 万行），`type` 列已建普通索引：

| 查询语句                        | 数据占比 | 优化器选择         | 原因                                                         |
| ------------------------------- | -------- | ------------------ | ------------------------------------------------------------ |
| `SELECT * FROM t WHERE type=0`  | 80%      | 全表扫描           | 返回行数太多，索引回表成本 > 全表扫描成本，优化器放弃索引；  |
| `SELECT * FROM t WHERE type=1`  | 15%      | 可能走索引         | 接近阈值（10%-20%），优化器会根据表统计信息动态判断（如数据更新频繁可能影响）； |
| `SELECT * FROM t WHERE type=2`  | 5%       | 走索引             | 返回行数少，索引查询 + 回表成本 < 全表扫描成本；             |
| `SELECT id FROM t WHERE type=0` | 80%      | 走索引（覆盖索引） | 仅查询 `id`（索引已包含该字段），无需回表，索引扫描成本更低； |

### 三、低基数列的索引优化建议（实用！）

1. **用覆盖索引避免回表**：若查询仅需少量字段（如 `id`、`type`），可创建「联合索引」（如 `idx_type_id (type, id)`），让索引包含查询所需所有字段，此时即使返回行数多，也会走索引（无回表成本）；
2. **避免用低基数列单独建索引**：单独建索引效果差，还会占用存储空间、降低写性能（插入 / 更新需维护索引），建议结合其他高基数列建联合索引（如 `idx_type_uid (type, user_id)`）；
3. **强制走索引（谨慎使用）**：若业务需强制走索引，可加 `FORCE INDEX` hint（如 `SELECT * FROM t FORCE INDEX (idx_type) WHERE type=0`），但需验证性能（避免强制走索引后性能更差）；
4. **分表拆分**：若某类 `type` 数据量极大（如 `type=0` 占 90%），可按 `type` 分表（如 `t_type0`、`t_type1`、`t_type2`），彻底避免全表扫描。

### 四、面试总结（直接背）

`type` 字段仅 0、1、2 三个值（低基数），作为 `where` 条件时：

1. 不一定走索引，核心看「查询返回行数占比」（优化器阈值 10%-20%）：占比低则走索引，占比高则全表扫描；
2. 关键影响因素：数据分布（各类值占比）、是否需要回表（是否覆盖索引）、表统计信息；
3. 优化方向：建覆盖索引、联合索引，避免单独建低基数索引，必要时分表。

简单说：低基数列的索引生效与否，本质是「回表成本」和「全表扫描成本」的权衡 —— 能避免回表，或返回行数少，就走索引；否则就走全表扫描。