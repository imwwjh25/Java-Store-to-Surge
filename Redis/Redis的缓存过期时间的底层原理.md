Redis 中缓存过期时间的设置和过期 key 的删除机制是保证缓存有效性的核心，底层设计非常巧妙，既兼顾性能又能合理释放资源。我们分两部分详细解释：

### 6. Redis 缓存的过期时间底层是如何设置的？

Redis 为 key 设置过期时间的底层实现，本质是**给 key 附加一个 “过期时间戳” 元数据**，并通过数据结构维护这些过期信息，具体流程和存储方式如下：

#### （1）设置过期时间的命令

用户通过 `EXPIRE key seconds`、`PEXPIRE key milliseconds`、`SET key value EX seconds` 等命令为 key 设置过期时间，底层最终会转化为 “绝对时间戳”（距离 Unix 纪元的毫秒数）存储。

#### （2）底层存储：过期字典（expires dict）

Redis 内部维护了一个**全局的哈希表（过期字典）**，专门存储所有 key 的过期时间：

- **键（key）**：指向 Redis 数据库中实际的 key（与主字典的 key 共享内存，避免冗余）。
- **值（value）**：存储该 key 的过期时间戳（毫秒级），即 key 失效的绝对时间（如 `1718923200000` 表示 2024-06-21 00:00:00 失效）。

#### （3）设置过程的底层逻辑

当执行 `EXPIRE key 100`（100 秒后过期）时：

1. 计算过期时间戳：当前服务器时间（`server.lua_caller->time`）+ 100 秒（转换为毫秒）。
2. 将 `key` 和计算出的时间戳插入过期字典（`expires`）：若 key 已存在，更新时间戳；若不存在，新增条目。
3. 若 key 原本不存在于主字典（`db->dict`），则设置过期时间无效（Redis 不允许为不存在的 key 设置过期时间）。

#### （4）过期时间的特殊处理

- 若对已设置过期时间的 key 执行 `SET`、`DEL` 等覆盖 / 删除操作，过期时间会被清除（从过期字典中移除该 key）。
- 若执行 `PERSIST key` 命令，会主动移除过期字典中该 key 的条目，使其永久有效。

### 7. Redis 过期的 key 是如何进行删除的？

Redis 不会在 key 过期的瞬间立即删除（“即时删除” 会导致性能问题），而是采用 **“惰性删除 + 定期删除”** 的混合策略，平衡内存占用和 CPU 消耗。

#### （1）惰性删除（Lazy Expiration）：“用的时候再检查”

- **触发时机**：当客户端访问某个 key 时（如 `GET key`），Redis 会先检查该 key 是否在过期字典中，且当前时间是否已超过过期时间戳。

- 删除逻辑 ：

    1. 若 key 已过期，从主字典（`db->dict`）和过期字典（`expires`）中删除该 key。
    2. 返回空结果（告知客户端 key 不存在）。

- **优点**：只在访问时检查，不浪费 CPU 资源在未访问的过期 key 上。

- **缺点**：若过期 key 长期未被访问，会一直占用内存（可能导致内存泄漏）。

#### （2）定期删除（Periodic Expiration）：“主动批量检查”

为了弥补惰性删除的内存泄漏问题，Redis 会定期（默认每 100 毫秒）触发一次后台任务，批量检查并删除过期 key，具体流程：

1. **随机抽样检查**：每次从过期字典中随机抽取 N 个 key（默认 N=20）。

2. **删除过期 key**：检查这 N 个 key 中已过期的，全部删除。

3. 判断是否需要继续 ：若本次删除的过期 key 占比超过 25%，则重复步骤 1（继续抽样检查），否则结束本次定期删除。

    - 这样设计是为了避免一次性处理大量过期 key 导致 Redis 阻塞（通过 “小批量、多轮次” 控制时间）。

4. **时间限制**：每次定期删除的总耗时不超过 25 毫秒（避免影响主线程处理请求）。

- **优点**：主动清理部分过期 key，减少内存浪费。
- **缺点**：可能存在 “漏网之鱼”（未被抽样到的过期 key 仍占用内存）。

#### （3）内存淘汰机制（Maxmemory Eviction）：“内存不足时的最后防线”

当 Redis 内存使用达到 `maxmemory` 限制时，会触发内存淘汰机制，此时即使 key 未过期，也可能被删除（取决于配置的淘汰策略，如 `allkeys-lru`、`volatile-lru` 等）。其中：

- `volatile-*` 策略（如 `volatile-lru`）：只淘汰**已设置过期时间且过期**或**虽未过期但内存不足**的 key。
- `allkeys-*` 策略：无论是否设置过期时间，只要内存不足就可能被淘汰。

这一机制是对前两种删除策略的补充，确保 Redis 不会因内存耗尽而崩溃。

### 总结：三种机制的协同作用

- **惰性删除**：保证 “访问时的正确性”，不浪费 CPU。
- **定期删除**：主动清理部分过期 key，平衡内存和 CPU。
- **内存淘汰**：内存不足时强制释放空间，防止 OOM。

三者结合，使得 Redis 在处理过期 key 时既能保持高性能，又能合理控制内存占用，这也是 Redis 作为缓存中间件高效的重要原因。
