MySQL 索引失效是查询性能优化中最常见的坑，核心原因是 **查询条件破坏了索引的 “有序性” 或 “可用性”**，导致优化器放弃走索引，转而全表扫描（type=ALL）。以下是 **12 种高频索引失效场景**，结合示例和原理拆解，帮你彻底避开陷阱：

## 一、核心前提：索引生效的基础

索引本质是 “有序数据结构”（如 B+ 树），优化器走索引的核心是 “能通过索引快速定位数据”。若查询条件让索引的 “有序性” 失效，或需要额外处理才能匹配数据，优化器会认为 “走索引不如全表扫描高效”，直接放弃索引。

## 二、高频索引失效场景（按出现频率排序）

### 场景 1：索引列参与函数 / 表达式运算

**原理**：索引存储的是 “原始列值”，若对索引列做函数 / 表达式运算，优化器无法直接使用索引的有序性，需逐行计算后匹配，导致索引失效。

#### 反例（失效）：



```sql
-- 索引列 id 参与函数运算（SUBSTRING）
SELECT * FROM user WHERE SUBSTRING(id, 1, 3) = '100';

-- 索引列 age 参与算术运算
SELECT * FROM user WHERE age + 1 = 30;

-- 索引列 create_time 参与函数运算（DATE_FORMAT）
SELECT * FROM order WHERE DATE_FORMAT(create_time, '%Y-%m-%d') = '2025-11-14';
```

#### 正例（生效）：


```sql
-- 函数运算移到右边（常量侧），索引列保持原始值
SELECT * FROM user WHERE id LIKE '100%'; -- 前缀匹配，走索引
SELECT * FROM user WHERE age = 30 - 1; -- 算术运算移到常量侧
SELECT * FROM order WHERE create_time BETWEEN '2025-11-14 00:00:00' AND '2025-11-14 23:59:59';
```

### 场景 2：隐式类型转换

**原理**：索引列与查询条件的值类型不匹配，MySQL 会自动做类型转换（如字符串→数字、数字→字符串），转换过程会破坏索引有序性，导致失效。

#### 反例（失效）：

```sql
-- 索引列 phone 是 VARCHAR 类型，查询条件用数字（隐式转换：字符串→数字）
SELECT * FROM user WHERE phone = 13800138000;

-- 索引列 id 是 INT 类型，查询条件用字符串（隐式转换：数字→字符串，偶尔可能生效，但不推荐）
SELECT * FROM user WHERE id = '1001';
```

#### 正例（生效）：


```sql
-- 类型严格匹配
SELECT * FROM user WHERE phone = '13800138000'; -- VARCHAR 匹配字符串
SELECT * FROM user WHERE id = 1001; -- INT 匹配数字
```

#### 关键提醒：

- 字符串列（VARCHAR）匹配数字时，**必然失效**（因为需要对每一行的字符串转数字，无法走索引）；
- 数字列（INT）匹配字符串时，MySQL 会将字符串转数字（常量侧转换），可能生效，但仍建议严格匹配类型（避免优化器误判）。

### 场景 3：LIKE 以 % 开头（前缀模糊匹配）

**原理**：B+ 树索引是 “前缀有序” 的，若 LIKE 以 `%` 开头（如 `%xxx`），优化器无法从索引的起始位置定位，只能全表扫描；若以 `xxx%` 开头（后缀模糊），仍可走索引。

#### 反例（失效）：


```sql
-- 索引列 name 前缀模糊匹配（% 开头）
SELECT * FROM user WHERE name LIKE '%张三';
SELECT * FROM user WHERE name LIKE '%张三%'; -- 前后都有 %，完全模糊
```

#### 正例（生效）：


```sql
-- 后缀模糊匹配（% 结尾），走索引
SELECT * FROM user WHERE name LIKE '张三%';

-- 完全匹配（无 %），走索引
SELECT * FROM user WHERE name = '张三';
```

#### 替代方案：

- 若需完全模糊匹配，可使用 **全文索引（FULLTEXT）**（适合字符串长度较长的场景，如文章内容）；
- 用 Elasticsearch 等搜索引擎替代（适合高频模糊查询场景）。

### 场景 4：OR 连接的条件中，存在非索引列

**原理**：OR 逻辑要求 “满足任一条件即可”，若其中一个条件的列无索引，优化器无法通过索引快速过滤所有符合条件的行，只能全表扫描（即使其他列有索引）。

#### 反例（失效）：

```sql
-- id 有索引，age 无索引，OR 连接导致索引失效
SELECT * FROM user WHERE id = 100 OR age = 30;
```

#### 正例（生效）：


```sql
-- 方案 1：所有 OR 条件的列都建索引（复合索引或单列索引）
CREATE INDEX idx_user_id ON user(id);
CREATE INDEX idx_user_age ON user(age);
SELECT * FROM user WHERE id = 100 OR age = 30; -- 走索引合并（type=index_merge）

-- 方案 2：用 UNION 替代 OR（适合部分列无索引的场景）
SELECT * FROM user WHERE id = 100
UNION ALL
SELECT * FROM user WHERE age = 30;
```

#### 注意：

- 索引合并（index_merge）的性能不一定比全表扫描好（需优化器判断），建议优先给核心查询条件的列建复合索引。

### 场景 5：联合索引不满足 “最左前缀原则”

**原理**：联合索引（如 `idx_a_b_c(a,b,c)`）的 B+ 树是按 “a→b→c” 的顺序排序的，查询条件必须从左到右匹配索引列，且不能跳过中间列，否则后续列的索引失效。

#### 反例（失效 / 部分失效）：


```sql
-- 联合索引：idx_a_b_c(a,b,c)
SELECT * FROM user WHERE b = 2 AND c = 3; -- 跳过 a，索引完全失效
SELECT * FROM user WHERE a = 1 AND c = 3; -- 跳过 b，仅 a 列走索引，c 列失效
SELECT * FROM user WHERE c = 3; -- 跳过 a、b，索引完全失效
```

#### 正例（生效）：

```sql
-- 从左到右匹配，不跳过中间列
SELECT * FROM user WHERE a = 1; -- 走索引（仅用 a 列）
SELECT * FROM user WHERE a = 1 AND b = 2; -- 走索引（用 a、b 列）
SELECT * FROM user WHERE a = 1 AND b = 2 AND c = 3; -- 走索引（用 a、b、c 列）

-- 中间列是范围查询，后续列失效，但前面列仍生效
SELECT * FROM user WHERE a = 1 AND b > 2 AND c = 3; -- a、b 列走索引，c 列失效
```

#### 关键提醒：

- 联合索引的列顺序决定了查询条件的匹配顺序，需按 “查询频率从高到低” 排列列（高频列在前）；
- 范围查询（>、<、BETWEEN、IN）会让后续列的索引失效（因为范围后的数据无序）。

### 场景 6：使用 NOT IN / NOT EXISTS / != / <>

**原理**：`NOT IN`、`!=` 等条件是 “排除性” 的，优化器认为 “符合条件的行占比可能较高”，走索引需要逐行过滤，效率不如全表扫描（具体是否失效取决于数据分布）。

#### 反例（大概率失效）：


```sql
-- 索引列 id，NOT IN 导致失效
SELECT * FROM user WHERE id NOT IN (100, 200, 300);

-- 索引列 name，!= 导致失效
SELECT * FROM user WHERE name != '张三';

-- 索引列 age，<> 导致失效（<> 等同于 !=）
SELECT * FROM user WHERE age <> 30;
```

#### 正例（生效）：


```sql
-- 用 LEFT JOIN + IS NULL 替代 NOT IN（避免失效，且处理 NULL 更友好）
SELECT u.* FROM user u
LEFT JOIN temp t ON u.id = t.id
WHERE t.id IS NULL;

-- 用 BETWEEN 替代 !=（适合数值型列）
SELECT * FROM user WHERE age < 30 OR age > 30; -- 若 age 有索引，可能走范围索引

-- 用 NOT EXISTS 替代 NOT IN（子查询场景）
SELECT * FROM user u
WHERE NOT EXISTS (SELECT 1 FROM order o WHERE o.user_id = u.id);
```

#### 注意：

- 若 “排除性条件” 的结果集占比极低（如 < 5%），优化器可能仍会走索引，具体取决于 MySQL 的统计信息。

### 场景 7：查询条件包含 NULL 判断（IS NULL / IS NOT NULL）

**原理**：MySQL 的 B+ 树索引会存储 NULL 值，但优化器对 NULL 的处理较为保守：

- `IS NULL`：若索引列允许 NULL，且 NULL 值较少，可能走索引；若 NULL 值较多，可能全表扫描；
- `IS NOT NULL`：大概率失效（因为需要排除大量 NULL 值，优化器认为全表扫描更高效）。

#### 反例（大概率失效）：


```sql
-- 索引列 email 允许 NULL，IS NOT NULL 导致失效
SELECT * FROM user WHERE email IS NOT NULL;
```

#### 正例（优化方案）：

```sql
-- 方案 1：给索引列设置默认值（如空字符串 ''），避免 NULL 值
ALTER TABLE user MODIFY COLUMN email VARCHAR(50) DEFAULT '';
SELECT * FROM user WHERE email != ''; -- 走索引

-- 方案 2：若必须允许 NULL，用覆盖索引优化（避免全表扫描）
CREATE INDEX idx_email_name ON user(email, name); -- 覆盖查询所需列
SELECT name FROM user WHERE email IS NOT NULL; -- 走覆盖索引（type=range）
```

### 场景 8：JOIN 连接的条件中，关联列类型不匹配

**原理**：JOIN 时，若两个表的关联列类型不一致（如 VARCHAR vs INT），会触发隐式类型转换，导致关联列的索引失效，进而引发全表扫描（尤其是小表驱动大表时，性能极差）。

#### 反例（失效）：

```sql
-- user 表的 id 是 INT 类型（有索引），order 表的 user_id 是 VARCHAR 类型（有索引）
SELECT * FROM user u
JOIN order o ON u.id = o.user_id; -- 隐式转换：o.user_id（字符串）→ 数字，索引失效
```

#### 正例（生效）：

```sql
-- 方案 1：统一关联列类型（推荐）
ALTER TABLE order MODIFY COLUMN user_id INT; -- 与 user.id 类型一致
SELECT * FROM user u JOIN order o ON u.id = o.user_id; -- 双表都走索引

-- 方案 2：手动转换类型（避免隐式转换）
SELECT * FROM user u
JOIN order o ON CAST(o.user_id AS UNSIGNED) = u.id; -- 转换常量侧（order.user_id 仍走索引）
```

### 场景 9：使用 LIMIT 但条件无索引（或索引失效）

**原理**：LIMIT 仅限制结果集返回行数，但 “找到符合条件的行” 仍需扫描数据。若查询条件无索引（或索引失效），即使 LIMIT 1，也会全表扫描（只是扫描到第 1 条符合条件的行后停止）。

#### 反例（失效）：

```sql
-- name 无索引，即使 LIMIT 1，仍全表扫描
SELECT * FROM user WHERE name = '张三' LIMIT 1;
```

#### 正例（生效）：

```sql
-- 给 name 建索引，LIMIT 1 会快速定位到数据
CREATE INDEX idx_user_name ON user(name);
SELECT * FROM user WHERE name = '张三' LIMIT 1; -- 走索引（type=ref）
```

### 场景 10：优化器认为全表扫描比走索引更快

**原理**：MySQL 优化器会根据 “表数据量、索引选择性、统计信息” 判断走索引还是全表扫描：

- 若表数据极少（如 < 100 行），全表扫描比走索引更快（避免索引查询的额外开销）；
- 若索引选择性极低（如索引列值重复率高，如性别列：男 / 女），优化器认为走索引意义不大，会选择全表扫描。

#### 示例（索引失效，但合理）：

```sql
-- 性别列 sex 有索引，但值只有 '男'/'女'（选择性极低）
SELECT * FROM user WHERE sex = '男'; -- 优化器选择全表扫描，索引失效
```

#### 优化方案：

- 此类低选择性列不适合建单列索引，可作为联合索引的后缀列；

- 若必须查询，可通过```FORCE INDEX```强制走索引（不推荐，除非明确优化器判断错误）：


  ```sql
  SELECT * FROM user FORCE INDEX(idx_sex) WHERE sex = '男';
  ```

  

### 场景 11：使用 SELECT * 导致覆盖索引失效

**原理**：覆盖索引是 “索引包含查询所需的所有列”，无需回表查询数据（效率极高）。若使用 `SELECT *`，会查询表中所有列，若索引未包含所有列，优化器无法使用覆盖索引，可能导致索引失效（或触发回表，性能下降）。

#### 反例（覆盖索引失效）：


```sql
-- 联合索引 idx_name_age(name, age)，但查询所有列，需回表
SELECT * FROM user WHERE name LIKE '张三%'; -- 走索引但需回表，性能不如覆盖索引
```

#### 正例（生效）：

```sql
-- 只查询索引包含的列，使用覆盖索引（无需回表）
SELECT name, age FROM user WHERE name LIKE '张三%'; -- 走覆盖索引（type=range）

-- 若需查询其他列，将列加入联合索引（扩展覆盖索引）
CREATE INDEX idx_name_age_email ON user(name, age, email);
SELECT name, age, email FROM user WHERE name LIKE '张三%'; -- 走覆盖索引
```

### 场景 12：更新统计信息过期

**原理**：MySQL 优化器依赖 “表统计信息”（如数据量、列值分布）判断是否走索引。若表数据频繁增删改，统计信息未及时更新，优化器可能做出错误判断（如认为全表扫描更快，导致索引失效）。

#### 示例（索引失效，因统计信息过期）：

```sql
-- 表 user 原本 100 行数据，后插入 100 万行，但统计信息未更新
SELECT * FROM user WHERE id = 100000; -- 优化器仍认为数据量小，走全表扫描
```

#### 解决方案：

- 手动更新统计信息：

  ```sql
  ANALYZE TABLE user; -- 更新表统计信息
  ```

  

- 开启自动更新统计信息（MySQL 8.0 默认开启，5.7 需配置）：

  ```sql
  SET GLOBAL innodb_stats_auto_recalc = ON;
  ```

  

## 三、如何快速判断索引是否失效？

用 `EXPLAIN` 分析查询语句，重点关注以下字段：

1. `type`：索引生效时通常为 `ref`、`range`、`eq_ref`、`index`（覆盖索引）；若为 `ALL`，说明全表扫描（索引失效）；
2. `key`：显示实际使用的索引，若为 `NULL`，说明未使用索引；
3. `rows`：预估扫描的行数，若数值过大（接近表总数据量），可能索引失效；
4. `Extra`：若出现 `Using fulltext`（全文索引）、`Using index`（覆盖索引），说明索引生效；若出现 `Using where; Using filesort`（排序未走索引）、`Using where; Using temporary`（临时表），可能索引失效或需优化。

#### 示例：

```sql
EXPLAIN SELECT * FROM user WHERE SUBSTRING(id, 1, 3) = '100';
-- type=ALL，key=NULL → 索引失效
```

## 四、索引失效核心总结

1. 索引失效的本质：**查询条件破坏了索引的有序性，或优化器认为走索引不如全表扫描高效**；
2. 高频避坑点：函数运算、隐式类型转换、LIKE % 开头、联合索引最左前缀、OR 非索引列；
3. 优化原则：
   - 索引列尽量保持 “原始值” 参与查询，避免函数 / 表达式；
   - 严格匹配数据类型，避免隐式转换；
   - 联合索引按 “查询频率→范围查询” 排序（高频列在前，范围列在后）；
   - 用 `EXPLAIN` 验证索引是否生效，及时调整查询或索引。
