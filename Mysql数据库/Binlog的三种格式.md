MySQL 的 binlog（二进制日志）有三种核心格式，分别是 **STATEMENT（语句级）**、**ROW（行级）**、**MIXED（混合级）**—— 格式决定了 binlog 记录「数据库修改操作」的方式，直接影响主从复制的一致性、日志体积和性能，生产环境首选 **ROW 格式**。

下面从「格式定义、记录逻辑、优缺点、适用场景」四个维度，逐一拆解三种格式：

### 一、三种 binlog 格式详解

#### 1. STATEMENT（语句级格式，简称 SBR）

- **核心定义**：binlog 仅记录「执行的 SQL 语句本身」，不记录具体修改的行数据 —— 主从复制时，从库会原样执行 binlog 中的 SQL 语句，达到数据同步的目的。

- 记录逻辑示例 ：





  ```
  UPDATE user SET age=25 WHERE id BETWEEN 1 AND 100;
  ```

（修改 100 行数据），binlog 仅记录这条```UPDATE```



语句，不记录每一行的修改前后值。

- 优点 ：

    - 日志体积极小（仅存 SQL 语句，无需记录行数据）；
    - 可读性强（可直接通过 `mysqlbinlog` 工具查看执行的 SQL）。

- 缺点

  （核心问题，导致逐渐被淘汰）：

    - 主从复制一致性风险：依赖 SQL 执行上下文（如 `NOW()`、`RAND()`、`USER()` 等函数，主库执行时取当前值，从库执行时可能取不同值）；
    - 不支持部分 SQL 语法：如 `LOAD DATA INFILE`、自定义函数（UDF）、存储过程中的非确定性逻辑，可能导致主从数据不一致；
    - 依赖索引：从库执行 SQL 时需重新解析、优化、执行，若索引不一致，可能执行计划不同（如主库走索引，从库全表扫描），导致同步延迟或数据不一致。

- **适用场景**：仅适用于早期简单业务、无复杂函数 / 存储过程、主从索引完全一致的场景（目前几乎不推荐使用）。

#### 2. ROW（行级格式，简称 RBR）

- **核心定义**：binlog 不记录 SQL 语句本身，而是记录「每一行数据的修改细节」（即 “行变更”）—— 主从复制时，从库直接根据行变更记录修改对应数据，无需重新执行 SQL。

- 记录逻辑示例 ：



同样执行



  ```
  UPDATE user SET age=25 WHERE id BETWEEN 1 AND 100;
  ```

（修改 100 行），binlog 会记录「id=1 的 age 从原始值改为 25」「id=2 的 age 从原始值改为 25」…… 共 100 条行变更记录（每条记录包含修改前后的列值）。

- 优点

  （生产环境首选的核心原因）：

    - 主从复制一致性最高：不依赖 SQL 执行上下文、函数、索引，直接修改行数据，完全避免 “执行结果不一致” 问题；
    - 支持所有 SQL 语法：包括 `LOAD DATA INFILE`、UDF、存储过程等，兼容性强；
    - 从库同步效率高：无需解析 SQL、优化执行计划，直接应用行变更，减少 CPU 消耗。

- 缺点：

    - 日志体积大：修改大量行时，binlog 会记录每条行的变更，导致日志文件暴涨（如修改 10 万行，会生成 10 万条行记录）；
    - 可读性差：binlog 中是二进制的行数据，无法直接查看 SQL 语句，需通过 `mysqlbinlog -v` 命令解析为 “伪 SQL”（如 `### UPDATE user ### WHERE id=1 SET age=25`）。

- **适用场景**：生产环境首选，尤其适合有复杂业务逻辑（函数、存储过程）、主从复制要求高一致性、数据变更频繁的场景。

#### 3. MIXED（混合级格式，简称 MBR）

- **核心定义**：自动切换 STATEMENT 和 ROW 格式 —— 简单 SQL 语句（如无函数、无批量修改的单条 `INSERT/UPDATE`）用 STATEMENT 格式（节省日志体积）；复杂 SQL 语句（如含 `NOW()`、`RAND()`、批量修改、存储过程）自动切换为 ROW 格式（保证一致性）。

- 记录逻辑示例 ：

    - 单条 `UPDATE user SET age=25 WHERE id=1;`（无函数）→ 用 STATEMENT 格式，记录 SQL 语句；
    - 批量 `UPDATE user SET age=25 WHERE id BETWEEN 1 AND 100;`（批量修改）→ 自动切换为 ROW 格式，记录行变更。

- **优点**：平衡日志体积和一致性，兼顾 STATEMENT 的小巧和 ROW 的可靠。

- **缺点**：格式切换逻辑复杂，排查主从复制问题时（如日志分析、数据不一致排查），需同时考虑两种格式的特性，增加排查难度；且部分场景下仍可能出现一致性风险（如切换逻辑判断不准确）。

- **适用场景**：过渡性选择，适合既想节省日志空间，又担心纯 STATEMENT 格式一致性问题的场景（但目前生产环境更倾向直接用 ROW 格式，避免切换带来的复杂性）。

### 二、三种格式核心对比表（面试直接背）

| 格式      | 记录内容           | 一致性 | 日志体积 | 可读性 | 适用场景                           |
| --------- | ------------------ | ------ | -------- | ------ | ---------------------------------- |
| STATEMENT | 执行的 SQL 语句    | 低     | 极小     | 强     | 简单业务、无复杂函数（几乎不推荐） |
| ROW       | 每行数据的修改细节 | 高     | 较大     | 弱     | 生产环境首选、高一致性要求         |
| MIXED     | 自动切换前两种格式 | 中     | 中等     | 中等   | 过渡场景、平衡体积和一致性         |


简单说：生产环境直接用 ROW 格式，兼顾主从一致性和兼容性，日志体积问题通过运维手段解决。
