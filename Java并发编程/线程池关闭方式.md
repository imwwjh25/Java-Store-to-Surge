Java 线程池的关闭流程主要通过`shutdown()`、`shutdownNow()`等方法实现，其核心是**中断线程、处理任务队列、终止线程池**，并涉及线程池状态的流转。以下从源码层面（基于 JDK 8）详细分析关闭流程的细节：

### 一、线程池的核心状态与控制参数

线程池通过`ctl`原子变量维护**运行状态**和**工作线程数**（高 3 位存状态，低 29 位存线程数）：



```java
private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
private static final int COUNT_BITS = Integer.SIZE - 3;
private static final int CAPACITY   = (1 << COUNT_BITS) - 1;

// 线程池状态（从高到低）
private static final int RUNNING    = -1 << COUNT_BITS; // 接受新任务+处理队列任务
private static final int SHUTDOWN   =  0 << COUNT_BITS; // 不接受新任务+处理队列任务
private static final int STOP       =  1 << COUNT_BITS; // 不接受新任务+中断处理中任务+抛弃队列任务
private static final int TIDYING    =  2 << COUNT_BITS; // 所有任务终止，工作线程数为0，准备执行terminated()
private static final int TERMINATED =  3 << COUNT_BITS; // terminated()执行完成
```

### 二、`shutdown()`方法：优雅关闭

`shutdown()`是**平缓关闭**，流程为：拒绝新任务→处理队列剩余任务→终止线程池。

#### 1. 状态校验与切换







```java
public void shutdown() {
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        // 权限校验（安全管理器）
        checkShutdownAccess();
        // 将线程池状态从RUNNING改为SHUTDOWN（若已非RUNNING则忽略）
        advanceRunState(SHUTDOWN);
        // 中断所有空闲的工作线程
        interruptIdleWorkers();
        // 钩子方法（ScheduledThreadPoolExecutor重写此方法处理定时任务）
        onShutdown(); 
    } finally {
        mainLock.unlock();
    }
    // 尝试终止线程池（核心逻辑）
    tryTerminate();
}
```

#### 2. 中断空闲工作线程（`interruptIdleWorkers()`）

仅中断**等待任务**的空闲线程（通过`Worker`的`lock`判断）：







```java
private void interruptIdleWorkers(boolean onlyOne) {
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        for (Worker w : workers) {
            Thread t = w.thread;
            // 若线程未中断且可获取锁（说明线程处于空闲等待状态）
            if (!t.isInterrupted() && w.tryLock()) {
                try {
                    t.interrupt(); // 中断线程
                } catch (SecurityException ignore) {
                } finally {
                    w.unlock();
                }
            }
            if (onlyOne)
                break;
        }
    } finally {
        mainLock.unlock();
    }
}
```

#### 3. 尝试终止线程池（`tryTerminate()`）

`tryTerminate()`是关闭流程的核心，负责状态流转到`TERMINATED`：




```java
final void tryTerminate() {
    for (;;) {
        int c = ctl.get();
        // 若状态为RUNNING/已终止/SHUTDOWN但队列非空 → 不终止
        if (isRunning(c) || 
            runStateAtLeast(c, TIDYING) ||
            (runStateOf(c) == SHUTDOWN && ! workQueue.isEmpty()))
            return;
        
        // 若工作线程数>0 → 中断一个空闲线程（触发剩余线程处理终止逻辑）
        if (workerCountOf(c) != 0) { 
            interruptIdleWorkers(ONLY_ONE);
            return;
        }

        // 工作线程数为0，进入TIDYING状态
        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        try {
            if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) {
                try {
                    terminated(); // 钩子方法（子类可重写）
                } finally {
                    // 最终转为TERMINATED状态
                    ctl.set(ctlOf(TERMINATED, 0));
                    termination.signalAll(); // 唤醒等待线程池终止的线程（如awaitTermination()）
                }
                return;
            }
        } finally {
            mainLock.unlock();
        }
    }
}
```

### 三、`shutdownNow()`方法：强制关闭

`shutdownNow()`是**暴力关闭**，流程为：拒绝新任务→中断所有工作线程→抛弃队列任务→返回未执行的任务。

#### 1. 核心源码










```java
public List<Runnable> shutdownNow() {
    List<Runnable> tasks;
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        checkShutdownAccess();
        // 将状态改为STOP（比SHUTDOWN更严格）
        advanceRunState(STOP);
        // 中断所有工作线程（无论是否空闲）
        interruptWorkers();
        // 清空任务队列，返回未执行的任务
        tasks = drainQueue();
    } finally {
        mainLock.unlock();
    }
    tryTerminate(); // 尝试终止线程池
    return tasks;
}
```

#### 2. 中断所有线程（`interruptWorkers()`）









```java
private void interruptWorkers() {
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        for (Worker w : workers)
            w.interruptIfStarted(); // 中断所有启动的工作线程
    } finally {
        mainLock.unlock();
    }
}
```

#### 3. 清空队列（`drainQueue()`）

将队列中未执行的任务转移到 List 返回：










```java
private List<Runnable> drainQueue() {
    BlockingQueue<Runnable> q = workQueue;
    ArrayList<Runnable> taskList = new ArrayList<>();
    q.drainTo(taskList); // 批量转移
    if (!q.isEmpty()) { // 处理队列中剩余的（如SynchronousQueue）
        for (Runnable r : q.toArray(new Runnable[0])) {
            if (q.remove(r))
                taskList.add(r);
        }
    }
    return taskList;
}
```

### 四、工作线程的退出逻辑（`Worker.runWorker()`）

线程池关闭的本质是让工作线程退出循环，`runWorker()`是工作线程的核心执行逻辑：








```java
final void runWorker(Worker w) {
    Thread wt = Thread.currentThread();
    Runnable task = w.firstTask;
    w.firstTask = null;
    w.unlock(); // 允许中断
    boolean completedAbruptly = true;
    try {
        // 循环获取任务：先取firstTask，再从队列取
        while (task != null || (task = getTask()) != null) {
            w.lock();
            // 若线程池已STOP，确保当前线程被中断
            if ((runStateAtLeast(ctl.get(), STOP) ||
                 (Thread.interrupted() &&
                  runStateAtLeast(ctl.get(), STOP))) &&
                !wt.isInterrupted())
                wt.interrupt();
            try {
                beforeExecute(wt, task); // 钩子方法
                Throwable thrown = null;
                try {
                    task.run(); // 执行任务
                } catch (RuntimeException x) {
                    thrown = x; throw x;
                } catch (Error x) {
                    thrown = x; throw x;
                } catch (Throwable x) {
                    thrown = x; throw new Error(x);
                } finally {
                    afterExecute(task, thrown); // 钩子方法
                }
            } finally {
                task = null;
                w.completedTasks++;
                w.unlock();
            }
        }
        completedAbruptly = false;
    } finally {
        // 工作线程退出，处理线程池终止逻辑
        processWorkerExit(w, completedAbruptly);
    }
}
```

#### 关键：`getTask()`方法的退出条件

`getTask()`决定工作线程是否继续存活，当线程池关闭时返回`null`，触发线程退出：



```java
private Runnable getTask() {
    boolean timedOut = false; // 上次poll是否超时

    for (;;) {
        int c = ctl.get();
        int rs = runStateOf(c);

        // 条件1：线程池已STOP，或SHUTDOWN且队列为空 → 返回null，线程退出
        if (rs >= SHUTDOWN && (rs >= STOP || workQueue.isEmpty())) {
            decrementWorkerCount();
            return null;
        }

        int wc = workerCountOf(c);

        // 条件2：是否需要超时控制（核心线程超时或非核心线程）
        boolean timed = allowCoreThreadTimeOut || wc > corePoolSize;

        // 条件3：线程数超过最大值，或超时且队列为空 → 返回null，线程退出
        if ((wc > maximumPoolSize || (timed && timedOut))
            && (wc > 1 || workQueue.isEmpty())) {
            if (compareAndDecrementWorkerCount(c))
                return null;
            continue;
        }

        try {
            // 从队列取任务：timed为true则poll（超时返回null），否则take（阻塞）
            Runnable r = timed ?
                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
                workQueue.take();
            if (r != null)
                return r;
            timedOut = true; // 超时，下次循环触发退出
        } catch (InterruptedException retry) {
            timedOut = false; // 被中断，重置超时标记
        }
    }
}
```

#### 工作线程退出后的清理（`processWorkerExit()`）







```java
private void processWorkerExit(Worker w, boolean completedAbruptly) {
    if (completedAbruptly) // 若因异常退出，减少工作线程数
        decrementWorkerCount();

    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        completedTaskCount += w.completedTasks;
        workers.remove(w); // 从工作线程集合中移除
    } finally {
        mainLock.unlock();
    }

    tryTerminate(); // 尝试终止线程池（关键：触发剩余线程的终止）

    int c = ctl.get();
    // 若线程池未STOP，补充新线程（维持核心线程数）
    if (runStateLessThan(c, STOP)) {
        if (!completedAbruptly) {
            int min = allowCoreThreadTimeOut ? 0 : corePoolSize;
            if (min == 0 && ! workQueue.isEmpty())
                min = 1;
            if (workerCountOf(c) >= min)
                return; // 无需补充
        }
        addWorker(null, false); // 补充线程
    }
}
```

### 五、关闭流程总结

1. **状态切换**：`shutdown()`→SHUTDOWN，`shutdownNow()`→STOP；
2. **中断线程**：`shutdown()`中断空闲线程，`shutdownNow()`中断所有线程；
3. **任务处理**：`shutdown()`处理队列任务，`shutdownNow()`抛弃队列任务；
4. **线程退出**：`getTask()`返回`null`，工作线程退出循环；
5. **最终终止**：所有线程退出后，线程池进入 TIDYING→TERMINATED 状态，执行`terminated()`钩子。

### 关键差异：`shutdown()` vs `shutdownNow()`

| 特性       | `shutdown()`                 | `shutdownNow()`                |
| ---------- | ---------------------------- | ------------------------------ |
| 线程池状态 | SHUTDOWN                     | STOP                           |
| 新任务     | 拒绝                         | 拒绝                           |
| 队列任务   | 执行完成                     | 抛弃并返回                     |
| 工作线程   | 中断空闲线程，执行中线程继续 | 中断所有线程（无论是否空闲）   |
| 返回值     | void                         | List<Runnable>（未执行的任务） |

通过源码可见，线程池的关闭是**状态驱动**的，通过原子变量控制状态流转，结合工作线程的循环退出逻辑，最终实现优雅或强制的终止。