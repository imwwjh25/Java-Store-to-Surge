要理解 `Future.get()` 为什么是阻塞的，核心得从 **`Future` 的设计目标、多线程协作逻辑、底层实现原理** 三个层面拆解 —— 它的阻塞特性不是 “设计缺陷”，而是为了实现 “异步任务结果的同步获取” 而必然存在的机制。

### 一、先明确核心前提：`Future` 的设计目标

`Future` 是 Java 中 “异步任务的结果载体”，核心目标是：**将 “任务执行” 和 “结果获取” 解耦**—— 让主线程无需等待异步任务执行完毕（可以先去做其他事），等需要结果时，再通过 `Future` 主动获取。

但这里有个关键矛盾：**异步任务的执行是 “非阻塞” 的（主线程不等待），但 “获取结果” 的动作必然是 “阻塞” 的**—— 如果任务还没执行完，主线程要拿到结果，只能停下来等任务完成，否则无法拿到有效结果。

简单说：`Future` 的核心价值是 “允许主线程先做别的，再回头等结果”，而不是 “不用等结果”——`get()` 就是 “回头等结果” 的核心接口，阻塞是其实现逻辑的必然。

### 二、阻塞的底层原理：线程间的 “等待 - 唤醒” 机制

`Future.get()` 的阻塞的本质，是通过 **“等待队列 + 锁 + 唤醒信号”** 实现的线程间协作，底层依赖 Java 的 `Object.wait()`/`notify()` 或 `LockSupport.park()`/`unpark()` 机制（不同实现类如 `FutureTask`、`CompletableFuture` 底层细节有差异，但核心逻辑一致）。

以最常用的 `FutureTask`（`ThreadPoolExecutor` 提交任务的返回值）为例，拆解阻塞流程：

#### 1. 任务执行与 `Future` 状态管理

`FutureTask` 内部维护了一个 “任务状态”（`state` 变量），核心状态流转：`NEW`（初始）→ `COMPLETING`（任务执行中）→ `NORMAL`（任务成功）/`EXCEPTIONAL`（任务失败）→ `CANCELLED`（任务取消）。

- 当主线程调用```future.get()```时，会先检查```state```：

- 若状态是 `NORMAL`/`EXCEPTIONAL`：直接返回结果（或抛出异常），不阻塞；
- 若状态是 `NEW`/`COMPLETING`：主线程进入 “阻塞等待”。

#### 2. 阻塞的实现：主线程进入等待队列

当任务未完成时，`get()` 会将当前主线程封装成一个 “等待节点”，加入 `FutureTask` 内部的等待队列（`WaitNode` 链表），然后通过 `LockSupport.park()` 暂停主线程的执行（释放 CPU 资源，让线程进入 `WAITING` 状态）。

此时主线程不再参与 CPU 调度，直到被 “唤醒信号” 触发。

#### 3. 唤醒的实现：任务完成后通知主线程

当异步任务执行完毕（无论成功 / 失败），`FutureTask` 会更新 `state` 为 `NORMAL` 或 `EXCEPTIONAL`，然后遍历等待队列，通过 `LockSupport.unpark(thread)` 唤醒所有等待的主线程。

主线程被唤醒后，会再次检查 `state`，确认任务完成后，返回结果（或抛出任务执行时的异常），阻塞结束。

### 三、为什么不能设计成 “非阻塞”？（反推设计逻辑）

如果 `get()` 是非阻塞的，会面临两个无法解决的问题，违背 `Future` 的核心目标：

#### 1. 无法保证 “结果的有效性”

非阻塞的 `get()` 只能 “尝试获取结果”，如果任务没完成，只能返回 `null` 或 “未完成标识”。但主线程无法区分 “任务真的返回 `null`” 和 “任务没完成”，导致结果判断混乱。

示例：








```java
// 非阻塞设计的矛盾
Future<String> future = executor.submit(() -> {
    Thread.sleep(3000);
    return "任务结果"; // 正常返回非 null
});

String result = future.get(); // 非阻塞，任务未完成时返回 null
if (result == null) {
    // 无法判断：是任务没完成？还是任务真的返回 null？
}
```

#### 2. 会让主线程陷入 “轮询忙等”，浪费资源

如果 `get()` 是非阻塞的，主线程要拿到结果，只能循环调用 `get()` 直到获取有效结果（即 “轮询”）：


```java
// 非阻塞设计的低效方案
while (true) {
    String result = future.getNonBlocking(); // 非阻塞方法
    if (result != null) {
        break;
    }
    Thread.sleep(100); // 短暂休眠，减少 CPU 占用
}
```

这种方式会让主线程频繁占用 CPU 资源（即使加了 `sleep`，也不如阻塞机制高效），违背了 “异步任务解耦主线程” 的设计初衷。

### 四、关键补充：`get(timeout, unit)` 的超时阻塞

`Future` 还提供了带超时参数的 `get(long timeout, TimeUnit unit)`，其阻塞逻辑与无参 `get()` 一致，但多了 “超时唤醒” 机制：

- 主线程调用时，除了等待任务完成的 “唤醒信号”，还会注册一个 “超时计时器”；
- 若在超时时间内任务完成：正常唤醒，返回结果；
- 若超时时间到任务仍未完成：计时器触发唤醒，抛出 `TimeoutException`，主线程退出阻塞。

本质是 “等待唤醒”+“超时兜底”，核心阻塞逻辑未变。

### 五、总结：`get()` 阻塞的核心逻辑链











```plaintext
主线程调用 future.get() → 检查任务状态：
  ├─ 任务已完成 → 直接返回结果/抛异常（不阻塞）；
  └─ 任务未完成 → 主线程进入等待队列，暂停执行（阻塞）；
异步任务执行完毕 → 更新状态，唤醒所有等待的主线程 → 主线程恢复执行，返回结果/抛异常。
```

`Future.get()` 的阻塞特性，是 “异步任务结果同步获取” 的必然设计 —— 它解决了 “主线程如何安全、高效地等待异步任务结果” 的问题，避免了轮询忙等的资源浪费，同时保证了结果的有效性。

如果需要 “非阻塞获取结果”，Java 8+ 提供的 `CompletableFuture` 支持回调式编程（`thenAccept()`/`whenComplete()`），无需调用 `get()` 阻塞，本质是把 “主动等结果” 变成 “被动收通知”，但这是 `CompletableFuture` 对 `Future` 的扩展，而非否定 `get()` 的阻塞设计。
