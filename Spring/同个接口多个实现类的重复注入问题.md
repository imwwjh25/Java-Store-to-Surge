当一个接口有多个实现类时，使用 `@Autowired` 按类型（byType）注入会出现**歧义**，因为 Spring 容器中存在多个匹配该接口类型的 Bean，此时 Spring 无法确定具体要注入哪一个，会直接抛出 **`NoUniqueBeanDefinitionException`** 异常。

### 具体表现：

假设存在接口 `UserService` 和两个实现类 `UserServiceImplA`、`UserServiceImplB`，且都被 Spring 管理（如加了 `@Service` 注解）：







```java
public interface UserService {}

@Service // Bean名称默认是 userServiceImplA
public class UserServiceImplA implements UserService {}

@Service // Bean名称默认是 userServiceImplB
public class UserServiceImplB implements UserService {}
```

此时若直接用 `@Autowired` 注入 `UserService`：






```java
@Service
public class OrderService {
    @Autowired
    private UserService userService; // 报错：NoUniqueBeanDefinitionException
}
```

Spring 会报错，因为它发现有两个 `UserService` 类型的 Bean（`userServiceImplA` 和 `userServiceImplB`），无法确定注入哪一个。

### 解决办法（指定具体实现类）：

需通过额外配置告诉 Spring 具体要注入哪个 Bean，常用方式有 3 种：

#### 1. 配合 `@Qualifier` 注解指定 Bean 名称

`@Qualifier` 可以指定要注入的 Bean 的名称（默认是类名首字母小写，如 `userServiceImplA`）：










```java
@Service
public class OrderService {
    // 明确指定注入名称为"userServiceImplA"的Bean
    @Autowired
    @Qualifier("userServiceImplA") 
    private UserService userService;
}
```

#### 2. 用 `@Primary` 注解指定默认实现类

在某个实现类上添加 `@Primary`，表示当存在多个同类型 Bean 时，优先注入该 Bean：







```java
@Service
@Primary // 标记为默认实现
public class UserServiceImplA implements UserService {}

@Service
public class UserServiceImplB implements UserService {}

// 此时注入会默认选择 UserServiceImplA
@Service
public class OrderService {
    @Autowired
    private UserService userService; // 注入的是 UserServiceImplA
}
```

#### 3. 自定义 Bean 名称，通过属性名匹配

`@Autowired` 在类型匹配失败（存在多个同类型 Bean）时，会 ** fallback 到按名称（byName）匹配 **，即属性名与 Bean 名称一致时会注入对应 Bean：




```java
@Service
public class OrderService {
    // 属性名是"userServiceImplB"，与Bean名称一致，会注入 UserServiceImplB
    @Autowired
    private UserService userServiceImplB; 
}
```

### 总结：

- 当接口有多个实现类时，`@Autowired` 按类型注入会直接报错（因为存在歧义）。
- 必须通过 `@Qualifier`（指定名称）、`@Primary`（指定默认）或属性名匹配的方式，明确告诉 Spring 要注入的具体 Bean。