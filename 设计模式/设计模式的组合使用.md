### 一、工厂模式 + 策略模式（最常用组合）

#### 组合原因

- 策略模式的痛点：客户端需要知道所有策略类，手动创建策略对象（如`new AlipayStrategy()`），代码冗余且易出错；
- 工厂模式补充：封装策略的创建逻辑，客户端只需传入 “策略类型”（如`alipay`），工厂自动返回对应策略对象，降低客户端认知成本。

#### 实现思路

1. 策略层：定义抽象策略 + 具体策略（如支付策略）；
2. 工厂层：创建策略工厂，根据类型创建具体策略；
3. 环境层：持有策略对象，调用策略逻辑；
4. 客户端：仅需指定策略类型，无需直接创建策略。

#### 代码示例（支付场景）










```
// 1. 抽象策略
public interface PaymentStrategy {
    String pay(double amount);
}

// 2. 具体策略
public class AlipayStrategy implements PaymentStrategy {
    @Override
    public String pay(double amount) {
        return "支付宝支付" + amount + "元";
    }
}

public class WechatPayStrategy implements PaymentStrategy {
    @Override
    public String pay(double amount) {
        return "微信支付" + amount + "元";
    }
}

// 3. 策略工厂（核心：封装创建逻辑）
public class PaymentStrategyFactory {
    public static PaymentStrategy createStrategy(String type) {
        return switch (type) {
            case "alipay" -> new AlipayStrategy();
            case "wechat" -> new WechatPayStrategy();
            default -> throw new IllegalArgumentException("不支持的支付方式");
        };
    }
}

// 4. 环境类
public class Order {
    private PaymentStrategy strategy;

    public void setPaymentStrategy(String type) {
        this.strategy = PaymentStrategyFactory.createStrategy(type);
    }

    public String pay(double amount) {
        return strategy.pay(amount);
    }
}

// 5. 客户端使用（极简）
public class Client {
    public static void main(String[] args) {
        Order order = new Order();
        order.setPaymentStrategy("alipay"); // 只需指定类型
        System.out.println(order.pay(100)); // 输出：支付宝支付100元
    }
}
```

#### 适用场景

- 支付方式、排序算法、日志存储方式等 “多策略可选” 的场景；
- 希望客户端无需感知具体策略类，仅通过 “类型标识” 使用策略。

### 二、建造者模式 + 原型模式

#### 组合原因

- 建造者模式的痛点：复杂对象的分步构建仍需执行初始化逻辑（如赋值多个属性），批量创建时效率低；
- 原型模式补充：先通过建造者创建一个 “原型对象”，后续批量创建时直接克隆原型，避免重复执行构建步骤。

#### 实现思路

1. 建造者层：构建复杂对象的原型（如高配电脑）；
2. 原型层：让产品类实现`Cloneable`，支持克隆；
3. 客户端：先 build 原型，再 clone 生成多个实例。

#### 代码示例（电脑创建）





```
// 1. 产品类（实现原型模式）
public class Computer implements Cloneable {
    private String cpu;
    private int memory;
    private int hardDisk;

    // 私有构造，通过建造者创建
    private Computer(Builder builder) {
        this.cpu = builder.cpu;
        this.memory = builder.memory;
        this.hardDisk = builder.hardDisk;
    }

    // 原型模式：克隆方法
    @Override
    protected Computer clone() throws CloneNotSupportedException {
        return (Computer) super.clone();
    }

    // 建造者模式
    public static class Builder {
        private String cpu;
        private int memory;
        private int hardDisk;

        public Builder cpu(String cpu) {
            this.cpu = cpu;
            return this;
        }

        public Builder memory(int memory) {
            this.memory = memory;
            return this;
        }

        public Builder hardDisk(int hardDisk) {
            this.hardDisk = hardDisk;
            return this;
        }

        public Computer build() {
            return new Computer(this);
        }
    }

    @Override
    public String toString() {
        return "Computer{" + "cpu='" + cpu + '\'' + ", memory=" + memory + ", hardDisk=" + hardDisk + '}';
    }
}

// 2. 客户端使用
public class Client {
    public static void main(String[] args) throws CloneNotSupportedException {
        // 1. 建造者创建原型（仅执行一次复杂构建）
        Computer prototype = new Computer.Builder()
                .cpu("i9")
                .memory(64)
                .hardDisk(2000)
                .build();

        // 2. 原型克隆批量创建（高效）
        Computer c1 = prototype.clone();
        Computer c2 = prototype.clone();
        System.out.println(c1); // 与原型一致，创建效率高
    }
}
```

#### 适用场景

- 需要批量创建相同 / 相似的复杂对象（如游戏角色、配置对象）；
- 复杂对象的构建成本高（如多属性赋值、依赖外部资源）。

### 三、装饰者模式 + 工厂模式

#### 组合原因

- 装饰者模式的痛点：多层装饰嵌套时（如`new MilkDecorator(new SugarDecorator(coffee))`），客户端代码冗长且易出错；
- 工厂模式补充：封装装饰者的组合逻辑，客户端只需指定 “基础对象 + 装饰类型”，工厂自动完成嵌套装饰。

#### 实现思路

1. 组件层：抽象组件 + 具体组件（如咖啡）；
2. 装饰层：抽象装饰者 + 具体装饰者（如牛奶、糖）；
3. 工厂层：创建装饰工厂，根据装饰类型组合装饰者；
4. 客户端：仅需指定咖啡类型和装饰列表，无需手动嵌套。

#### 代码示例（咖啡场景）




```
// 1. 抽象组件
public interface Coffee {
    double cost();
    String getDesc();
}

// 2. 具体组件
public class Americano implements Coffee {
    @Override
    public double cost() {
        return 10;
    }

    @Override
    public String getDesc() {
        return "美式咖啡";
    }
}

// 3. 抽象装饰者
public abstract class CoffeeDecorator implements Coffee {
    protected Coffee coffee;

    public CoffeeDecorator(Coffee coffee) {
        this.coffee = coffee;
    }
}

// 4. 具体装饰者
public class MilkDecorator extends CoffeeDecorator {
    public MilkDecorator(Coffee coffee) {
        super(coffee);
    }

    @Override
    public double cost() {
        return coffee.cost() + 2;
    }

    @Override
    public String getDesc() {
        return coffee.getDesc() + "+牛奶";
    }
}

public class SugarDecorator extends CoffeeDecorator {
    public SugarDecorator(Coffee coffee) {
        super(coffee);
    }

    @Override
    public double cost() {
        return coffee.cost() + 1;
    }

    @Override
    public String getDesc() {
        return coffee.getDesc() + "+糖";
    }
}

// 5. 装饰工厂（核心）
public class CoffeeFactory {
    // 创建咖啡并添加装饰
    public static Coffee createCoffee(String coffeeType, List<String> decorators) {
        // 1. 创建基础咖啡
        Coffee coffee = switch (coffeeType) {
            case "americano" -> new Americano();
            default -> throw new IllegalArgumentException("不支持的咖啡类型");
        };

        // 2. 批量添加装饰
        for (String decorator : decorators) {
            coffee = switch (decorator) {
                case "milk" -> new MilkDecorator(coffee);
                case "sugar" -> new SugarDecorator(coffee);
                default -> coffee;
            };
        }
        return coffee;
    }
}

// 6. 客户端使用
public class Client {
    public static void main(String[] args) {
        // 只需指定咖啡类型+装饰列表，无需手动嵌套
        Coffee coffee = CoffeeFactory.createCoffee("americano", List.of("milk", "sugar"));
        System.out.println(coffee.getDesc()); // 美式咖啡+牛奶+糖
        System.out.println(coffee.cost());    // 13
    }
}
```

#### 适用场景

- 需要灵活组合多个装饰者的场景（如咖啡配料、IO 流包装、权限叠加）；
- 装饰者嵌套层级多，希望简化客户端调用。

### 四、外观模式 + 模板方法模式

#### 组合原因

- 外观模式的痛点：封装复杂子系统时，子系统内部的流程可能重复（如不同导出方式的 “校验 - 保存” 流程）；
- 模板方法补充：子系统的流程用模板方法固定，外观类只需调用模板方法，既简化客户端，又保证子系统流程统一。

#### 实现思路

1. 模板层：抽象模板定义子系统流程（如导出流程），具体模板实现可变步骤；
2. 外观层：封装模板对象的调用，提供统一入口；
3. 客户端：仅调用外观类，无需关注模板和子系统。

#### 代码示例（报表导出）










```
// 1. 抽象模板（模板方法）
public abstract class ReportExporter {
    // 固定流程
    public final String export(Object[][] data) {
        validate(data);
        Object assembled = assemble(data);
        generate(assembled);
        save();
        return "导出成功";
    }

    private void validate(Object[][] data) {
        System.out.println("校验数据");
    }

    private void save() {
        System.out.println("保存文件");
    }

    protected abstract Object assemble(Object[][] data);
    protected abstract void generate(Object data);
}

// 2. 具体模板
public class ExcelExporter extends ReportExporter {
    @Override
    protected Object assemble(Object[][] data) {
        System.out.println("组装Excel数据");
        return "ExcelData";
    }

    @Override
    protected void generate(Object data) {
        System.out.println("生成Excel文件");
    }
}

public class PdfExporter extends ReportExporter {
    @Override
    protected Object assemble(Object[][] data) {
        System.out.println("组装PDF数据");
        return "PDFData";
    }

    @Override
    protected void generate(Object data) {
        System.out.println("生成PDF文件");
    }
}

// 3. 外观类（外观模式）
public class ReportFacade {
    // 统一导出入口
    public String exportReport(String type, Object[][] data) {
        ReportExporter exporter = switch (type) {
            case "excel" -> new ExcelExporter();
            case "pdf" -> new PdfExporter();
            default -> throw new IllegalArgumentException("不支持的类型");
        };
        return exporter.export(data);
    }
}

// 4. 客户端使用
public class Client {
    public static void main(String[] args) {
        ReportFacade facade = new ReportFacade();
        Object[][] data = {{"日期", "销售额"}, {"2026", "1000"}};
        // 仅调用外观类，无需关注模板和流程
        System.out.println(facade.exportReport("excel", data));
    }
}
```

#### 适用场景

- 复杂子系统有固定流程（如导出、审批、下单），且需要统一对外接口；
- 希望客户端完全隔离子系统的复杂度，仅通过简单接口使用。

### 五、观察者模式 + 状态模式

#### 组合原因

- 状态模式的痛点：状态切换时，若需要通知多个外部模块（如订单状态变更需通知物流、财务、用户），硬编码通知会增加耦合；
- 观察者模式补充：将状态变更作为 “被观察者事件”，外部模块作为观察者，状态切换时自动通知，解耦状态与通知逻辑。

#### 实现思路

1. 观察者层：抽象观察者 + 具体观察者（如物流、财务）；
2. 状态层：抽象状态 + 具体状态（订单状态），状态切换时触发通知；
3. 环境层：订单类（被观察者）维护观察者列表，状态切换时通知；
4. 客户端：注册观察者，触发状态变更。

#### 代码示例（订单场景）






```
// 1. 抽象观察者
public interface OrderObserver {
    void onStateChange(String orderId, String state);
}

// 2. 具体观察者
public class LogisticsObserver implements OrderObserver {
    @Override
    public void onStateChange(String orderId, String state) {
        System.out.println("物流模块：订单" + orderId + "状态变为" + state);
    }
}

public class FinanceObserver implements OrderObserver {
    @Override
    public void onStateChange(String orderId, String state) {
        System.out.println("财务模块：订单" + orderId + "状态变为" + state);
    }
}

// 3. 抽象状态
public abstract class OrderState {
    protected Order order;

    public void setOrder(Order order) {
        this.order = order;
    }

    public abstract void pay();
}

// 4. 具体状态
public class WaitPayState extends OrderState {
    @Override
    public void pay() {
        System.out.println("订单支付成功");
        order.setState(new PaidState());
        // 状态切换后通知观察者
        order.notifyObservers("已支付");
    }
}

public class PaidState extends OrderState {
    @Override
    public void pay() {
        System.out.println("订单已支付");
    }
}

// 5. 环境类（被观察者）
public class Order {
    private String orderId;
    private OrderState state;
    private List<OrderObserver> observers = new ArrayList<>();

    public Order(String orderId) {
        this.orderId = orderId;
        this.state = new WaitPayState();
        this.state.setOrder(this);
    }

    public void setState(OrderState state) {
        this.state = state;
        this.state.setOrder(this);
    }

    public void pay() {
        state.pay();
    }

    // 观察者模式：注册观察者
    public void addObserver(OrderObserver observer) {
        observers.add(observer);
    }

    // 通知观察者
    public void notifyObservers(String newState) {
        for (OrderObserver observer : observers) {
            observer.onStateChange(orderId, newState);
        }
    }
}

// 6. 客户端使用
public class Client {
    public static void main(String[] args) {
        Order order = new Order("ORD123");
        // 注册观察者
        order.addObserver(new LogisticsObserver());
        order.addObserver(new FinanceObserver());
        // 触发状态变更，自动通知观察者
        order.pay();
    }
}
```

#### 适用场景

- 状态变更需要通知多个外部模块（如订单、电梯、工单系统）；
- 希望状态切换的通知逻辑与状态本身解耦，便于扩展观察者。

### 六、其他高频组合速览




|        组合模式         |                      核心价值                      |           适用场景           |
| :---------------------: | :------------------------------------------------: | :--------------------------: |
|   原型模式 + 单例模式   |     单例对象初始化成本高，先克隆原型再保证单例     |     配置中心、连接池单例     |
|  适配器模式 + 外观模式  |    适配多个第三方接口后，通过外观类提供统一入口    | 集成多个支付渠道、第三方 SDK |
|   策略模式 + 模板方法   | 模板方法固定流程，策略模式替换流程中的某个算法步骤 |   流程固定但某步骤算法可选   |
| 建造者模式 + 装饰者模式 |       建造者构建基础对象，装饰者动态添加功能       |   复杂对象 + 动态扩展功能    |

### 总结

1. 组合核心原则 ：

    - 互补短板：用 A 模式解决 B 模式的痛点（如工厂解决策略的创建复杂度）；
    - 分层解耦：不同模式负责不同维度（如模板方法管流程，外观模式管入口）；
    - 最小侵入：组合后不增加客户端复杂度，反而简化使用。



2. 选型技巧 ：

    - 先确定核心问题（如 “对象创建”“功能扩展”“行为协调”），选核心模式；
    - 再看核心模式的痛点，用另一模式补充（如核心用策略→痛点是创建复杂→加工厂）；



3. 避坑点 ：

    - 避免过度组合：仅当单一模式无法满足需求时才组合，否则增加复杂度；
    - 优先经典组合（如工厂 + 策略、外观 + 模板方法），这些是行业通用实践。



这些组合场景覆盖了 80% 以上的实际开发需求，你可以根据业务场景的核心问题（如 “要简化策略选择” 就用工厂 + 策略，“要解耦状态通知” 就用状态 + 观察者）直接套用。