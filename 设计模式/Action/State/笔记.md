### 一、为什么需要状态模式？

先看痛点场景：

- 你开发一个订单系统，订单有 “待支付、已支付、已发货、已完成、已取消”5 种状态，不同状态下能执行的操作不同：

    - 待支付：可支付、可取消；
    - 已支付：可发货、可退款；
    - 已发货：可确认收货；
    - 已完成 / 已取消：无操作；



- 若用`if/else`实现：每个操作方法（如`pay()`、`cancel()`）中都要判断当前状态，代码会臃肿且难以维护（新增状态时需修改所有判断逻辑）。

状态模式的解决思路：将每个订单状态封装为独立的`State`类（如`WaitPayState`、`PaidState`），订单对象持有当前状态对象，调用操作时直接委托给状态类，无需判断。

### 二、状态模式的核心结构

状态模式包含 4 个核心角色：

1. **环境类（Context）**：持有当前状态对象，提供状态切换接口，委托状态对象处理具体行为（如`Order`）；
2. **抽象状态（State）**：定义所有状态的通用行为接口（如`pay()`、`cancel()`、`ship()`）；
3. **具体状态（Concrete State）**：实现抽象状态接口，处理该状态下的具体行为，并负责状态切换；
4. **客户端（Client）**：通过环境类调用状态行为，无需关注具体状态类。

### 三、完整代码实现（订单状态场景）

#### 1. 抽象状态（State）









```
// 订单状态抽象类：定义所有状态的行为接口
public abstract class OrderState {
    // 持有环境类引用（用于状态切换）
    protected Order order;

    public void setOrder(Order order) {
        this.order = order;
    }

    // 支付操作
    public abstract void pay();

    // 取消订单
    public abstract void cancel();

    // 发货操作
    public abstract void ship();

    // 确认收货
    public abstract void confirm();

    // 获取当前状态名称
    public abstract String getStateName();
}
```

#### 2. 具体状态（Concrete State）




```
// 具体状态1：待支付
public class WaitPayState extends OrderState {
    @Override
    public void pay() {
        System.out.println("订单支付成功，状态从【待支付】切换为【已支付】");
        // 状态切换：更新订单的当前状态
        order.setState(new PaidState());
    }

    @Override
    public void cancel() {
        System.out.println("订单取消成功，状态从【待支付】切换为【已取消】");
        order.setState(new CanceledState());
    }

    @Override
    public void ship() {
        System.out.println("待支付订单无法发货");
    }

    @Override
    public void confirm() {
        System.out.println("待支付订单无法确认收货");
    }

    @Override
    public String getStateName() {
        return "待支付";
    }
}

// 具体状态2：已支付
public class PaidState extends OrderState {
    @Override
    public void pay() {
        System.out.println("订单已支付，无需重复支付");
    }

    @Override
    public void cancel() {
        System.out.println("已支付订单取消失败（需先退款）");
    }

    @Override
    public void ship() {
        System.out.println("订单发货成功，状态从【已支付】切换为【已发货】");
        order.setState(new ShippedState());
    }

    @Override
    public void confirm() {
        System.out.println("已支付订单未发货，无法确认收货");
    }

    @Override
    public String getStateName() {
        return "已支付";
    }
}

// 具体状态3：已发货
public class ShippedState extends OrderState {
    @Override
    public void pay() {
        System.out.println("已发货订单无需支付");
    }

    @Override
    public void cancel() {
        System.out.println("已发货订单无法取消");
    }

    @Override
    public void ship() {
        System.out.println("订单已发货，无需重复发货");
    }

    @Override
    public void confirm() {
        System.out.println("订单确认收货成功，状态从【已发货】切换为【已完成】");
        order.setState(new CompletedState());
    }

    @Override
    public String getStateName() {
        return "已发货";
    }
}

// 具体状态4：已完成
public class CompletedState extends OrderState {
    @Override
    public void pay() {
        System.out.println("已完成订单无需支付");
    }

    @Override
    public void cancel() {
        System.out.println("已完成订单无法取消");
    }

    @Override
    public void ship() {
        System.out.println("已完成订单无需发货");
    }

    @Override
    public void confirm() {
        System.out.println("订单已完成，无需重复确认");
    }

    @Override
    public String getStateName() {
        return "已完成";
    }
}

// 具体状态5：已取消
public class CanceledState extends OrderState {
    @Override
    public void pay() {
        System.out.println("已取消订单无法支付");
    }

    @Override
    public void cancel() {
        System.out.println("订单已取消，无需重复取消");
    }

    @Override
    public void ship() {
        System.out.println("已取消订单无法发货");
    }

    @Override
    public void confirm() {
        System.out.println("已取消订单无法确认收货");
    }

    @Override
    public String getStateName() {
        return "已取消";
    }
}
```

#### 3. 环境类（Context）






```
// 订单环境类：持有当前状态，委托状态处理行为
public class Order {
    private String orderId;
    // 当前状态（初始为待支付）
    private OrderState state;

    public Order(String orderId) {
        this.orderId = orderId;
        this.state = new WaitPayState();
        // 将当前订单对象传递给状态类（用于状态切换）
        this.state.setOrder(this);
    }

    // 状态切换：更新当前状态，并绑定订单对象
    public void setState(OrderState newState) {
        this.state = newState;
        this.state.setOrder(this);
    }

    // 委托给状态类处理：支付
    public void pay() {
        state.pay();
    }

    // 委托给状态类处理：取消
    public void cancel() {
        state.cancel();
    }

    // 委托给状态类处理：发货
    public void ship() {
        state.ship();
    }

    // 委托给状态类处理：确认收货
    public void confirm() {
        state.confirm();
    }

    // 获取当前状态信息
    public void showState() {
        System.out.println("订单[" + orderId + "]当前状态：" + state.getStateName());
    }
}
```

#### 4. 客户端使用示例








```
public class StatePatternDemo {
    public static void main(String[] args) {
        // 1. 创建订单（初始状态：待支付）
        Order order = new Order("ORD123456");
        order.showState(); // 输出：订单[ORD123456]当前状态：待支付

        // 2. 执行支付操作（状态切换为已支付）
        order.pay();
        order.showState(); // 输出：订单[ORD123456]当前状态：已支付

        // 3. 尝试取消（已支付状态无法取消）
        order.cancel();

        // 4. 执行发货操作（状态切换为已发货）
        order.ship();
        order.showState(); // 输出：订单[ORD123456]当前状态：已发货

        // 5. 执行确认收货（状态切换为已完成）
        order.confirm();
        order.showState(); // 输出：订单[ORD123456]当前状态：已完成

        // 6. 已完成状态下尝试发货（无操作）
        order.ship();
    }
}
```

**输出结果**：












```
订单[ORD123456]当前状态：待支付
订单支付成功，状态从【待支付】切换为【已支付】
订单[ORD123456]当前状态：已支付
已支付订单取消失败（需先退款）
订单发货成功，状态从【已支付】切换为【已发货】
订单[ORD123456]当前状态：已发货
订单确认收货成功，状态从【已发货】切换为【已完成】
订单[ORD123456]当前状态：已完成
已完成订单无需发货
```

### 四、状态模式 vs 策略模式（易混淆的区别）

两者结构相似（都封装行为到独立类），但核心目标完全不同：








|       维度       |                   状态模式                   |                     策略模式                      |
| :--------------: | :------------------------------------------: | :-----------------------------------------------: |
|     核心目标     | 处理**状态驱动**的行为变化（行为由状态决定） | 处理**算法 / 策略**的灵活替换（行为由客户端选择） |
| 状态 / 策略切换  | 由状态类内部自动切换（如支付后自动切已支付） |    由客户端手动切换（如选择支付宝 / 微信支付）    |
| 行为与上下文关系 |    状态类持有上下文引用，可修改上下文状态    |          策略类无上下文引用，仅执行算法           |
|     适用场景     |     对象有明确的状态流转（如订单、电梯）     |         多种算法可选（如排序、支付方式）          |

### 五、状态模式的核心特点

#### 优点：

1. **消除冗余判断**：替代大量`if/else`/`switch`，代码更清晰、易维护；
2. **状态行为封装**：每个状态的行为集中在对应状态类中，符合 “单一职责原则”；
3. **易扩展**：新增状态只需添加新的状态类，无需修改原有代码（符合 “开闭原则”）；
4. **状态切换清晰**：状态切换逻辑由状态类自身控制，流转规则更明确。

#### 缺点：

1. **类数量增加**：每个状态对应一个类，状态多的时候会导致类爆炸（如 10 种状态需 10 个状态类）；
2. **状态依赖**：状态类持有环境类引用，可能增加耦合（需谨慎设计）；
3. **流转复杂度**：若状态流转规则复杂（如多条件切换），状态类之间的依赖会变复杂。

### 总结

1. **核心思想**：状态模式将对象的状态和对应行为解耦，让状态变化驱动行为变化，核心是 “状态封装、行为委托”；

2. 适用场景 ：

    - 对象行为依赖于状态，且状态有明确的流转规则；
    - 代码中存在大量与状态相关的`if/else`/`switch`，难以维护；
    - 需要动态切换对象状态，且不同状态下行为不同；



3. 实现关键 ：

    - 环境类持有当前状态对象，所有行为委托给状态类执行；
    - 状态类持有环境类引用，负责状态的自动切换；
    - 抽象状态定义所有可能的行为，具体状态实现自身支持的行为，不支持的行为给出提示；



4. 优化建议 ：

    - 状态数量过多时，可结合享元模式复用状态对象（避免创建大量相同状态实例）；
    - 复杂状态流转可引入 “状态管理器” 统一管理切换规则。