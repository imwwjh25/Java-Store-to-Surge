### 14. int 和 double 的区别 + 存储范围

#### 一、核心区别（从本质到使用场景）

| 对比维度         | int（整型）                            | double（双精度浮点型）                                       |
| ---------------- | -------------------------------------- | ------------------------------------------------------------ |
| 数据类型         | 整数类型（无小数部分）                 | 浮点类型（支持整数 + 小数，或极大 / 极小值）                 |
| 存储本质         | 二进制补码直接存储整数（无精度损失）   | 按 **IEEE 754 标准** 存储（符号位 + 指数位 + 尾数位），存在精度误差 |
| 占用字节（标准） | 4 字节（32 位）                        | 8 字节（64 位）                                              |
| 精度特性         | 绝对精确（存储范围内的整数无误差）     | 相对精度（小数 / 大数可能丢失精度，如 0.1 无法精确存储）     |
| 适用场景         | 计数、索引、无小数的数值（如年龄、ID） | 科学计算、工程测量、需要小数的场景（如身高、重量、浮点数运算） |
| 运算速度         | 更快（整数运算硬件支持更直接）         | 较慢（浮点运算需额外解析指数和尾数）                         |

#### 二、存储范围（基于标准 32 位 int 和 64 位 double）

##### 1. int 的存储范围

- 存储方式：32 位二进制补码（1 位符号位 + 31 位数值位）
- 范围计算：
  - 负数范围：-2³¹ （符号位 1，数值位全 0）
  - 正数范围：2³¹ - 1 （符号位 0，数值位全 1，因 0 占一个位置）
- 具体数值：**-2147483648 ~ 2147483647**（约 ±21 亿）

> 补充：如果是 64 位 int（long long），范围是 -9223372036854775808 ~ 9223372036854775807（约 ±9e18），但通常说的 int 默认是 32 位。

##### 2. double 的存储范围

- 存储方式：64 位 IEEE 754 标准（1 位符号位 + 11 位指数位 + 52 位尾数位）
- 范围计算：
  - 指数位取值范围：0 ~ 2047（排除全 0 和全 1 的特殊情况，有效指数范围为 -1022 ~ +1023）
  - 数值范围：±(2^-1022) ~ ±(2^1023 × (1 + (2^52 - 1)/2^52))
- 具体数值（近似）：
  - 最小值（绝对值最小）：约 ±2.225×10⁻³⁰⁸（能表示的最小非零数）
  - 最大值（绝对值最大）：约 ±1.798×10³⁰⁸（能表示的最大数）

> 关键：double 的范围远大于 int，但**精度有限**（52 位尾数位对应约 15~17 位十进制有效数字），超过有效数字的部分会被截断或四舍五入。

### 15. 浮点型的存储方式 + 数值表示（以 IEEE 754 标准为例）

浮点型（float 单精度、double 双精度）的核心是**用 “科学计数法” 的二进制形式存储**，通过 “符号位 + 指数位 + 尾数位” 拆分表示，既兼顾大范围，又节省存储空间。

#### 一、存储结构（以 double 为例，64 位）

| 位段        | 长度（位数） | 作用                                                         |
| ----------- | ------------ | ------------------------------------------------------------ |
| 符号位（S） | 1            | 0 表示正数，1 表示负数（仅控制符号，不影响数值大小）         |
| 指数位（E） | 11           | 存储指数的 “偏移值”（避免存储负数指数），偏移量 = 2^(11-1) - 1 = 1023 |
| 尾数位（M） | 52           | 存储二进制小数的 “有效数字”（隐含整数部分为 1，节省 1 位存储空间） |

> 补充：float 是 32 位（S=1，E=8，偏移量 = 127，M=23），精度和范围均小于 double。

#### 二、数值表示规则（核心：二进制科学计数法）

任意非零浮点数可表示为：`数值 = (-1)^S × (1.M) × 2^(E - 偏移量)`

逐部分拆解：

1. **符号位（S）**：控制正负，简单直接（(-1)^S 要么是 1，要么是 -1）。

2. 指数位（E）：

   - 实际指数 = 存储的 E 值 - 偏移量（double 偏移量 1023，float 127）。
   - 示例：double 中 E 存储 1024 → 实际指数 = 1024 - 1023 = 1；E 存储 1022 → 实际指数 = -1。
   - 特殊情况：E 全 0 表示 “非规格化数”（处理接近 0 的小数），E 全 1 表示无穷大或 NaN（非数字）。

3. 尾数位（M）：

   - 隐含整数部分 “1”，因此 M 存储的是 “小数部分”（如 M=010...0 → 1.M = 1.01₂）。
   - 为什么隐含 1？因为二进制科学计数法的整数部分只能是 1（如 101.101₂ = 1.01101₂ × 2²），无需额外存储，节省 1 位空间提升精度。
   - 示例：M=000...0（全 0）→ 1.M = 1.0₂；M=111...1（全 1）→ 1.M = 1.111...1₂（52 个 1）。

#### 三、实际示例（double 表示 0.5）

步骤 1：将 0.5 转为二进制科学计数法0.5₁₀ = 0.1₂ = 1.0₂ × 2^(-1)

步骤 2：拆分三部分

- 符号位 S=0（正数）；
- 实际指数 = -1 → 存储的 E = 实际指数 + 偏移量 = -1 + 1023 = 1022（二进制：01111111110）；
- 尾数位 M = 0（因 1.M = 1.0₂，小数部分为 0，52 位全 0）。

步骤 3：最终 64 位存储（简化）S (1) + E (11) + M (52) → 0 01111111110 000...000（共 64 位）。

#### 四、关键结论

1. 浮点型的 “范围” 由**指数位长度**决定（指数越大，能表示的数越大）；
2. 浮点型的 “精度” 由**尾数位长度**决定（尾数越长，有效数字越多，精度越高）；
3. 精度误差根源：尾数位是有限的（double 52 位 → 约 15~17 位十进制有效数字），无法精确表示所有小数（如 0.1₁₀ = 0.0001100110011...₂ 无限循环，会被截断）。
