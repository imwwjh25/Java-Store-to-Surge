Redis 的内存模型核心是「分层存储 + 高效数据结构 + 内存管理机制」，本质是将用户数据（键值对）通过特定数据结构存储在内存中，同时通过内存分配、回收、淘汰策略优化内存使用效率。下面从「内存结构分层」「核心数据结构的内存布局」「内存管理机制」三个核心维度，把 Redis 内存模型讲透：

## 一、先明确：Redis 内存的整体构成（分层视角）

Redis 的内存并非只存储用户的键值对，而是由「用户数据 + 元数据 + 系统开销」三部分组成，整体结构如下（按占比从高到低）：

| 内存分层            | 核心内容                                                     | 占比 / 作用                           |
| ------------------- | ------------------------------------------------------------ | ------------------------------------- |
| 1. 用户数据（核心） | 键（key）+ 值（value），值的类型包括 String、Hash、List、Set、ZSet 等 | 占比 80%-90%，是 Redis 内存的核心用途 |
| 2. 元数据（辅助）   | - 键的元数据：过期时间、类型、编码方式、引用计数；- 数据库元数据：字典（db->dict）、过期键字典（db->expires） | 占比 5%-10%，支撑数据的管理和查询     |
| 3. 系统开销（基础） | - 内存分配器开销：如 jemalloc 的内存块头部、对齐填充；- 进程运行开销：线程栈、文件描述符、共享库等 | 占比 1%-5%，是 Redis 运行的基础开销   |

### 关键说明：

- 用户数据是优化核心：Redis 所有数据结构设计（如 ziplist、intset）的核心目标是「压缩用户数据的内存占用」；
- 元数据不可忽视：大量短键场景下（如键是 1-2 字节），元数据占比可能超过 20%，需通过 `hash-max-ziplist-entries` 等配置优化。

## 二、核心：用户数据的内存布局（按数据类型拆解）

用户数据的内存占用由「键（key）」和「值（value）」两部分决定，键固定是「字符串（SDS）」，值则根据类型和编码方式有不同的内存布局，核心是「小数据用紧凑结构（省内存），大数据用高效结构（提性能）」。

### 1. 键（key）的内存布局：简单动态字符串（SDS）

Redis 中的键和字符串类型的值，底层都用「SDS（Simple Dynamic String）」存储，而非 C 语言原生字符串（char []）。SDS 结构如下（3.2+ 版本，按字符串长度自适应）：





```c
// 短字符串（len < 2^8）
struct __attribute__ ((__packed__)) sdshdr8 {
    uint8_t len;    // 已使用字节数（不包含末尾 \0）
    uint8_t alloc;  // 总分配字节数（不包含头部和 \0）
    unsigned char flags; // 类型标记（8/16/32/64 位）
    char buf[];     // 字符串数据（末尾自动加 \0，兼容 C 函数）
};
```

- 内存占用 = 头部（len + alloc + flags） + buf 长度 + 1（\0 结束符）；
- 优势：
    1. 预分配空间：修改字符串时提前扩容（避免频繁分配内存）；
    2. 惰性释放：字符串缩短时，不立即回收内存（后续可复用）；
    3. 记录长度：获取字符串长度是 O (1)（C 语言是 O (n)）。

示例：存储键 `key1`（3 字节），SDS 头部占 3 字节（len=3，alloc=3，flags=0x08），buf 占 4 字节（"key1"+"\0"），总内存 = 3+4=7 字节。

### 2. 值（value）的内存布局：按类型 + 编码分类

Redis 为每种值类型提供多种编码方式（通过 `object encoding 键` 查看），核心是「空间 - 时间权衡」，以下是常用类型的内存布局：

#### （1）字符串（String）：SDS + 整数优化

- 编码方式：
    - `int`：值是 64 位以内的整数（如 `123`），直接存储为整数（占 8 字节），无需 SDS 头部；
    - `embstr`：短字符串（默认长度 < 44 字节），SDS 头部和数据连续存储（减少内存碎片）；
    - `raw`：长字符串（长度 ≥44 字节），SDS 头部和数据分开存储（适配大字符串扩容）。
- 内存对比：存储 `123`（int 编码）占 8 字节，存储 "abc"（embstr 编码）占 3（头部）+3（数据）+1（\0）=7 字节，存储长字符串（raw 编码）占头部 + 数据 + \0。

#### （2）哈希（Hash）：ziplist + dict

- 编码方式：
    - `ziplist`（压缩列表）：元素数 < 512 且键值对长度 <64 字节时使用，是连续内存的紧凑结构，无指针开销；
    - `dict`（字典）：超过阈值时切换，结构同前文「Redis Hash 实现」，内存占用 = 字典结构 + 哈希桶 + 键值对 SDS。
- 内存优势：ziplist 存储 100 个短键值对，内存占用仅为 dict 的 1/5 左右（无哈希桶和指针开销）。

#### （3）列表（List）：ziplist + linkedlist

- 编码方式：
    - `ziplist`：元素数 < 512 且元素长度 <64 字节时使用，紧凑存储；
    - `linkedlist`：超过阈值时切换为双向链表，每个节点存储 SDS + 前后指针（每个节点占 32 字节左右，内存开销大）。
- Redis 3.2+ 优化：用 `quicklist` 替代 linkedlist，是「ziplist 片段 + 链表」的混合结构（兼顾紧凑性和灵活性）。

#### （4）集合（Set）：intset + dict

- 编码方式：
    - `intset`（整数集合）：所有元素是整数且元素数 <512 时使用，连续内存存储（无指针开销）；
    - `dict`：存在非整数元素或元素数超标时使用，字典的 value 为 NULL（仅用键存储集合元素）。
- 内存对比：存储 100 个整数（1-100），intset 占 4（头部）+100*4（int 元素）=404 字节，dict 占至少 100*32（哈希桶 + 节点）=3200 字节。

#### （5）有序集合（ZSet）：ziplist + skiplist

- 编码方式：
    - `ziplist`：元素数 < 128 且元素长度 <64 字节时使用，按分数排序，紧凑存储；
    - `skiplist`（跳表）+ dict：超过阈值时切换，跳表存储元素（分数 + 值）支持快速排序和范围查询，dict 存储「值→分数」的映射支持 O (1) 查找。
- 内存特点：跳表的内存开销主要来自索引（每层指针），但查询效率高（O (log n)）。

## 三、Redis 的内存管理机制（分配、回收、淘汰）

Redis 不仅优化数据存储，还通过「内存分配器」「内存回收」「内存淘汰」三大机制，确保内存高效利用。

### 1. 内存分配：依赖第三方分配器（jemalloc/tcmalloc）

Redis 不直接调用系统 `malloc/free`，而是使用 jemalloc（默认）或 tcmalloc，核心优势是「减少内存碎片 + 高效分配不同大小的内存块」：

- 内存块分类：jemalloc 将内存分为小（<8KB）、中（8KB-64KB）、大（>64KB）三类，每类有固定大小的内存块（如 8B、16B、32B），分配时匹配最接近的块；
- 减少碎片：避免频繁分配 / 释放不同大小的内存块导致的碎片（系统 malloc 容易产生碎片）；
- 适配 Redis 场景：大量小内存块（如短键、ziplist 元素）的分配效率极高。

### 2. 内存回收：惰性回收 + 主动回收

Redis 是「内存数据库」，但不会立即回收无用内存，而是采用「惰性 + 主动」结合的策略：

- 惰性回收：当键过期、被删除（`DEL`）或被覆盖时，Redis 不会立即释放内存给系统，而是标记为「空闲内存」，后续分配新内存时优先复用；
- 主动回收：当空闲内存达到 `maxmemory` 阈值，或内存碎片率过高时，Redis 会主动整理内存（如合并空闲块），并释放部分内存给系统；
- 注意：Redis 不会主动释放所有空闲内存（避免频繁系统调用），因此 `used_memory` 可能高于实际用户数据占用。

### 3. 内存淘汰：maxmemory 策略（避免 OOM）

当 Redis 内存达到 `maxmemory`（默认无限制，生产环境需配置），会触发内存淘汰策略，选择部分键删除以释放内存：

- 常用策略：
    - `volatile-lru`：删除过期键中最近最少使用的键（推荐，兼顾过期和热点）；
    - `allkeys-lru`：删除所有键中最近最少使用的键（适用于无过期键的场景）；
    - `volatile-ttl`：删除过期键中剩余生存时间最短的键；
- 淘汰流程：Redis 维护一个「LRU 池」（默认 16 个元素），每次随机选取部分键放入池，淘汰池中最久未使用的键（避免遍历所有键，提升效率）。

### 4. 过期键回收：惰性删除 + 定期删除

过期键的回收不依赖内存淘汰，而是单独的策略：

- 惰性删除：访问键时才检查是否过期，过期则删除（不浪费 CPU，可能浪费内存）；
- 定期删除：每隔 100ms 随机抽取部分过期键检查，删除已过期的（平衡 CPU 和内存）；
- 配合内存淘汰：若过期键未被访问且未被定期删除，会占用内存，此时 `volatile-lru` 策略会优先淘汰它们。

## 四、内存优化的核心思路（基于内存模型）

理解 Redis 内存模型后，优化内存的思路就很明确：

1. 用紧凑编码：尽量让值满足 ziplist、intset 的阈值（如 Hash 元素数 <512，字符串用整数存储）；
2. 避免短键冗余：用 Hash 存储同类短键（如将 `user:1:name`、`user:1:age` 改为 `user:1` 的 Hash 键值对），减少键的元数据开销；
3. 配置合理的 maxmemory：根据物理内存设置（如 8GB 内存设为 6GB），避免 OOM；
4. 选择合适的淘汰策略：根据业务场景选择（如缓存场景用 `volatile-lru`）；
5. 控制内存碎片：避免频繁存储 / 删除大键（容易产生碎片），定期执行 `MEMORY PURGE` 整理碎片。

## 核心总结

Redis 内存模型的本质是「分层存储 + 紧凑编码 + 高效管理」：

1. 内存构成：用户数据（核心）+ 元数据 + 系统开销；
2. 数据存储：键用 SDS，值按类型选择紧凑编码（ziplist/intset）或高效编码（dict/skiplist）；
3. 内存管理：依赖 jemalloc 分配内存，通过惰性 + 主动回收复用内存，通过淘汰策略控制内存上限。

简单说：Redis 对内存的优化做到了「极致的空间利用」和「高效的访问性能」平衡，这也是它能支撑海量数据的核心原因。