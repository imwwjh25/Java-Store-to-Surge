# 死锁（Deadlock）详解：原理、排查、解决与实战

死锁是多线程 / 多进程并发编程中最棘手的问题之一，指 **两个或多个线程（进程）互相持有对方所需的资源，且都无法释放自己的资源，导致所有线程（进程）永久阻塞** 的状态。一旦发生死锁，程序会卡住无法继续执行，只能通过重启等方式恢复。

## 一、死锁的核心原理（4 个必要条件）

死锁的发生必须同时满足以下 **4 个必要条件**（缺一不可），这是理解死锁的基础：

1. **互斥条件**：资源只能被一个线程（进程）独占使用（如一把锁只能被一个线程持有）；
2. **持有并等待条件**：线程持有一个资源后，又去申请其他资源，且在等待新资源时不释放已持有的资源；
3. **不可剥夺条件**：线程已持有的资源不能被其他线程强制剥夺（只能由持有者主动释放）；
4. **循环等待条件**：多个线程形成闭环，每个线程都在等待下一个线程持有的资源（如 A 等 B 的资源，B 等 C 的资源，C 等 A 的资源）。

### 经典示例（Java 死锁代码）






```java
public class DeadlockDemo {
    // 定义两个互斥资源（锁）
    private static final Object LOCK_A = new Object();
    private static final Object LOCK_B = new Object();

    public static void main(String[] args) {
        // 线程1：持有 LOCK_A，等待 LOCK_B
        new Thread(() -> {
            synchronized (LOCK_A) {
                System.out.println("线程1：持有 LOCK_A，等待 LOCK_B");
                try { Thread.sleep(100); } catch (InterruptedException e) {} // 让线程2有时间持有 LOCK_B
                synchronized (LOCK_B) {
                    System.out.println("线程1：获取 LOCK_B，执行完成");
                }
            }
        }, "线程1").start();

        // 线程2：持有 LOCK_B，等待 LOCK_A
        new Thread(() -> {
            synchronized (LOCK_B) {
                System.out.println("线程2：持有 LOCK_B，等待 LOCK_A");
                try { Thread.sleep(100); } catch (InterruptedException e) {} // 让线程1有时间持有 LOCK_A
                synchronized (LOCK_B) { // 此处应为 LOCK_A，模拟循环等待
                    System.out.println("线程2：获取 LOCK_A，执行完成");
                }
            }
        }, "线程2").start();
    }
}
```

**执行结果**：两个线程互相等待对方的锁，永久阻塞，控制台输出如下：






```plaintext
线程1：持有 LOCK_A，等待 LOCK_B
线程2：持有 LOCK_B，等待 LOCK_A
```

## 二、是否遇到过死锁？实际场景案例

### 1. 个人遇到的死锁场景（生产环境）

#### 场景：订单支付流程中的死锁

- 背景

  ：电商系统中，订单支付完成后，需要同时更新 “订单表” 和 “库存表”，两个线程并发处理不同订单的支付：

    - 线程 A：先锁订单 1（`orderId=1`），再锁库存 100（`productId=100`）；
    - 线程 B：先锁库存 100（`productId=100`），再锁订单 1（`orderId=1`）；

- **触发条件**：线程 A 持有订单 1 的锁，等待库存 100 的锁；线程 B 持有库存 100 的锁，等待订单 1 的锁，形成循环等待；

- **现象**：应用日志卡住，订单支付状态一直处于 “处理中”，数据库连接池耗尽（线程阻塞未释放连接）。

#### 其他常见死锁场景

- **数据库层面**：两个事务并发更新多张表，更新顺序不一致（如事务 1：更新表 A → 表 B；事务 2：更新表 B → 表 A）；
- **分布式场景**：分布式锁使用不当（如多个服务同时申请多个不同的分布式锁，申请顺序不一致）；
- **线程池 + 锁**：线程池中的线程持有锁后，等待其他线程的结果，而其他线程又在等待该线程的锁（如线程池任务依赖循环）。

## 三、死锁的排查方法（从易到难）

当程序出现 “卡住不响应、资源耗尽、日志无进展” 等现象时，需怀疑死锁，以下是常用排查手段：

### 1. JVM 自带工具（Java 程序首选）

#### （1）jps + jstack（最常用）

- 步骤 1：用```jps```查看 Java 进程 ID（如```1234```）；












  ```bash
  jps -l # 输出：1234 com.example.DeadlockDemo
  ```



- 步骤 2：用```jstack```分析进程的线程栈，自动检测死锁；











  ```bash
  jstack 1234
  ```



- 关键输出（jstack 会明确标记死锁线程和持有的锁）：










  ```plaintext
  Found one Java-level deadlock:
  =============================
  "线程2":
    waiting to lock monitor 0x00007f8c00001000 (object 0x000000076b6e0008, a java.lang.Object),
    which is held by "线程1"
  "线程1":
    waiting to lock monitor 0x00007f8c00002000 (object 0x000000076b6e0018, a java.lang.Object),
    which is held by "线程2"
  
  Java stack information for the threads listed above:
  ===================================================
  "线程2":
    at com.example.DeadlockDemo.lambda$main$1(DeadlockDemo.java:25)
    - waiting to lock <0x000000076b6e0008> (a java.lang.Object)
    - locked <0x000000076b6e0018> (a java.lang.Object)
  "线程1":
    at com.example.DeadlockDemo.lambda$main$0(DeadlockDemo.java:15)
    - waiting to lock <0x000000076b6e0018> (a java.lang.Object)
    - locked <0x000000076b6e0008> (a java.lang.Object)
  ```



#### （2）jconsole（图形化工具）

- 步骤 1：运行 `jconsole`，选择目标进程连接；
- 步骤 2：切换到 “线程” 标签页，点击 “检测死锁”，工具会自动识别死锁线程并展示详细信息（锁对象、调用栈）。

### 2. 数据库死锁排查（MySQL 为例）

- 查看数据库死锁日志：




  ```sql
  SHOW ENGINE INNODB STATUS; -- 输出中包含死锁详情（事务、SQL、锁类型）
  ```



- 开启死锁监控（MySQL 配置文件）：






  ```ini
  innodb_print_all_deadlocks = 1 -- 所有死锁都会记录到 error.log 中
  ```



### 3. 分布式死锁排查

- 查看分布式锁中间件日志（如 Redis、ZooKeeper），确认锁的申请 / 释放顺序；
- 结合链路追踪工具（如 SkyWalking、Zipkin），分析多个服务的调用顺序和锁申请时机；
- 检查服务间的依赖关系，是否存在循环依赖 + 锁竞争。

## 四、死锁的解决方法（从预防到修复）

解决死锁的核心思路是 **破坏死锁的 4 个必要条件之一**，优先选择 “低成本、无副作用” 的方案：

### 1. 预防死锁（最推荐，从源头避免）

#### （1）破坏 “循环等待条件”：统一资源申请顺序

这是最常用、最有效的预防手段 —— 所有线程（进程）申请多个资源时，按固定的顺序申请（如按资源 ID 升序、按表名字典序）。

**示例修复（订单支付场景）**：

- 原逻辑：线程 A 锁订单 → 锁库存；线程 B 锁库存 → 锁订单（顺序不一致）；

- 修复后：统一按 “资源 ID 升序” 申请（订单 ID < 库存 ID 时，先锁订单；否则先锁库存）；







  ```java
  // 资源 ID 比较，固定申请顺序
  if (orderId < productId) {
      synchronized (LOCK_ORDER) { // 先锁订单
          synchronized (LOCK_STOCK) { // 再锁库存
              // 业务逻辑
          }
      }
  } else {
      synchronized (LOCK_STOCK) { // 先锁库存
          synchronized (LOCK_ORDER) { // 再锁订单
              // 业务逻辑
          }
      }
  }
  ```



#### （2）破坏 “持有并等待条件”：一次性申请所有资源

线程在执行前，一次性申请所需的所有资源，申请成功后再执行；若有任何资源未申请到，則释放已申请的资源，重新等待。

**示例（Java 实现）**：







```java
// 一次性申请 LOCK_A 和 LOCK_B，失败则重试
private boolean acquireAllLocks() {
    synchronized (LOCK_A) {
        synchronized (LOCK_B) {
            // 检查是否都申请成功（此处简化，实际需结合锁的状态）
            return true;
        }
    }
}

// 业务线程
new Thread(() -> {
    while (!acquireAllLocks()) {
        try { Thread.sleep(10); } catch (InterruptedException e) {} // 重试间隔
    }
    // 执行业务逻辑
}).start();
```

#### （3）破坏 “不可剥夺条件”：允许资源抢占

为锁添加 “超时机制”，线程申请资源时若超时未获取到，则主动释放已持有的资源，避免永久等待。

**示例（Java 可重入锁 + 超时）**：









```java
private static final ReentrantLock LOCK_A = new ReentrantLock();
private static final ReentrantLock LOCK_B = new ReentrantLock();

new Thread(() -> {
    boolean acquiredA = false;
    boolean acquiredB = false;
    try {
        // 申请 LOCK_A，超时 1 秒
        acquiredA = LOCK_A.tryLock(1, TimeUnit.SECONDS);
        if (acquiredA) {
            // 申请 LOCK_B，超时 1 秒
            acquiredB = LOCK_B.tryLock(1, TimeUnit.SECONDS);
            if (acquiredB) {
                System.out.println("线程1：获取所有锁，执行完成");
            } else {
                System.out.println("线程1：获取 LOCK_B 超时，释放 LOCK_A");
            }
        } else {
            System.out.println("线程1：获取 LOCK_A 超时");
        }
    } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
    } finally {
        // 释放已持有的锁
        if (acquiredB) LOCK_B.unlock();
        if (acquiredA) LOCK_A.unlock();
    }
}).start();
```

#### （4）破坏 “互斥条件”：使用共享资源（减少锁竞争）

若资源无需独占使用（如只读数据），则改为共享资源（如使用 `ReadWriteLock`，读锁可共享，写锁独占），减少锁竞争的概率。

**示例（读写锁优化）**：






```java
private static final ReadWriteLock rwLock = new ReentrantReadWriteLock();
private static final Lock readLock = rwLock.readLock(); // 读锁共享
private static final Lock writeLock = rwLock.writeLock(); // 写锁独占

// 读操作（可并发）
public void readData() {
    readLock.lock();
    try {
        // 读取数据
    } finally {
        readLock.unlock();
    }
}

// 写操作（独占）
public void writeData() {
    writeLock.lock();
    try {
        // 修改数据
    } finally {
        writeLock.unlock();
    }
}
```

### 2. 避免死锁（动态检测，规避风险）

通过算法（如银行家算法）动态检测资源申请是否会导致死锁，若会则拒绝申请。但银行家算法实现复杂，适合资源固定、场景简单的系统（如操作系统内核），日常开发中很少使用。

### 3. 解除死锁（死锁发生后的修复）

若死锁已发生，需强制解除：

- **线程层面**：中断死锁线程（如 `Thread.interrupt()`），释放资源；或设置线程守护线程（Daemon），主线程退出时自动销毁；
- **数据库层面**：杀死死锁的事务（`KILL TRANSACTION ID`），MySQL 会自动回滚死锁事务；
- **分布式层面**：强制释放分布式锁（如 Redis 过期时间、ZooKeeper 临时节点），或重启相关服务。

## 五、死锁的日常开发规范（避坑指南）

1. **减少锁的粒度**：避免使用全局锁（如 `synchronized (this)`），尽量使用局部锁（如锁具体的资源对象）；
2. **缩短锁的持有时间**：锁内只执行核心业务逻辑，避免 IO 操作（如数据库查询、网络请求）和长时间计算；
3. **避免嵌套锁**：尽量减少锁的嵌套层级（如锁 A 中套锁 B，锁 B 中套锁 C），降低循环等待的概率；
4. **使用安全的锁工具**：优先使用 `ReentrantLock`（支持超时、可中断），而非 `synchronized`（不支持超时，难以中断）；
5. **监控锁竞争**：通过 JVM 监控工具（如 VisualVM）查看锁的竞争情况（如 `lock contention`），提前优化高竞争锁；
6. **数据库层面**：更新多张表时，统一 SQL 执行顺序；使用 `SELECT ... FOR UPDATE` 时，明确锁的范围（避免表锁）。

## 六、核心总结

1. **死锁本质**：多线程 / 进程的资源竞争 + 不当的申请顺序，导致循环等待；
2. **排查关键**：Java 程序用 `jstack`，数据库用 `SHOW ENGINE INNODB STATUS`，分布式用中间件日志 + 链路追踪；
3. **解决优先级**：预防（统一资源顺序 > 超时机制）> 避免（算法检测）> 解除（强制释放）；
4. **实战建议**：日常开发中，优先通过 “统一资源申请顺序” 和 “锁超时” 预防死锁，这两种方案低成本、无副作用，能覆盖 90% 以上的场景。

死锁的核心是 “预防大于修复”，只要在设计阶段规范锁的使用，就能大幅降低死锁的发生概率。