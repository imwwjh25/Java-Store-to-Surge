###  kill 命令终止进程的底层实现原理？

`kill` 命令本质是**向进程发送信号（Signal）**，内核根据信号类型触发进程终止逻辑，步骤如下：

#### （1）命令执行流程

1. 用户执行 `kill [信号] [PID]`（如 `kill -9 1234`），shell 调用`kill()`系统调用；
2. 内核根据 PID 找到目标进程的`task_struct`（进程控制块）；
3. 内核将信号加入进程的「未决信号集」，并唤醒进程（若进程休眠）；
4. 进程从内核态返回用户态时，检查未决信号集，执行信号处理逻辑。

#### （2）不同信号的终止逻辑

- **SIGTERM（15，默认）**：友好终止，进程可捕获信号，执行清理逻辑（如保存数据、关闭文件）后退出；

- SIGKILL（9） ：强制终止，进程无法捕获 / 忽略，内核直接销毁进程：

    - 释放进程占用的资源（内存、文件描述符、信号量）；
    - 更新进程状态为`ZOMBIE`，通知父进程（通过 SIGCHLD）；
    - 父进程调用`wait()`回收子进程资源，否则成为僵尸进程。

#### （3）底层核心

- 信号由内核统一管理，`kill` 仅触发信号发送，不直接终止进程；
- 进程终止的核心是内核释放`task_struct`及关联资源，更新进程表。


### 14. 进程管理 进程终止的底层交互（信号机制）？

进程终止的核心是「**内核 - 进程 - 父进程**」的信号交互，步骤如下：

#### （1）触发终止信号

- 主动终止：进程调用`exit()`，内核发送 SIGCHLD 给父进程；
- 被动终止：`kill`/`pkill`发送 SIGTERM/SIGKILL，内核将信号加入进程未决信号集。

#### （2）进程处理信号

- 若为 SIGTERM（可捕获）：进程执行清理逻辑（关闭文件、释放内存、刷新缓冲区），调用`_exit()`；
- 若为 SIGKILL（不可捕获）：内核直接终止进程，跳过清理。

#### （3）内核回收进程资源

- 内核释放进程的虚拟内存、文件描述符、信号量、网络连接等；
- 进程状态变为`TASK_ZOMBIE`（僵尸进程），保留 PID 和退出状态。

#### （4）父进程回收僵尸进程

- 内核向父进程发送 SIGCHLD 信号，通知子进程终止；
- 父进程调用`wait()`/`waitpid()`，读取子进程退出状态，内核释放僵尸进程的 PID 和`task_struct`；
- 若父进程未处理，僵尸进程会一直存在，直至父进程退出（由 init 进程（PID=1）接管并回收）。