
总的来说，**一个对象被序列化后，其状态会被完整地记录下来；当它被反序列化时，JVM 会创建一个新的对象，并将记录的状态恢复到这个新对象中。** 这个过程看似是 “复制”，但其间会发生一些微妙而重要的变化。

### 一、核心变化：对象的 “重生”



1. **创建新对象**：反序列化**不会调用类的构造函数**。JVM 会直接在堆上分配内存，创建一个全新的对象，然后将从字节流中读取的数据填充到这个对象中。
2. **`transient`字段被忽略**：被`transient`关键字修饰的字段在序列化时不会被写入字节流。因此，在反序列化出的新对象中，这些字段会被赋予其类型的**默认值**（例如，`null` for 对象，`0` for `int`，`false` for `boolean`等）。

**示例：**

```
import java.io.*;

class User implements Serializable {
    private static final long serialVersionUID = 1L;
    private String name;
    private transient String password; // 这个字段不会被序列化

    public User(String name, String password) {
        this.name = name;
        this.password = password;
        System.out.println("Constructor called");
    }

    @Override
    public String toString() {
        return "User{name='" + name + "', password='" + password + "'}";
    }
}

public class SerializationDemo {
    public static void main(String[] args) throws IOException, ClassNotFoundException {
        // 序列化
        User originalUser = new User("Alice", "secret123");
        System.out.println("Original: " + originalUser); // 输出: Original: User{name='Alice', password='secret123'}

        try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("user.ser"))) {
            oos.writeObject(originalUser);
        }

        // 反序列化
        try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream("user.ser"))) {
            User deserializedUser = (User) ois.readObject();
            // 注意：反序列化过程中没有打印 "Constructor called"
            System.out.println("Deserialized: " + deserializedUser); // 输出: Deserialized: User{name='Alice', password='null'}
        }
    }
}
```



**输出结果分析：**

- `originalUser` 的 `password` 是 `"secret123"`。
- `deserializedUser` 的 `password` 是 `null`，因为它被 `transient` 修饰，没有被序列化。
- 反序列化时，`User`类的构造函数没有被调用。

### 二、引用关系的变化



1. **深拷贝特性**：序列化会递归地序列化对象的所有引用对象，直到遇到`transient`或不可序列化的对象。因此，反序列化后得到的是一个**深拷贝**（Deep Copy）。原始对象和新对象之间，以及它们引用的对象之间，都没有内存上的关联。
2. **同一对象的多次引用**：如果一个对象在序列化流中被多次引用，反序列化后，这些引用会指向同一个新创建的对象，从而保持了对象图的完整性。

### 三、静态字段的特殊性



- **静态字段不会被序列化**：静态字段属于类，而不是对象。序列化保存的是对象的**实例状态**，因此静态字段的值不会被写入字节流。
- **反序列化后的静态字段值**：反序列化出的对象，其静态字段的值取决于**当前 JVM 中该类的静态字段值**，而不是序列化时的值。

**示例：**


```
class Counter implements Serializable {
    private static final long serialVersionUID = 1L;
    public static int count = 0; // 静态字段
    private int id;

    public Counter() {
        id = ++count;
    }

    @Override
    public String toString() {
        return "Counter{id=" + id + "}";
    }
}

public class StaticSerializationDemo {
    public static void main(String[] args) throws IOException, ClassNotFoundException {
        Counter c1 = new Counter();
        System.out.println("After creating c1: " + c1 + ", count=" + Counter.count); // After creating c1: Counter{id=1}, count=1

        // 序列化 c1
        try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("counter.ser"))) {
            oos.writeObject(c1);
        }
        
        Counter.count = 100; // 修改静态字段的值

        // 反序列化
        try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream("counter.ser"))) {
            Counter c2 = (Counter) ois.readObject();
            System.out.println("Deserialized c2: " + c2 + ", count=" + Counter.count); // Deserialized c2: Counter{id=1}, count=100
        }
    }
}
```



**输出结果分析：**

- `c1` 的 `id` 是 `1`，序列化时 `count` 是 `1`。
- 在反序列化前，我们将 `Counter.count` 修改为了 `100`。
- 反序列化出的 `c2`，其 `id` 仍然是序列化时保存的 `1`，但它读取到的静态字段 `count` 的值是当前 JVM 中的 `100`。

### 四、通过自定义序列化逻辑改变对象



你可以通过实现 `writeObject` 和 `readObject` 方法来完全控制序列化和反序列化的过程，从而在这个过程中改变对象的状态。

**示例：在反序列化时修改字段值**


```
class UserWithCustomLogic implements Serializable {
    private static final long serialVersionUID = 1L;
    private String name;
    private String password;

    public UserWithCustomLogic(String name, String password) {
        this.name = name;
        this.password = password;
    }
    
    // 自定义反序列化逻辑
    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
        in.defaultReadObject(); // 先执行默认的反序列化
        // 在反序列化后，将密码字段置为"[REDACTED]"
        this.password = "[REDACTED]"; 
    }

    @Override
    public String toString() {
        return "User{name='" + name + "', password='" + password + "'}";
    }
}
```



在这个例子中，反序列化出的 `UserWithCustomLogic` 对象，其 `password` 字段将总是 `"[REDACTED]"`，无论序列化时它是什么值。

### 五、类结构不兼容导致的变化（或失败）



如果在序列化和反序列化之间，类的结构发生了不兼容的改变（例如，删除了一个字段、改变了字段的类型），并且没有正确处理 `serialVersionUID`，那么反序列化会失败并抛出 `InvalidClassException`。

- **如果显式声明了 `serialVersionUID`**：只要版本号不变，即使类结构有小的、兼容的变化（如增加字段），反序列化仍可能成功。新增的字段会被赋予默认值。
- **如果没有显式声明 `serialVersionUID`**：Java 会根据类的结构自动计算一个值。类结构的任何改变都会导致计算出的 `serialVersionUID` 不同，从而导致反序列化失败。

### 总结：序列化 / 反序列化过程中的关键变化



1. **对象实例**：创建一个全新的对象，不调用构造函数。
2. **`transient` 字段**：值丢失，被重置为类型默认值。
3. **静态字段**：值不被序列化，反序列化后的值为当前 JVM 中类的静态值。
4. **对象引用**：保持对象图的完整性，是深拷贝。
5. **自定义逻辑**：可以在 `writeObject` / `readObject` 中注入代码，主动改变对象状态。
6. **类兼容性**：类结构变化可能导致反序列化失败，`serialVersionUID` 是版本兼容性的关键。