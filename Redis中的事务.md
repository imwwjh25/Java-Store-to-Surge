Redis 有事务，但和 MySQL 等关系型数据库的事务 **完全不同**——Redis 事务是「弱事务」，核心作用是「将多个命令打包执行，保证执行过程中不被其他命令插入」，但不支持关系型数据库的「原子性（全部成功或全部失败）」「回滚」等强特性。

如果面试时不懂，建议先明确「Redis 有事务，但和 MySQL 事务不一样」，再按「是什么、怎么用、核心特性（和 MySQL 对比）、适用场景」的逻辑说，既诚实又有条理，下面帮你拆解清楚：

### 一、Redis 事务到底是什么？

Redis 事务的本质是「命令批量执行的容器」，核心目标是 **“一次性、顺序性、排他性”** 执行多个命令：

- 一次性：把多个命令打包，一次发送给 Redis 执行；
- 顺序性：事务中的命令按提交顺序依次执行，中间不会被其他客户端的命令打断；
- 排他性：执行事务期间，其他命令需等待事务执行完才能执行（但 Redis 是单线程，本身就不会并发执行命令，这里的排他性是指 “命令块不被拆分”）。

简单说：Redis 事务就是 “把多个命令捆在一起，让它们连续执行，不被插队”，但不保证 “要么全成，要么全败”。

### 二、Redis 事务怎么用？（3 个核心命令）

Redis 事务通过 `MULTI`（开启事务）、`EXEC`（执行事务）、`DISCARD`（取消事务）三个命令操作，流程非常简单：

#### 1. 基本用法（正常执行）


```bash
127.0.0.1:6379> MULTI  # 开启事务（标记事务开始）
OK
127.0.0.1:6379> SET key1 value1  # 命令1：加入事务队列（未执行）
QUEUED
127.0.0.1:6379> SET key2 value2  # 命令2：加入事务队列（未执行）
QUEUED
127.0.0.1:6379> GET key1  # 命令3：加入事务队列（未执行）
QUEUED
127.0.0.1:6379> EXEC  # 执行事务（一次性执行队列中所有命令）
1) OK
2) OK
3) "value1"
```

- 过程：`MULTI` 后，所有命令不会立即执行，而是返回 `QUEUED` 表示 “加入队列”；只有执行 `EXEC`，才会批量执行所有队列中的命令。

#### 2. 取消事务（DISCARD）

```bash
127.0.0.1:6379> MULTI
OK
127.0.0.1:6379> SET key3 value3
QUEUED
127.0.0.1:6379> DISCARD  # 取消事务，队列中的命令全部丢弃
OK
127.0.0.1:6379> GET key3  # 无结果，命令未执行
(nil)
```

#### 3. 错误处理（关键：不会回滚！）

这是 Redis 事务和 MySQL 事务的核心区别，分两种情况：

- 情况 1：

  命令语法错误

  （如命令写错）—— 事务中只要有一个命令语法错误，```EXEC ```会直接拒绝执行整个事务，所有命令都不执行：

  ```bash
  127.0.0.1:6379> MULTI
  OK
  127.0.0.1:6379> SET key4 value4
  QUEUED
  127.0.0.1:6379> SETERROR key5 value5  # 语法错误（命令不存在）
  (error) ERR unknown command `SETERROR`, with args beginning with: `key5`, `value5`, 
  127.0.0.1:6379> EXEC  # 整个事务被拒绝
  (error) EXECABORT Transaction discarded because of previous errors.
  ```

  

- 情况 2：

  命令逻辑错误

  （如给字符串做自增）—— 语法没问题，但执行时出错，Redis 会继续执行后续命令，出错的命令仅自身失败，不会回滚其他命令：


  ```bash
  127.0.0.1:6379> SET key6 "abc"  # 先设一个字符串
  OK
  127.0.0.1:6379> MULTI
  OK
  127.0.0.1:6379> INCR key6  # 逻辑错误（字符串不能自增）
  QUEUED
  127.0.0.1:6379> SET key7 value7  # 正常命令
  QUEUED
  127.0.0.1:6379> EXEC  # 执行事务：出错的命令失败，其他命令成功
  1) (error) ERR value is not an integer or out of range  # 第一个命令失败
  2) OK  # 第二个命令成功
  127.0.0.1:6379> GET key7  # 能拿到结果
  "value7"
  ```

  

**关键结论**：Redis 事务 **不支持回滚**—— 只有语法错误会导致整个事务不执行，逻辑错误只会让出错命令失败，其他命令照常执行，已执行的命令无法撤销。

### 三、Redis 事务 vs MySQL 事务（对比着说更清晰）

面试时如果被追问，用表格对比能快速讲清差异：

| 特性     | Redis 事务                                       | MySQL 事务（InnoDB）                         |
| -------- | ------------------------------------------------ | -------------------------------------------- |
| 原子性   | 弱原子性（仅语法错误全不执行，逻辑错误部分执行） | 强原子性（要么全成，要么全回滚）             |
| 一致性   | 依赖业务逻辑（无回滚，需手动处理错误）           | 由 ACID 保证（事务执行后数据一致）           |
| 隔离性   | 天然隔离（单线程，事务执行时无并发插入）         | 支持 4 种隔离级别（解决脏读 / 不可重复读等） |
| 持久性   | 依赖 Redis 持久化（RDB/AOF）                     | 由事务日志（redo/undo log）保证              |
| 回滚机制 | 无（不支持 ROLLBACK 命令）                       | 支持（ROLLBACK 撤销已执行操作）              |
| 核心用途 | 批量执行命令，避免插队                           | 保证数据操作的可靠性（如转账）               |

### 四、Redis 事务的补充：乐观锁（WATCH 命令）

Redis 事务没有悲观锁（如 MySQL 的 `FOR UPDATE`），但提供了 `WATCH` 命令实现「乐观锁」，用于解决 “并发修改冲突”：

#### 1. 作用

`WATCH` 可以监视一个或多个 key，在事务执行前（`EXEC` 前），如果被监视的 key 被其他客户端修改了，那么当前事务会被取消执行（返回 `(nil)`），避免覆盖其他客户端的修改。

#### 2. 用法示例（模拟并发修改）



```bash
# 客户端A：
127.0.0.1:6379> SET balance 100  # 初始余额100
OK
127.0.0.1:6379> WATCH balance  # 监视 balance
OK
127.0.0.1:6379> MULTI  # 开启事务
OK
127.0.0.1:6379> DECRBY balance 30  # 扣30（预期余额70）
QUEUED

# 此时客户端B修改 balance：
127.0.0.1:6379> SET balance 200  # 客户端B把余额改成200
OK

# 客户端A执行事务：
127.0.0.1:6379> EXEC  # 因为 balance 被修改，事务取消
(nil)
127.0.0.1:6379> GET balance  # 余额是客户端B修改后的200，避免了覆盖
"200"
```

#### 3. 核心逻辑

- 乐观锁思想：假设不会发生并发冲突，只在事务执行前检查是否有冲突；
- 适用场景：并发修改较少的场景（如秒杀库存、余额更新）；
- 注意：如果事务被取消，需要重新执行「WATCH + 事务」流程（重试机制）。

### 五、Redis 事务的适用场景

1. 批量执行命令（如一次性设置多个 key-value，避免多次网络往返）；
2. 避免命令插队（如先删缓存再更数据库，需要这两个命令连续执行，不被其他命令打断）；
3. 简单的并发控制（结合 `WATCH` 解决少量并发修改冲突）。

**不适用场景**：

- 需要强原子性 / 回滚的场景（如转账、支付等核心业务）；
- 复杂的并发冲突场景（乐观锁仅能解决简单冲突，复杂场景需用分布式锁）。

### 面试总结（直接背）

“Redis 有事务，但和 MySQL 事务不一样，是弱事务：

1. 核心用法是 `MULTI` 开启事务、`EXEC` 执行事务、`DISCARD` 取消事务，作用是把多个命令打包，连续执行不被其他命令插队；
2. 关键特点是不支持回滚 —— 只有命令语法错会导致整个事务不执行，逻辑错只会让出错命令失败，其他命令照常执行；
3. 它没有强原子性，隔离性是天然的（单线程），持久性依赖 Redis 自身的 RDB/AOF 持久化；
4. 还可以用 `WATCH` 命令实现乐观锁，解决简单的并发修改冲突；
5. 主要用于批量执行命令或避免命令插队，不适合需要强一致性的场景（如转账），那些场景更适合用 MySQL 事务。”

这样说既覆盖了核心知识点，又诚实说明了 “和 MySQL 事务的差异”，即使一开始不懂，也能清晰传达你的理解。
