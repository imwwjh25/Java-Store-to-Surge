### 场景题 1：余额与积分服务的分布式事务一致性保障



余额和积分服务属于跨服务操作（如用户支付后扣减余额、增加积分），需保证**原子性**（要么都成功，要么都失败），核心方案基于分布式事务模式，按复杂度和性能排序如下：

#### 1. 最终一致性方案（主流推荐）



适合对实时一致性要求不高的场景，通过 “补偿机制” 实现最终一致：

- 方案 1：本地消息表 + 消息队列
    1. **扣减余额**：在余额服务的本地事务中，先扣减余额，再插入 “积分增加任务” 到本地消息表（状态为 “待处理”）；
    2. **消息投递**：通过定时任务扫描本地消息表，将 “待处理” 任务投递到 MQ（如 RocketMQ）；
    3. **积分增加**：积分服务消费 MQ 消息，增加积分后发送 “确认消息”；
    4. **状态更新**：余额服务收到确认消息，将本地消息表状态改为 “已完成”；
    5. **补偿重试**：若积分服务处理失败，MQ 消息重试（设置最大重试次数），仍失败则人工介入。
- 方案 2：事务消息（RocketMQ / 阿里云 ONS）
    1. 余额服务发送 “半事务消息” 到 MQ（此时积分服务无法消费）；
    2. 执行本地扣减余额事务，若成功则通知 MQ 提交消息，积分服务消费并增加积分；若失败则通知 MQ 回滚消息；
    3. 若 MQ 长时间未收到提交 / 回滚通知，会反向查询余额服务的事务状态，确保消息最终一致。
- 方案 3：SAGA 模式
    1. **编排式 SAGA**：由协调器（如 Seata）调用余额服务的 “扣减余额”（正向操作）和积分服务的 “增加积分”（正向操作）；
    2. **补偿逻辑**：若积分服务失败，协调器调用余额服务的 “恢复余额”（反向操作），保证回滚；
    3. 优点：支持长事务，适合多服务串联场景；缺点：需编写正向 / 反向接口，开发成本高。

#### 2. 强一致性方案（性能较低，慎用）



适合对实时一致性要求极高的场景：

- 方案 1：2PC（两阶段提交）
    1. **准备阶段**：协调器向余额服务、积分服务发送 “准备请求”，两服务执行操作（扣减余额、增加积分）但不提交事务，返回 “就绪”；
    2. **提交阶段**：若所有服务就绪，协调器发送 “提交请求”，两服务提交事务；若任一服务失败，发送 “回滚请求”；
    3. 缺点：性能差（阻塞等待）、协调器单点故障风险、脑裂问题（部分服务提交失败）。
- 方案 2：TCC（Try-Confirm-Cancel）
    1. **Try 阶段**：余额服务冻结用户余额（预留扣减额度），积分服务预留积分（确保可增加）；
    2. **Confirm 阶段**：若 Try 成功，执行实际扣减余额、增加积分；
    3. **Cancel 阶段**：若 Try 失败，解冻余额、释放积分预留；
    4. 优点：无锁阻塞，性能优于 2PC；缺点：需改造业务接口（拆分 Try/Confirm/Cancel），开发成本高。

#### 方案选择建议



- 互联网场景优先选**本地消息表 + MQ**或**事务消息**（最终一致性，性能高）；
- 金融核心场景可考虑**TCC**（强一致性，兼顾性能）；
- 避免使用 2PC（性能瓶颈明显）。