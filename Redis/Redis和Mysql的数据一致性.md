Redis 和 MySQL 保证数据一致性的核心挑战是 **“缓存（Redis）与数据库（MySQL）的双写同步”**—— 既要避免 “缓存有脏数据”“缓存与数据库数据不一致”，又要平衡性能（不能因同步拖慢读写）。其核心原则是：**以 MySQL 为 “数据权威源”，Redis 仅作为缓存（加速查询），所有数据变更最终落地到 MySQL，再通过合理的同步策略更新 Redis**。

### 一、先明确：数据一致性的目标

我们要保证的是 **“最终一致性”**（绝大多数场景够用），而非 “强一致性”（强一致性会牺牲性能，Redis 作为缓存的价值会大打折扣）：

- 最终一致性：短时间内缓存与数据库可能不一致，但经过同步策略修正后，最终会保持一致；
- 强一致性：任何时刻，缓存与数据库的数据都完全相同（仅适用于金融交易等极端场景，需额外代价）。

### 二、核心同步策略：按 “读写场景” 选择

数据一致性问题本质是 “读 / 写操作如何同步 Redis 和 MySQL”，不同场景（读多写少、写多读少）对应不同策略，核心分为「写操作同步」和「读操作兜底」两部分。

#### （一）写操作：数据变更的核心同步逻辑

写操作（新增 / 修改 / 删除）必须先操作 MySQL，再同步 Redis（避免先改缓存导致的数据不一致），主流有 3 种策略：

##### 1. 策略一：Cache-Aside（旁路缓存）—— 最常用、性价比最高

核心逻辑：**读走缓存，写走数据库，写后更新 / 删除缓存**（不直接写缓存）。

- 写操作步骤（以 “更新数据” 为例）：

    1. 先执行 MySQL 的更新操作（`UPDATE`），确保数据落地数据库；
    2. 再执行 Redis 的删除操作（`DEL key`），而非直接更新 Redis（避免 “缓存更新成功但数据库更新失败” 的脏数据）；

    - （删除而非更新的原因：若直接更新 Redis，可能出现 “数据库更新失败，但 Redis 已改” 的不一致；删除后，下次读会重新从数据库加载最新数据到缓存）

- 读操作步骤：

    1. 先查 Redis，若存在（缓存命中），直接返回；
    2. 若 Redis 不存在（缓存未命中），查 MySQL，获取最新数据；
    3. 将 MySQL 结果写入 Redis（缓存预热），再返回给客户端。

- 适用场景：读多写少（如商品详情、用户信息），是互联网最常用的策略；

- 优点：简单易懂、性能好（写操作仅多一步 Redis 删除，开销小）；

- 风险与解决：

    - 风险 1：并发写导致的短暂不一致（如两个线程同时更新，线程 1 删缓存后，线程 2 先查数据库写缓存，线程 1 再写数据库）；



    解决：给缓存加 “过期时间”（兜底），或对写操作加分布式锁（确保串行执行，适用于写冲突频繁场景）；

- 风险 2：缓存删除失败（如 Redis 宕机），导致缓存存旧数据；



    解决：缓存必须设置过期时间（强制失效），结合定期全量同步兜底。

##### 2. 策略二：Write-Through（写透）—— 强一致性优先，性能略低

核心逻辑：**写操作同时更新数据库和缓存，两者都成功才算完成**（缓存与数据库强绑定）。

- 写操作步骤：
    1. 先更新 Redis 缓存；
    2. Redis 内部同步更新 MySQL 数据库（或客户端先更 MySQL 再更 Redis，需保证原子性）；
    3. 两者都返回成功，才给客户端确认。
- 读操作步骤：仅查 Redis（缓存必然是最新的，未命中则查 MySQL 并写入缓存）。
- 适用场景：对一致性要求极高、写操作不频繁的场景（如金融核心数据）；
- 优点：强一致性（缓存与数据库实时同步），读操作无需兜底；
- 缺点：写性能差（需同时操作两个存储，耗时翻倍），Redis 故障会阻塞写操作；
- 注意：需保证 “双写原子性”（可用事务 / 分布式事务，或 Redis 事务 + MySQL 事务），否则一方失败会导致不一致。

##### 3. 策略三：Write-Behind（写回）—— 高性能优先，一致性较弱

核心逻辑：**写操作只更新 Redis，Redis 异步批量同步到 MySQL**（类似操作系统的 “页缓存写回”）。

- 写操作步骤：
    1. 仅更新 Redis 缓存（同步返回成功）；
    2. Redis 后台异步（或定时）将变更批量同步到 MySQL；
- 读操作步骤：同 Cache-Aside（优先查缓存）。
- 适用场景：写操作极频繁、对一致性要求不高的场景（如实时统计计数、临时缓存）；
- 优点：写性能极高（仅操作内存），支持批量同步提升效率；
- 缺点：数据丢失风险（Redis 宕机后，未同步到 MySQL 的数据会丢失），存在较长时间的不一致；
- 注意：需开启 Redis 持久化（RDB+AOF），并定期检查同步状态，降低丢失风险。

#### （二）读操作：兜底策略（解决缓存未命中 / 脏数据）

无论哪种写策略，读操作都需要 “兜底逻辑”，避免因缓存问题返回旧数据：

1. 缓存未命中：必须查 MySQL，并将结果写入 Redis（缓存预热）；
2. 缓存命中但数据过期：先删除过期缓存，再查 MySQL 并重新写入缓存；
3. 缓存穿透防护：对 “不存在的 key”（如恶意查询 `id=-1`），在 Redis 中缓存一个空值（设置短期过期时间），避免频繁查 MySQL；
4. 缓存击穿防护：对 “热点 key”（如秒杀商品），在缓存过期前主动预热，或加分布式锁（避免并发查 MySQL 导致数据库压力飙升）。

### 三、关键问题：如何解决 “并发读写导致的不一致”

Cache-Aside 策略中，最容易出现 “并发读写冲突”，例如：

- 线程 1（更新）：删除 Redis → 准备更新 MySQL（未完成）；
- 线程 2（查询）：Redis 未命中 → 查 MySQL（拿到旧数据）→ 写入 Redis；
- 结果：线程 1 最终更新了 MySQL，但 Redis 中是线程 2 写入的旧数据，导致不一致。

解决方案：

1. 方案一：写操作加分布式锁（如 Redis 分布式锁）—— 确保同一时间只有一个线程更新数据，避免并发冲突；
2. 方案二：缓存设置 “随机过期时间”—— 避免大量热点 key 同时过期，减少并发查询 MySQL 的场景；
3. 方案三：延迟删除缓存 —— 写操作更新 MySQL 后，不立即删除 Redis，而是延迟 1~3 秒删除（给并发读操作留时间），可用 Redis 过期键通知或消息队列实现；
4. 方案四：版本号机制 —— 给每条数据加版本号（存在 MySQL 和 Redis 中），读操作时对比版本号，若 Redis 版本低于 MySQL，则重新加载数据。

### 四、进阶保障：持久化与同步兜底

即使做好了读写同步，仍需通过 “持久化 + 定期同步” 确保极端场景下的数据一致性：

1. MySQL 层面：
    - 开启主从复制（一主多从），避免 MySQL 单点故障；
    - 重要数据开启事务（ACID），确保写入原子性；
2. Redis 层面：
    - 开启持久化：RDB（定时快照）+ AOF（日志追加），确保 Redis 宕机后能恢复数据；
    - 避免缓存无限期存活：所有缓存 key 必须设置过期时间（即使是热点数据，也可设置较长过期时间 + 主动刷新）；
3. 定期全量同步：
    - 每天凌晨（低峰期）执行全量同步任务：从 MySQL 读取全量数据，批量更新 Redis（覆盖旧数据）；
    - 适用于：异步同步场景（如 Write-Behind），或解决长期积累的不一致问题；
4. 增量同步兜底：
    - 用 MySQL binlog 同步（推荐）：通过 Canal 等工具监听 MySQL 的 binlog，实时解析数据变更，同步到 Redis（相当于 “准实时异步同步”）；
    - 优点：解耦业务代码（无需在业务中写 Redis 同步逻辑），一致性强，性能好；
    - 适用场景：Cache-Aside 策略的补充，解决并发读写冲突和缓存删除失败问题。

### 五、生产环境推荐方案（兼顾一致性与性能）

绝大多数互联网场景（读多写少、要求最终一致性），推荐「Cache-Aside + MySQL binlog 增量同步 + 过期时间兜底」的组合方案：

1. 写操作流程：
    - 业务代码：先更新 MySQL（事务提交成功）→ 再删除 Redis 缓存；
    - 兜底同步：Canal 监听 MySQL binlog → 解析变更数据 → 异步更新 / 删除 Redis（弥补 “缓存删除失败” 的情况）；
2. 读操作流程：
    - 查 Redis → 命中则返回；
    - 未命中 → 查 MySQL → 写入 Redis → 返回；
3. 关键配置：
    - Redis 缓存 key 过期时间：根据业务设置（如商品数据 1 小时，用户数据 30 分钟）；
    - MySQL 事务：确保数据更新原子性；
    - Canal 同步延迟：控制在 100ms 内（接近实时）；
4. 优势：
    - 业务代码简单（仅需处理 MySQL 更新 + Redis 删除）；
    - 一致性有保障（binlog 兜底同步，避免缓存删除失败）；
    - 性能好（写操作仅多一步 Redis 删除，读操作走缓存）。

### 六、避坑指南：常见错误与解决方案

1. 错误 1：先更新 Redis，再更新 MySQL → 导致 “Redis 改成功，MySQL 改失败” 的脏数据；



解决：必须先更 MySQL，再更 / 删 Redis；

2. 错误 2：写操作只更 MySQL，不处理 Redis → 导致 Redis 中一直是旧数据；



解决：写操作后必须删除 / 更新 Redis，或依赖 binlog 同步；

3. 错误 3：缓存 key 无过期时间 → 旧数据永久存在；



解决：所有缓存 key 强制设置过期时间；

4. 错误 4：高并发写场景下未加锁 → 并发冲突导致不一致；



解决：加分布式锁（如 Redisson），或用 binlog 同步替代业务层删除缓存；

5. 错误 5：忽略 Redis 宕机场景 → 缓存不可用时，大量请求压垮 MySQL；



解决：开启 Redis 集群（高可用），并给 MySQL 加限流 / 熔断（如 Sentinel）。

### 总结

Redis 与 MySQL 数据一致性的核心是 **“以 MySQL 为权威，Redis 为缓存，通过合理的读写策略 + 兜底机制实现最终一致性”**：

- 绝大多数场景：选「Cache-Aside + binlog 同步 + 过期时间」，兼顾一致性、性能和开发成本；
- 强一致性场景：选「Write-Through + 分布式事务」，牺牲性能换一致性；
- 高写性能场景：选「Write-Behind + Redis 持久化」，牺牲部分一致性换性能；
- 兜底原则：缓存必须设过期时间，定期全量同步，用 binlog 解决异步同步问题。