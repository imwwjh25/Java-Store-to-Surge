### 一、Exception 的继承体系

`Exception` 直接继承自 **`Throwable`** 类（Java 中所有错误 / 异常的根类）。`Throwable` 有两个核心子类：

- **`Error`**：表示系统级错误（如`OutOfMemoryError`、`StackOverflowError`），由 JVM 抛出，程序无法处理，通常直接终止；

- `Exception`：表示程序级异常，是用户代码可处理的异常，又分为两类：

    - **受检异常（Checked Exception）**：编译器强制要求处理（如`IOException`、`SQLException`），必须`try-catch`或`throws`声明；
    - **非受检异常（Unchecked Exception）**：继承自`RuntimeException`（如`NullPointerException`、`IndexOutOfBoundsException`），编译器不强制处理，可由程序逻辑规避。

### 二、异常的常规处理方式

1. **`try-catch` 捕获并处理**：直接捕获异常，在`catch`块中编写恢复逻辑（如重试、使用默认值）；
2. **`throws` 声明抛出**：将异常抛给上层调用方处理（适用于当前方法无法处理的情况）；
3. **`try-catch-finally`**：`finally`块释放资源（如关闭流、数据库连接），保证无论是否异常都执行；
4. **`try-with-resources`**：自动关闭实现`AutoCloseable`接口的资源（替代`finally`，更简洁）。

### 三、“不能 try-catch 住、不能往上抛” 的解决方案

若要求**既不捕获吞掉异常，也不向上抛出**，核心思路是**从源头预防异常发生**，或**通过兜底策略处理异常场景**，确保程序不中断且异常被 “妥善消化”：

#### 1. 提前校验，规避异常触发

通过**前置逻辑检查**避免异常发生，从根源消除异常可能：

- 例：避免```NullPointerException```→ 先判断对象是否为```null```；










  ```java
  // 坏写法：直接调用obj.method()，可能抛NPE
  // 好写法：前置校验
  if (obj != null) {
      obj.method();
  } else {
      // 执行备选逻辑（如使用默认对象）
  }
  ```



- 例：避免```NumberFormatException```→ 先校验字符串是否为合法数字；











  ```java
  public static int parseNumber(String s) {
      if (s == null || !s.matches("\\d+")) {
          return 0; // 返回默认值，避免异常
      }
      return Integer.parseInt(s);
  }
  ```



#### 2. 使用兜底方案 / 默认值

异常发生时，用预设的默认值或备选逻辑替代异常路径，保证程序继续运行：

- 例：读取配置文件失败 → 使用硬编码的默认配置；







  ```java
  public Properties loadConfig() {
      Properties props = new Properties();
      try (FileInputStream fis = new FileInputStream("config.properties")) {
          props.load(fis);
      } catch (IOException e) {
          // 不抛异常，用默认配置兜底
          props.setProperty("timeout", "3000");
          props.setProperty("maxConn", "10");
          // 记录日志（关键：保留异常痕迹，不吞掉信息）
          log.error("加载配置失败，使用默认配置", e);
      }
      return props;
  }
  ```



#### 3. 日志记录 + 补偿机制

记录异常的完整上下文（日志），并触发补偿操作（如重试、降级），既不抛异常也不忽略问题：

- 例：调用第三方接口失败 → 有限次数重试，重试失败则用缓存数据；











  ```java
  public String callThirdPartyApi(String url) {
      int retryCount = 3;
      while (retryCount > 0) {
          try {
              return HttpClient.get(url); // 调用接口
          } catch (IOException e) {
              retryCount--;
              log.warn("接口调用失败，剩余重试次数：{}", retryCount, e);
              if (retryCount == 0) {
                  // 补偿：返回缓存数据
                  return cache.get(url);
              }
              Thread.sleep(1000); // 退避重试
          }
      }
      return ""; // 最终兜底
  }
  ```



#### 4. 封装为业务状态码（非异常形式传递）

将异常转换为业务可识别的状态码 / 结果对象，通过返回值传递错误信息，而非抛出异常：

- 例：定义统一结果类```Result<T> ```，包含状态码和数据；











  ```java
  public class Result<T> {
      private int code; // 200成功，500异常
      private String msg;
      private T data;
      // 构造方法、getter/setter
  }
  
  public Result<User> getUserById(Long id) {
      if (id == null || id <= 0) {
          return new Result<>(400, "ID不合法", null);
      }
      User user = userDao.selectById(id);
      if (user == null) {
          return new Result<>(404, "用户不存在", null);
      }
      return new Result<>(200, "成功", user);
  }
  ```



#### 5. 利用设计模式处理异常场景

- **策略模式**：为不同异常场景预设处理策略，发生异常时自动匹配策略执行；
- **责任链模式**：将异常处理逻辑拆分为多个处理器，依次尝试处理，直到异常被消化。

### 核心原则

“不捕获、不抛出” 本质是要求**异常必须被 “消化” 而非 “传递 / 忽略”**，关键在于：

- 提前预防（前置校验）；
- 异常发生时提供**无副作用的兜底逻辑**；
- 保留异常痕迹（日志），便于问题排查。

这种场景常见于对稳定性要求极高的底层组件（如框架核心、中间件），需通过严谨的逻辑设计避免异常扩散。