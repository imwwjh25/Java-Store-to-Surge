### 一、核心原理：线程池的线程创建逻辑

标准线程池（如 Java 的`ThreadPoolExecutor`）的线程创建遵循以下规则：

1. 当提交任务时，若当前线程数 < 核心线程数（`corePoolSize`），则直接新建核心线程执行任务。
2. 若核心线程数已满，任务会被放入任务队列（`workQueue`）。
3. 若队列已满，且当前线程数 < 最大线程数（`maximumPoolSize`），则新建非核心线程执行任务。
4. 若队列和最大线程数都已满，则触发拒绝策略。

**问题**：默认逻辑中，队列未满时会优先将任务放入队列，而非新建线程（即使未达最大线程数）。要改变这一行为，需让队列 “尽快满”，迫使线程池在队列未满时就创建线程至最大数。

### 二、解决方案：使用 “同步队列” 或 “自定义队列”

#### 1. 方案一：使用同步队列（`SynchronousQueue`）

同步队列的特点是**不存储任务**，每个任务必须立即被线程接收，否则视为队列已满。
此时线程池会：

- 先创建核心线程（若未满）。
- 核心线程满后，因队列无法存储任务，直接新建线程至最大线程数（只要未达`maximumPoolSize`）。

**配置示例（Java）**：

java



运行









```java
ThreadPoolExecutor executor = new ThreadPoolExecutor(
    5,                  // 核心线程数（corePoolSize）
    10,                 // 最大线程数（maximumPoolSize）：目标最大线程数
    60L,                // 非核心线程空闲超时时间
    TimeUnit.SECONDS,
    new SynchronousQueue<>(),  // 同步队列（不存储任务）
    Executors.defaultThreadFactory(),
    new ThreadPoolExecutor.AbortPolicy()  // 拒绝策略
);
```

- 当提交任务时，若核心线程（5 个）已满，同步队列无法存储任务，线程池会直接新建线程至最大 10 个（只要任务数≤10）。
- 若任务数超过 10，队列和最大线程都满，触发拒绝策略。

**适用场景**：任务提交频率不高，且需要立即用最大线程处理（队列无缓冲）。

#### 2. 方案二：使用 “有界队列 + 核心线程数 = 最大线程数”

若需要队列有一定缓冲，但仍希望队列未满时达到最大线程数，可将**核心线程数设置为最大线程数**（`corePoolSize = maximumPoolSize`），同时搭配有界队列。
此时线程池会：

- 优先创建核心线程至最大数（因为`corePoolSize`即最大数），之后任务才会进入队列。

**配置示例（Java）**：

java



运行









```java
ThreadPoolExecutor executor = new ThreadPoolExecutor(
    10,                 // 核心线程数=最大线程数（直接创建到最大）
    10,
    60L,
    TimeUnit.SECONDS,
    new ArrayBlockingQueue<>(20),  // 有界队列（缓冲20个任务）
    Executors.defaultThreadFactory(),
    new ThreadPoolExecutor.AbortPolicy()
);
```

- 提交任务时，会先新建线程至 10 个（核心线程满），之后的任务进入队列（最多 20 个）。
- 队列满后，因已达最大线程数，触发拒绝策略。

**效果**：队列未满时，线程数已达最大（10 个），符合 “队列未满时创建最大线程数” 的需求。
**适用场景**：需要队列缓冲，但希望线程数尽快达到最大值。

#### 3. 方案三：自定义任务队列（重写`offer`方法）

通过自定义队列，修改其 “入队规则”：当线程数未达最大时，拒绝入队（迫使线程池新建线程），仅当线程数达最大后才允许入队。

**自定义队列示例（Java）**：

java



运行









```java
class CustomQueue extends ArrayBlockingQueue<Runnable> {
    private final ThreadPoolExecutor executor;

    public CustomQueue(int capacity, ThreadPoolExecutor executor) {
        super(capacity);
        this.executor = executor;
    }

    @Override
    public boolean offer(Runnable e) {
        int currentThreadCount = executor.getPoolSize();
        // 若当前线程数 < 最大线程数，返回false（拒绝入队，迫使线程池新建线程）
        if (currentThreadCount < executor.getMaximumPoolSize()) {
            return false;
        }
        // 否则允许入队
        return super.offer(e);
    }
}

// 使用自定义队列
ThreadPoolExecutor executor = new ThreadPoolExecutor(
    5,                  // 核心线程数
    10,                 // 最大线程数
    60L,
    TimeUnit.SECONDS,
    new CustomQueue(20, executor),  // 自定义队列
    Executors.defaultThreadFactory(),
    new ThreadPoolExecutor.AbortPolicy()
);
```

- 当提交任务时，若线程数未达 10（最大），`offer`返回 false，线程池会新建线程（即使队列未满）。
- 当线程数达 10 后，任务才进入队列（最多 20 个）。

**适用场景**：需要队列缓冲，且严格控制 “线程数优先增长至最大，再使用队列”。

### 三、总结

根据需求选择方案：

1. 无队列缓冲，直接用最大线程：**同步队列（`SynchronousQueue`）**。
2. 有队列缓冲，且线程数优先达最大：**核心线程数 = 最大线程数 + 有界队列**。
3. 复杂缓冲需求，灵活控制入队时机：**自定义队列（重写`offer`）**。