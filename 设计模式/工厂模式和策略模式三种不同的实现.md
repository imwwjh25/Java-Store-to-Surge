### 核心前提（通用代码）

先定义策略层的通用代码（三种实现方式都基于此），保证案例的一致性：




```
// 1. 抽象支付策略
public interface PaymentStrategy {
    String pay(double amount); // 执行支付
    String getType();          // 获取支付类型（如alipay/wechat）
}

// 2. 具体策略：支付宝
public class AlipayStrategy implements PaymentStrategy {
    @Override
    public String pay(double amount) {
        return "支付宝支付：" + amount + "元";
    }

    @Override
    public String getType() {
        return "alipay";
    }
}

// 3. 具体策略：微信支付
public class WechatPayStrategy implements PaymentStrategy {
    @Override
    public String pay(double amount) {
        return "微信支付：" + amount + "元";
    }

    @Override
    public String getType() {
        return "wechat";
    }
}

// 4. 具体策略：银联支付
public class UnionPayStrategy implements PaymentStrategy {
    @Override
    public String pay(double amount) {
        return "银联支付：" + amount + "元";
    }

    @Override
    public String getType() {
        return "unionpay";
    }
}
```

------

## 方式一：工厂 + if-else 实现

### 实现思路

在策略工厂中，通过`if-else`判断支付类型，创建对应的策略对象 —— 最基础的实现方式，逻辑直观但扩展时需修改工厂代码。

### 完整代码






```
// 策略工厂（if-else版）
public class PaymentStrategyFactory {
    // 私有化构造，避免实例化
    private PaymentStrategyFactory() {}

    /**
     * 根据支付类型创建策略对象
     * @param type 支付类型（alipay/wechat/unionpay）
     * @return 具体策略对象
     */
    public static PaymentStrategy createStrategy(String type) {
        // 空值/空字符串校验（必加，避免NPE）
        if (type == null || type.trim().isEmpty()) {
            throw new IllegalArgumentException("支付类型不能为空");
        }

        // if-else判断创建策略
        if ("alipay".equals(type)) {
            return new AlipayStrategy();
        } else if ("wechat".equals(type)) {
            return new WechatPayStrategy();
        } else if ("unionpay".equals(type)) {
            return new UnionPayStrategy();
        } else {
            throw new IllegalArgumentException("不支持的支付类型：" + type);
        }
    }
}

// 客户端使用
public class Client {
    public static void main(String[] args) {
        // 1. 创建策略（只需传入类型）
        PaymentStrategy strategy = PaymentStrategyFactory.createStrategy("alipay");
        // 2. 执行支付
        System.out.println(strategy.pay(100)); // 输出：支付宝支付：100.0元
    }
}
```

### 优缺点





|          优点          |                     缺点                      |
| :--------------------: | :-------------------------------------------: |
|  逻辑直观，新手易理解  |  扩展新策略时需修改工厂代码（违反开闭原则）   |
|   代码量少，实现简单   |     策略过多时，if-else 链冗长，可读性差      |
| 无需额外依赖（如枚举） | 容易出现漏写 / 错写类型的问题（字符串硬编码） |

### 适用场景

- 策略数量少（≤3 种）；
- 快速原型开发，无需长期维护；
- 团队新手较多，优先保证可读性。

------

## 方式二：工厂 + switch 实现

### 实现思路

在策略工厂中，用`switch`（Java 14 + 支持 switch 表达式）替代`if-else`，逻辑更清晰，尤其适合多分支场景 —— 是`if-else`的优化版，但仍需修改工厂代码扩展策略。

### 完整代码








```
// 策略工厂（switch版，Java 14+）
public class PaymentStrategyFactory {
    private PaymentStrategyFactory() {}

    public static PaymentStrategy createStrategy(String type) {
        if (type == null || type.trim().isEmpty()) {
            throw new IllegalArgumentException("支付类型不能为空");
        }

        // switch表达式（推荐），自动返回结果
        return switch (type) {
            case "alipay" -> new AlipayStrategy();
            case "wechat" -> new WechatPayStrategy();
            case "unionpay" -> new UnionPayStrategy();
            default -> throw new IllegalArgumentException("不支持的支付类型：" + type);
        };

        // 传统switch（兼容低版本Java）
        /*
        switch (type) {
            case "alipay":
                return new AlipayStrategy();
            case "wechat":
                return new WechatPayStrategy();
            case "unionpay":
                return new UnionPayStrategy();
            default:
                throw new IllegalArgumentException("不支持的支付类型：" + type);
        }
        */
    }
}

// 客户端使用（与if-else版完全一致）
public class Client {
    public static void main(String[] args) {
        PaymentStrategy strategy = PaymentStrategyFactory.createStrategy("wechat");
        System.out.println(strategy.pay(200)); // 输出：微信支付：200.0元
    }
}
```

### 优缺点



|               优点                |                    缺点                    |
| :-------------------------------: | :----------------------------------------: |
|    多分支时可读性优于 if-else     | 扩展新策略仍需修改工厂代码（违反开闭原则） |
| switch 表达式语法简洁（Java 14+） |           仍存在字符串硬编码问题           |
|       分支逻辑清晰，易调试        |        策略数量极多（>5）时仍显冗长        |

### 适用场景

- 策略数量中等（3~5 种）；
- 使用 Java 14+，希望代码更简洁；
- 需兼顾可读性和简洁性的常规场景。

------

## 方式三：工厂 + 枚举 实现

### 实现思路

1. 定义**支付类型枚举**，每个枚举值绑定对应的策略类 / 策略实例；
2. 工厂通过枚举获取策略，无需`if-else/switch`，扩展新策略时仅需新增枚举值（无需修改工厂代码）—— 最优雅、最符合 “开闭原则” 的实现方式。

### 完整代码

#### 步骤 1：定义支付枚举（核心）




```
// 支付类型枚举（绑定策略）
public enum PaymentTypeEnum {
    // 枚举值：类型标识 + 策略类 + 策略实例
    ALIPAY("alipay", AlipayStrategy.class),
    WECHAT("wechat", WechatPayStrategy.class),
    UNIONPAY("unionpay", UnionPayStrategy.class);

    // 枚举属性
    private final String type;        // 支付类型标识
    private final Class<? extends PaymentStrategy> strategyClass; // 策略类
    private PaymentStrategy strategyInstance; // 策略实例（懒加载）

    // 构造器
    PaymentTypeEnum(String type, Class<? extends PaymentStrategy> strategyClass) {
        this.type = type;
        this.strategyClass = strategyClass;
    }

    // 懒加载创建策略实例（避免枚举初始化时创建）
    public PaymentStrategy getStrategy() {
        if (strategyInstance == null) {
            try {
                // 通过反射创建策略实例（无参构造）
                strategyInstance = strategyClass.getDeclaredConstructor().newInstance();
            } catch (Exception e) {
                throw new RuntimeException("创建支付策略失败：" + this.type, e);
            }
        }
        return strategyInstance;
    }

    // 根据类型标识获取枚举值（核心方法）
    public static PaymentTypeEnum getByType(String type) {
        if (type == null || type.trim().isEmpty()) {
            throw new IllegalArgumentException("支付类型不能为空");
        }
        // 遍历枚举值匹配类型
        for (PaymentTypeEnum enumObj : PaymentTypeEnum.values()) {
            if (enumObj.type.equals(type)) {
                return enumObj;
            }
        }
        throw new IllegalArgumentException("不支持的支付类型：" + type);
    }

    // getter
    public String getType() {
        return type;
    }
}
```

#### 步骤 2：枚举版策略工厂









```
// 策略工厂（枚举版）
public class PaymentStrategyFactory {
    private PaymentStrategyFactory() {}

    /**
     * 通过枚举创建策略（无需if-else/switch）
     * @param type 支付类型标识
     * @return 具体策略对象
     */
    public static PaymentStrategy createStrategy(String type) {
        // 1. 根据类型获取枚举值
        PaymentTypeEnum enumObj = PaymentTypeEnum.getByType(type);
        // 2. 从枚举获取策略实例
        return enumObj.getStrategy();
    }
}
```

#### 步骤 3：客户端使用









```
public class Client {
    public static void main(String[] args) {
        // 1. 创建银联支付策略
        PaymentStrategy strategy = PaymentStrategyFactory.createStrategy("unionpay");
        // 2. 执行支付
        System.out.println(strategy.pay(300)); // 输出：银联支付：300.0元

        // 扩展新策略示例：新增PayPal（仅需两步）
        // 1. 新增PayPalStrategy实现PaymentStrategy；
        // 2. 枚举中新增：PAYPAL("paypal", PayPalStrategy.class)；
        // 无需修改工厂代码，符合开闭原则！
    }
}
```

### 进阶优化：枚举 + 单例策略

若策略无状态（如示例中的支付策略），可将策略实例改为**单例**，避免重复创建：











```
// 枚举中优化getStrategy方法
public PaymentStrategy getStrategy() {
    if (strategyInstance == null) {
        synchronized (this) { // 双重检查锁，保证单例
            if (strategyInstance == null) {
                try {
                    strategyInstance = strategyClass.getDeclaredConstructor().newInstance();
                } catch (Exception e) {
                    throw new RuntimeException("创建策略失败", e);
                }
            }
        }
    }
    return strategyInstance;
}
```

### 优缺点







|                  优点                  |                           缺点                            |
| :------------------------------------: | :-------------------------------------------------------: |
| 符合开闭原则：扩展新策略仅需新增枚举值 |             入门门槛稍高（需理解枚举 + 反射）             |
| 无 if-else/switch，代码更简洁、易维护  |           策略类必须有**无参构造**（反射要求）            |
|    避免字符串硬编码：类型由枚举管控    | 反射创建实例有轻微性能损耗（可忽略，懒加载 + 单例可优化） |
|  枚举天然单例，可统一管理所有策略类型  |                                                           |

### 适用场景

- 策略数量多（≥3 种）或未来会频繁扩展；
- 追求代码优雅、符合设计原则的中大型项目；
- 希望统一管控所有策略类型，避免硬编码错误。

------

## 三种实现方式对比总结






|    维度    |     if-else 版     |    switch 版     |         枚举版          |
| :--------: | :----------------: | :--------------: | :---------------------: |
|   可读性   |    差（多分支）    |  中（分支清晰）  | 优（无分支，枚举管控）  |
|   扩展性   |  差（改工厂代码）  | 差（改工厂代码） |   优（仅新增枚举值）    |
|  编码成本  |   低（新手易写）   | 中（语法稍复杂） | 高（需设计枚举 + 反射） |
|  出错风险  | 高（字符串硬编码） | 中（仍有硬编码） |   低（枚举约束类型）    |
|  开闭原则  |        违反        |       违反       |          符合           |
| 适用策略数 |       ≤3 种        |      3~5 种      |      ≥3 种（推荐）      |

### 最终选型建议

1. **快速原型 / 小项目**：用`if-else`（最快实现）；
2. **常规场景 / 中等策略数**：用`switch`（平衡简洁与可读性）；
3. **中大型项目 / 需长期维护**：用`枚举`（最优雅、易扩展）；
4. **极致性能场景**：枚举版 + 单例策略（反射仅执行一次，性能接近直接 new）。

### 核心要点回顾

1. 工厂 + 策略的核心是**工厂封装策略创建，策略封装算法**，无论哪种实现方式，都要保证客户端只需传入 “类型标识” 即可使用策略；
2. 枚举版是工业级最佳实践，核心优势是 “扩展不修改原有代码”，符合开闭原则；
3. 所有实现方式都要**先校验入参**（空值 / 非法类型），避免 NPE 或非法参数异常；
4. 无状态的策略建议做成单例，减少对象创建开销。