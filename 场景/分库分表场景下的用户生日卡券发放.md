### 3. 5 亿用户生日优惠券发放（分库分表场景）

#### 核心挑战

- 数据规模：5 亿用户，按 `user_name` 分库分表（假设分 100 库、1000 表，共 10 万表）；
- 业务要求：每天准确识别「当天过生日」的用户，发放优惠券，确保不重复、不遗漏，支持高并发；
- 关键问题：`user_name` 分库分表无法直接按「生日」筛选，需跨库跨表查询当天生日用户，效率极低。

#### 解决方案：「预分区 + 定时任务 + 消息队列」

核心思路：**将「按 user_name 分库分表」的用户数据，按「生日月日」预分区存储**，每天仅需扫描对应生日分区的表，避免跨库跨表全量扫描。

#### 一、数据分层设计

##### 1. 主数据层（按 user_name 分库分表）

- 存储用户完整信息（`user_id`、`user_name`、`birthday`（生日，格式 `YYYY-MM-DD`）、`phone`、`address` 等）；
- 分库分表规则：`hash(user_name) % 100` 分库，`hash(user_name) % 1000` 分表（确保同一用户数据在同一库表）；
- 作用：支持用户信息查询、更新等日常业务。

##### 2. 生日分区层（按生日月日分表）

- 核心设计：独立于主数据层，按「生日月日」分表，存储用户 `user_id` 和 `birthday`（仅需月日信息）；

- 分表规则：共 366 张表（`birthday_0101` 到 `birthday_1231`），对应一年 366 天（含闰年 2 月 29 日）；

- 表结构（```birthday_MMDD```）：

| user_id（用户 ID） | birthday（生日，格式 MM-DD） | is_sent（是否已发放优惠券） | send_time（发放时间） |

- 同步策略：

    1. 新增用户：主数据层插入用户后，发送消息到 MQ，消费者根据 `birthday` 的月日，插入对应 `birthday_MMDD` 表；
    2. 更新生日：用户修改生日时，先更新主数据层，再删除原生日分区表的记录，插入新生日分区表；
    3. 全量同步：每天凌晨执行全量对账，确保主数据层和生日分区层数据一致（如新增用户未同步、生日修改未同步）。

#### 二、优惠券发放流程（每天执行）

##### 1. 定时任务触发（精准定位目标表）

- 每天凌晨 00:00 启动定时任务（如 XXL-Job、Elastic-Job 分布式定时任务框架），避免单点故障；
- 任务计算当天的「月日标识」（如 11 月 19 日 → `1119`），确定目标表 `birthday_1119`（仅需扫描这 1 张表，无需跨库跨表）。

##### 2. 批量读取目标用户（高并发优化）

- 任务按「分库分表」并行扫描 `birthday_1119` 表（假设生日分区层也分 100 库，每个库 3-4 张生日表）；
- 读取条件：`birthday = '11-19' AND is_sent = 0`（未发放优惠券的用户）；
- 分页读取：每次读取 1000 条用户 ID，避免一次性加载过多数据导致内存溢出。

##### 3. 优惠券发放（异步高并发）

- 批量将用户 ID 发送到 MQ（如 RocketMQ Topic 按用户 ID 哈希分区，确保同一用户消息顺序消费）；
- 优惠券服务监听 MQ 消息，执行发放逻辑：
    1. 调用优惠券系统接口，为用户创建优惠券（需幂等处理，避免重复发放，如通过 `user_id + 日期` 作为唯一键）；
    2. 发放成功后，更新 `birthday_1119` 表的 `is_sent = 1` 和 `send_time = NOW()`；
    3. 发放失败（如优惠券系统超时）：消息重试（最多 3 次），重试失败则存入死信队列，后续人工处理。

##### 4. 兜底校验（避免遗漏）

- 当天中午 12:00 启动「遗漏校验任务」，再次扫描 `birthday_1119` 表，查询 `is_sent = 0` 的用户；
- 对未发放的用户，重新触发发放流程（可能是凌晨发放时 MQ 消息丢失、服务宕机导致）；
- 生成发放报表（成功数、失败数、遗漏数），用于业务监控。

#### 三、关键优化点

1. 预分区减少扫描范围：按生日月日分表，每天仅需扫描 1 张表（366 分之一的数据），避免 5 亿用户全量扫描；
2. 分布式任务并行处理：定时任务按库表并行执行，100 个库同时扫描，处理效率提升 100 倍；
3. 异步发放解耦：通过 MQ 异步发放优惠券，支持每秒万级并发，避免定时任务阻塞；
4. 幂等性设计：发放优惠券时，通过 `user_id + 日期` 唯一键确保不重复发放，更新 `is_sent` 状态时使用 `UPDATE ... WHERE user_id = ? AND is_sent = 0` 避免重复更新；
5. 容灾处理：定时任务、MQ、优惠券服务均采用集群部署，避免单点故障；死信队列 + 人工处理确保失败案例不遗漏。

#### 四、扩展场景（如支持农历生日）

- 新增「农历生日」字段 `lunar_birthday`（格式 `MM-DD`），同步到生日分区层（新增 `lunar_birthday_0101` 到 `lunar_birthday_1231` 表）；
- 定时任务每天同时计算「公历月日」和「农历月日」（需农历 - 公历转换工具），扫描对应的两张表，发放优惠券；
- 支持用户选择「公历 / 农历生日」发放优惠券，通过 `user` 表的 `birthday_type` 字段控制。
