在 Kafka 中，**整体有序（全局有序）** 和 **局部有序（业务维度有序）** 的实现，核心都围绕「分区的有序性特性」—— 整体有序靠 “单分区” 强约束，局部有序靠 “按业务 Key 路由到固定分区”，两者的区别在于「分区粒度与业务绑定方式」，具体实现方案如下：

## 一、整体有序（全局有序）：单分区 + 严格有序配置

整体有序指 **所有消息（无论业务维度）按发送顺序全局消费**（比如全量日志同步、时序数据采集，要求 “先发生的消息必须先处理”）。

### 实现方案：Topic 仅配置 1 个分区 + 全链路有序保障

#### 1. 核心设计：单分区是全局有序的唯一前提

Kafka 只有 “分区内 FIFO” 的特性，要实现全局有序，必须让 **所有消息都进入同一个分区**——Topic 的 `partition 数 = 1`，此时所有消息按发送顺序追加到这一个分区，消费时也只能按 Offset 顺序读取，天然全局有序。

#### 2. 全链路配置保障（缺一不可）

仅单分区不够，还需生产者、消费者配合，避免任何环节破坏有序：

- **生产者配置**：
    1. 无需指定 `key`（或固定 `key`），所有消息默认进入唯一分区；
    2. 开启 `retries > 0`（重试机制，避免消息丢失），同时强制设置 `max.in.flight.requests.per.connection = 1`（禁止单个连接同时发送多个未确认请求，防止重试导致消息乱序）；
    3. 禁用批量发送（`batch.size = 0`）或确保批量发送是有序的（默认批量发送是按发送顺序打包，无需修改，但需避免多线程生产）；
    4. 生产者单线程发送（若多线程生产，需通过锁保证发送顺序，否则线程间消息可能乱序）。
- **消费者配置**：
    1. 消费者组内仅启动 1 个消费者实例（或 1 个消费者线程），因为单分区只能被同一个组内的 1 个消费者线程消费；
    2. 按 Offset 顺序读取 + 处理，禁止多线程并行处理该分区消息（比如拉取消息后直接单线程处理，不分发到工作线程）；
    3. 手动提交 Offset（`enable.auto.commit = false`），处理完一条消息后再提交对应的 Offset（避免跳过消息）。

#### 3. 示例场景：全量日志同步

- 需求：所有服务的日志按产生时间全局有序，供下游审计系统消费；
- 实现：创建 `global-log-topic`（partition=1），所有服务的日志生产者单线程发送到该 Topic，消费者单线程按顺序消费，确保日志时序一致。

#### 优点：实现简单，绝对全局有序；

#### 缺点：性能瓶颈明显（单分区的生产 / 消费 TPS 有限，通常只能支撑每秒几千到几万条消息），不适合高并发场景。

## 二、局部有序（业务维度有序）：多分区 + 业务 Key 路由

局部有序指 **同一业务维度的消息有序，不同维度的消息可并行无序**（比如电商订单：同一订单的创建、支付、发货消息有序，不同订单的消息可无序），是生产环境最常用的方案（兼顾有序性和并发性能）。

### 实现方案：多分区 + 按业务 Key 路由 + 单线程消费 per 分区

#### 1. 核心设计：“业务 Key → 固定分区” 绑定

通过「业务 Key 的路由规则」，让同一维度的消息进入同一个分区（保证该维度有序），不同维度的消息进入不同分区（并行处理，提升并发）。

#### 2. 具体步骤：

- **Step 1：Topic 配置多分区**：根据业务并发量设置分区数（比如订单场景设置 10 个分区，支撑 10 倍并发）；

- **Step 2：生产者路由规则**：

    1. 发送消息时，指定「业务 Key」（如订单 ID、用户 ID）；

    2. 采用默认分区器（```DefaultPartitioner```），通过```hash(业务 Key) % 分区数```计算分区（相同 Key 永远进入同一个分区）；

     - 若担心 hash 碰撞导致热点分区（比如某类 Key 过多），可自定义分区器（如按 Key 的范围分片：订单 ID 前 3 位相同的进入同一分区）。

- **Step 3：消费者有序处理**：

    1. 消费者组内启动与分区数匹配的消费者线程（比如 10 个分区对应 10 个线程），Kafka 会自动将每个分区分配给 1 个线程；
    2. 每个线程单线程处理对应分区的消息（按 Offset 顺序读取 + 处理），同一业务维度的消息在同一个分区内有序，不同分区的消息并行处理。

#### 3. 示例场景：电商订单有序

- 需求：同一订单的消息（创建→支付→发货）有序，不同订单可并行；
- 实现：
    1. 创建 `order-topic`（partition=10）；
    2. 生产者发送订单消息时，用 `orderId` 作为 Key，通过 `hash(orderId) % 10` 路由到对应分区；
    3. 消费者组启动 10 个线程，每个线程处理 1 个分区的消息，同一订单的消息在同一分区有序，10 个订单并行处理。

#### 优点：并发性能高（分区数越多，并发能力越强），适配高吞吐场景；

#### 注意事项：

- 分区数一旦确定，尽量不修改（修改后 `hash(Key) % 分区数` 结果变化，导致同 Key 消息进入不同分区，破坏历史有序性）；
- 若必须扩容分区，可采用 “范围分片” 替代 hash 路由（如订单 ID 按区间分配：1-10000 进入分区 0，10001-20000 进入分区 1），避免路由规则变化。

## 三、整体有序 vs 局部有序：核心区别与选型建议

| 对比维度   | 整体有序（单分区）                 | 局部有序（多分区 + 业务 Key）       |
| ---------- | ---------------------------------- | ----------------------------------- |
| 实现核心   | 单分区 + 全链路有序约束            | 业务 Key 路由 + 单线程消费 per 分区 |
| 有序性保障 | 绝对全局有序                       | 同一业务维度有序，跨维度无序        |
| 并发性能   | 低（单分区瓶颈）                   | 高（分区数决定并发能力）            |
| 适用场景   | 全量时序数据、日志审计、强一致同步 | 电商订单、用户操作轨迹、分维度业务  |
| 配置复杂度 | 简单（单分区 + 基础有序配置）      | 中等（分区规划 + Key 路由设计）     |

### 选型原则：

1. 优先选局部有序：绝大多数业务场景只需要 “同一维度有序”，局部有序能兼顾性能和有序性，是生产环境首选；
2. 仅特殊场景选整体有序：只有 “全量消息必须严格按发送顺序处理”（如审计、时序数据），且并发量低时，才用单分区实现整体有序；
3. 避免过度追求整体有序：若高并发场景硬要整体有序，会导致系统性能瓶颈，可考虑通过 “中间件转发”（如 Kafka Streams 按顺序重排）模拟整体有序，但会增加复杂度。

## 四、常见坑与避坑指南

1. **整体有序坑**：多线程生产单分区 Topic，未加锁导致发送顺序乱 → 解决方案：生产者单线程发送，或通过锁保证多线程发送顺序；
2. **局部有序坑**：业务 Key 为空，导致消息轮询进入不同分区 → 解决方案：必须指定业务 Key（如订单 ID、用户 ID）；
3. **重试乱序坑**：生产者开启重试但未设置 `max.in.flight.requests.per.connection = 1` → 解决方案：强制设置该参数为 1，避免重试导致消息颠倒；
4. **消费乱序坑**：一个消费者线程拉取分区消息后，分给多工作线程并行处理 → 解决方案：每个分区仅用一个线程处理，禁止并行分发。

## 核心总结

- 整体有序：**单分区 + 生产者单线程发送 + 消费者单线程消费**，简单但性能低；
- 局部有序：**多分区 + 业务 Key 路由 + 单线程消费 per 分区**，兼顾性能和有序性，生产首选；
- 本质：Kafka 只保证分区内有序，整体有序是局部有序的 “极端情况（单分区）”，局部有序是业务落地的 “最优解”。