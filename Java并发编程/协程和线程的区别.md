# 一、协程是什么？

协程（Coroutine），也叫 “用户态线程” 或 “微线程”，是 **由程序员（或框架）在用户态调度的 “执行单元”**—— 它依赖于线程存在，但调度完全不经过操作系统内核，而是由程序自身控制（比如通过 yield 暂停、resume 恢复），核心特点是 “**协作式调度**”（而非线程的 “抢占式调度”）。

可以通俗理解为：

- 线程是 “操作系统管理的打工者”，内核会强行分配 CPU 时间片（抢占式），打工者之间会抢资源；
- 协程是 “线程管理的临时工”，必须自己主动 “暂停工作（yield）”，让其他协程执行（协作式），不会被强行打断。

协程的核心操作：

- **挂起（Suspend）**：协程执行到某个点时，主动暂停，保存当前执行上下文（程序计数器、栈帧等）；
- **恢复（Resume）**：后续通过调用接口，恢复协程的执行上下文，从暂停点继续执行。

# 二、为什么协程是 “轻量级线程”？轻量在哪里？

协程的 “轻量” 是相对于线程而言的，核心体现在 **资源占用极少、调度开销极低**，具体拆解为 4 个维度：

## 1. 轻量 1：内存占用极省（栈空间）

- **线程**：操作系统为每个线程分配独立的 “内核栈”，默认大小通常是 1MB~8MB（比如 Java 线程默认栈大小 1MB）—— 即使线程不执行任何任务，也会占用固定的栈内存；
- **协程**：协程的栈是 “用户态栈”，由程序（或框架）管理，大小可动态调整（通常是 KB 级，比如 4KB~64KB），且仅在执行时占用内存，挂起时几乎不消耗额外资源。

举个例子：

- 1 万个线程：占用内存 = 1 万 × 1MB = 约 10GB，操作系统根本无法支撑（线程数量上限通常是几千）；
- 1 万个协程：占用内存 = 1 万 × 16KB = 约 156MB，普通服务器轻松承载，甚至能支撑百万级协程。

## 2. 轻量 2：调度开销极低（无内核切换）

线程和协程的调度流程差异，直接决定了开销差距：

### （1）线程调度（内核态切换）

线程是 “内核级调度单元”，调度由操作系统内核完成，流程如下：

1. 内核暂停当前线程，保存线程的内核栈、寄存器、程序计数器等上下文；
2. 从就绪队列中选择另一个线程，恢复其上下文；
3. 切换 CPU 执行权限（用户态 ↔ 内核态）。

这个过程的开销很大：

- 涉及内核态与用户态的切换（CPU 特权级切换，耗时）；
- 上下文保存 / 恢复的数据量多（内核栈、寄存器等）；
- 高并发下，大量线程切换会导致 CPU 开销浪费在 “切换” 上（上下文切换风暴）。

### （2）协程调度（用户态切换）

协程是 “用户级调度单元”，调度由程序自身（或框架，如 Go 的 runtime、Python 的 gevent）完成，流程如下：

1. 协程主动调用 yield 暂停，保存用户态的栈帧、程序计数器等上下文（仅需保存少量数据）；
2. 程序从协程就绪队列中选择一个，恢复其上下文；
3. 全程在用户态执行，不涉及内核态切换。

这个过程的开销极小：

- 无内核态切换（用户态内部完成，耗时仅为线程切换的千分之一）；
- 上下文保存 / 恢复的数据量少（仅用户态栈的核心信息）；
- 调度逻辑由程序控制，无需内核参与，延迟极低。

## 3. 轻量 3：创建 / 销毁成本低

- **线程**：创建线程需要操作系统内核分配内核栈、PCB（进程控制块）等资源，销毁时需要回收这些内核资源 —— 涉及内核调用，成本高；
- **协程**：创建协程仅需在用户态分配少量内存（用于保存上下文和栈），销毁时直接释放用户态内存 —— 无需内核干预，成本接近普通对象的创建 / 销毁。

比如 Go 语言中，创建一个协程（goroutine）的成本几乎可以忽略，而创建一个线程的成本是协程的数百倍。

## 4. 轻量 4：无额外内核资源占用

- **线程**：除了栈内存，还会占用内核的调度资源（如就绪队列、等待队列中的节点），操作系统对线程数量有严格限制（通常是几千个）；
- **协程**：不占用额外内核资源，仅依赖于一个或多个线程（称为 “载体线程”）执行，协程数量仅受限于物理内存（可轻松达到百万级）。

# 三、协程与线程的核心区别（表格对比）

| 对比维度        | 线程（Kernel Thread）                                   | 协程（Coroutine）                                            |
| --------------- | ------------------------------------------------------- | ------------------------------------------------------------ |
| 调度主体        | 操作系统内核（抢占式调度）                              | 程序 / 框架（用户态调度，协作式 / 半抢占式）                 |
| 调度开销        | 高（内核态切换 + 大量上下文保存）                       | 极低（用户态切换 + 少量上下文保存）                          |
| 内存占用        | 高（内核栈 1MB~8MB）                                    | 极低（用户栈 4KB~64KB，动态调整）                            |
| 创建 / 销毁成本 | 高（内核资源分配 / 回收）                               | 低（用户态内存操作，接近对象）                               |
| 数量上限        | 低（几千个，受内核限制）                                | 极高（百万级，受物理内存限制）                               |
| 并发模型        | 多线程并行（多个线程同时执行，依赖多核 CPU）            | 多协程并发（同一时间一个线程仅执行一个协程，通过切换模拟并行） |
| 阻塞影响        | 线程阻塞（如 IO 等待）会占用内核资源，导致 CPU 利用率低 | 协程阻塞（如 IO 等待）会主动挂起，释放载体线程执行其他协程，CPU 利用率高 |
| 编程复杂度      | 低（内核调度，无需手动管理切换）                        | 中（需手动处理 yield/resume，或依赖框架封装）                |
| 依赖            | 依赖操作系统内核支持                                    | 依赖线程（载体）和用户态调度框架                             |

> 补充：现代协程框架（如 Go 的 goroutine、Java 的 Project Loom）支持 “半抢占式调度”—— 当协程执行时间过长（如超过 10ms），框架会主动触发挂起，避免单个协程独占线程，解决了传统协作式调度的 “饥饿问题”。

# 四、关键场景：协程的优势在哪里？

协程的核心优势体现在 **“IO 密集型并发场景”**（如网络请求、数据库查询、文件读写）—— 这类场景中，线程大部分时间都在等待 IO 完成（阻塞状态），而协程可以在 IO 等待时主动挂起，让载体线程执行其他协程，极大提升 CPU 利用率。

举个例子：1 万个网络请求（每个请求需 1 秒 IO 等待）

- **多线程方案**：需创建 1 万个线程，每个线程等待 1 秒 —— 内存占用 10GB+，上下文切换频繁，CPU 利用率不足 1%；
- **协程方案**：仅需 10 个载体线程（对应 CPU 核心数），每个协程在 IO 等待时挂起，线程切换执行其他协程 —— 内存占用仅 156MB，CPU 利用率接近 100%，执行效率提升数十倍。

而在 **CPU 密集型场景**（如大量计算、循环），协程几乎无优势 —— 因为协程无法并行执行（同一线程的协程只能串行），此时多线程并行（利用多核 CPU）的效率更高。

# 五、总结：协程的核心价值

1. **极致的并发能力**：百万级协程支持，轻松应对高并发 IO 场景（如微服务、爬虫、消息队列）；
2. **极低的资源消耗**：内存占用和调度开销远低于线程，降低服务器成本；
3. **高效的 CPU 利用率**：IO 等待时主动挂起，避免线程阻塞浪费资源。

简单说：**协程是 “线程的优化版”，解决了线程在高并发 IO 场景下的资源浪费问题，是高并发编程的核心技术之一**（如 Go 语言的高并发能力，本质就是依赖 goroutine 协程模型）
