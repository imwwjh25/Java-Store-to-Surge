### 一、数据库范式基础概念

首先明确：**范式（NF）** 是数据库表设计的规范，核心目标是**消除数据冗余**、**避免更新异常**（插入 / 更新 / 删除异常）。范式是 “递进式” 的，满足高范式必须先满足低范式，通常默认基于**关系型数据库**、以 “函数依赖” 和 “主键” 为基础。

### 二、五大范式详解（附实战例子）

为了让例子更直观，我会围绕一个核心场景：**电商用户订单系统**，从反范式的糟糕设计开始，逐步优化到各范式。

#### 前置准备：核心概念简化

- **函数依赖**：若字段 A 的值能唯一确定字段 B 的值，称 B 依赖于 A（如`用户ID → 用户名`）；
- **主键**：唯一标识一行数据的字段 / 字段组合；
- **部分依赖**：非主键字段仅依赖于主键的一部分（如联合主键`(订单ID,商品ID)`，`商品名称`仅依赖`商品ID`）；
- **传递依赖**：非主键字段通过其他非主键字段依赖主键（如`订单ID → 商品ID → 商品分类`）；
- **多值依赖**：一个主键对应多个独立的多值字段（如`用户ID → 多个收货地址 + 多个联系电话`）；
- **连接依赖**：表的信息必须通过多个子表连接才能完整还原，拆分后无冗余。

------

#### 1. 第一范式（1NF）：原子性

##### 定义

表中的**每一列必须是不可再分的原子值**，不能有嵌套、数组、多值字段。

##### 反例（不满足 1NF）






| 订单 ID | 用户信息（非原子） | 商品（非原子） | 金额 |
| :-----: | :----------------: | :------------: | :--: |
|    1    | 张三，13800138000  |   手机，耳机   | 5000 |
|    2    | 李四，13900139000  |      电脑      | 8000 |

问题：

- “用户信息” 包含姓名 + 手机号，可拆分；
- “商品” 包含多个商品，可拆分；
- 无法单独查询 “买了手机的订单”，数据冗余且查询困难。

##### 正例（满足 1NF）







| 订单 ID | 用户名 |   手机号    | 商品名称 | 金额 |
| :-----: | :----: | :---------: | :------: | :--: |
|    1    |  张三  | 13800138000 |   手机   | 4000 |
|    1    |  张三  | 13800138000 |   耳机   | 1000 |
|    2    |  李四  | 13900139000 |   电脑   | 8000 |

核心：每一列只有一个值，不可再拆。

------

#### 2. 第二范式（2NF）：消除部分依赖

##### 定义

满足 1NF + **所有非主键字段必须完全依赖于整个主键**（而非主键的一部分）。

👉 关键：若主键是**联合主键**，非主键字段不能只依赖其中一个主键字段。

##### 反例（满足 1NF，但不满足 2NF）

主键：`(订单ID,商品名称)`（联合主键）






| 订单 ID | 商品名称 | 用户名（依赖订单 ID） | 手机号（依赖订单 ID） | 商品单价（依赖商品名称） | 金额 |
| :-----: | :------: | :-------------------: | :-------------------: | :----------------------: | :--: |
|    1    |   手机   |         张三          |      13800138000      |           4000           | 4000 |
|    1    |   耳机   |         张三          |      13800138000      |           1000           | 1000 |
|    2    |   电脑   |         李四          |      13900139000      |           8000           | 8000 |

问题：

- “用户名、手机号” 仅依赖`订单ID`（主键的一部分）；
- “商品单价” 仅依赖`商品名称`（主键的一部分）；
- 冗余严重：比如 “手机单价 4000” 重复存储，修改单价需改所有相关行。

##### 正例（满足 2NF）：拆分表，消除部分依赖

- **订单表（t_order）**：主键`订单ID`







| 订单 ID | 用户名 |   手机号    |
  | :-----: | :----: | :---------: |
|    1    |  张三  | 13800138000 |
|    2    |  李四  | 13900139000 |



- **商品表（t_product）**：主键`商品名称`








| 商品名称 | 商品单价 |
  | :------: | :------: |
|   手机   |   4000   |
|   耳机   |   1000   |
|   电脑   |   8000   |



- **订单明细表（t_order_item）**：主键`(订单ID,商品名称)`





| 订单 ID | 商品名称 | 金额 |
  | :-----: | :------: | :--: |
|    1    |   手机   | 4000 |
|    1    |   耳机   | 1000 |
|    2    |   电脑   | 8000 |



核心：拆分后，每个表的非主键字段都完全依赖于自身主键。

------

#### 3. 第三范式（3NF）：消除传递依赖

##### 定义

满足 2NF + **非主键字段不能传递依赖于主键**（即非主键字段之间不能有函数依赖）。

##### 反例（满足 2NF，但不满足 3NF）

以 “订单表” 为例，新增 “用户所在省份” 和 “省份邮编”：




| 订单 ID | 用户名 |   手机号    |  省份  |  邮编  |
| :-----: | :----: | :---------: | :----: | :----: |
|    1    |  张三  | 13800138000 | 广东省 | 510000 |
|    2    |  李四  | 13900139000 | 广东省 | 510000 |

问题：

- 主键是`订单ID`，`邮编`依赖于`省份`（`省份 → 邮编`），而非直接依赖`订单ID`；
- 冗余：“广东省 = 510000” 重复存储，修改邮编需改所有相关行。

##### 正例（满足 3NF）：拆分传递依赖字段

- **用户表（t_user）**：主键`用户ID`（新增用户 ID，替代用户名作为主键，更规范）






| 用户 ID | 用户名 |   手机号    | 省份 ID |
  | :-----: | :----: | :---------: | :-----: |
|    1    |  张三  | 13800138000 |    1    |
|    2    |  李四  | 13900139000 |    1    |



- **省份表（t_province）**：主键`省份ID`






| 省份 ID | 省份名称 |  邮编  |
  | :-----: | :------: | :----: |
|    1    |  广东省  | 510000 |
|    2    |  浙江省  | 310000 |



- **订单表（t_order）**：主键`订单ID`






| 订单 ID | 用户 ID |
  | :-----: | :-----: |
|    1    |    1    |
|    2    |    2    |



核心：非主键字段仅直接依赖主键，无 “主键→非主键→非主键” 的传递依赖。

------

#### 4. 第四范式（4NF）：消除多值依赖

##### 定义

满足 3NF + **消除非平凡的多值依赖**（即一个主键对应多个独立的多值字段，且字段之间无关联）。

👉 场景：一个实体有多个独立的 “多值属性”（如用户有多个收货地址、多个联系电话）。

##### 反例（满足 3NF，但不满足 4NF）





| 用户 ID |   收货地址   |  联系电话   |
| :-----: | :----------: | :---------: |
|    1    | 广州市天河区 | 13800138000 |
|    1    | 深圳市南山区 | 13800138000 |
|    1    | 广州市天河区 | 13900139000 |
|    1    | 深圳市南山区 | 13900139000 |

问题：

- 主键`用户ID`，对应 “多个收货地址” 和 “多个联系电话”，且地址和电话无关联；
- 数据爆炸式冗余：用户有 2 个地址 + 2 个电话，需存储 4 行，新增 1 个地址需新增 N 行（N = 电话数）。

##### 正例（满足 4NF）：拆分多值依赖字段

- **用户表（t_user）**：主键`用户ID`（仅存核心信息）








| 用户 ID | 用户名 |
  | :-----: | :----: |
|    1    |  张三  |



- **用户地址表（t_user_address）**：主键`(用户ID,地址ID)`






| 用户 ID | 地址 ID |   收货地址   |
  | :-----: | :-----: | :----------: |
|    1    |    1    | 广州市天河区 |
|    1    |    2    | 深圳市南山区 |



- **用户电话表（t_user_phone）**：主键`(用户ID,电话ID)`










| 用户 ID | 电话 ID |  联系电话   |
  | :-----: | :-----: | :---------: |
|    1    |    1    | 13800138000 |
|    1    |    2    | 13900139000 |



核心：每个多值属性单独成表，消除主键对多个独立多值字段的依赖。

------

#### 5. 第五范式（5NF / 投影连接范式）：消除连接依赖

##### 定义

满足 4NF + **表的所有连接依赖都由主键隐含决定**（即表拆分后，无需通过多表连接才能还原原始信息，且拆分后无冗余）。

👉 场景：多实体之间的 “多对多” 关系，且关系无法拆分为更简单的二元关系。

##### 反例（满足 4NF，但不满足 5NF）

场景：用户、商品、供应商的三方关系（一个用户购买的商品由特定供应商提供）。






| 用户 ID | 商品 ID | 供应商 ID |
| :-----: | :-----: | :-------: |
|    1    |    1    |     1     |
|    1    |    2    |     1     |
|    2    |    1    |     2     |
|    2    |    2    |     1     |

问题：

- 该表的信息无法拆分为 “用户 - 商品”“用户 - 供应商”“商品 - 供应商” 三个二元表（还原后会产生冗余）；
- 比如 “用户 1 - 商品 1 - 供应商 1”，拆分后 “用户 1 - 商品 1”“用户 1 - 供应商 1”“商品 1 - 供应商 1”，但 “商品 1 - 供应商 2” 可能不存在，连接后会产生错误数据。

##### 正例（满足 5NF）：拆分连接依赖为最小二元关系

- **用户 - 商品表（t_user_product）**：主键`(用户ID,商品ID)`









| 用户 ID | 商品 ID |
  | :-----: | :-----: |
|    1    |    1    |
|    1    |    2    |
|    2    |    1    |
|    2    |    2    |



- **商品 - 供应商表（t_product_supplier）**：主键`(商品ID,供应商ID)`








| 商品 ID | 供应商 ID |
  | :-----: | :-------: |
|    1    |     1     |
|    1    |     2     |
|    2    |     1     |



- **用户 - 商品 - 供应商表（t_user_product_supplier）**：仅存储 “有效组合”









| 用户 ID | 商品 ID | 供应商 ID |
  | :-----: | :-----: | :-------: |
|    1    |    1    |     1     |
|    1    |    2    |     1     |
|    2    |    1    |     2     |
|    2    |    2    |     1     |



核心：拆分后，所有有效关系都能通过 “最小二元表 + 组合表” 还原，无冗余和错误。

### 三、反范式化策略（何时打破范式？）

**反范式**：故意引入适量冗余，牺牲 “无冗余” 换取 “查询性能”—— 核心是 “权衡”，通常用于**读多写少**的场景（如电商订单查询、报表统计）。

#### 1. 常见反范式策略（附应用场景）

##### 策略 1：增加冗余字段

- 做法：在表中新增其他表的字段，避免多表连接。

- 例子：

    - 订单表中新增 “商品名称”（原本需关联商品表）；
    - 用户表中新增 “省份名称”（原本需关联省份表）。



- 适用场景：高频查询字段（如订单列表需显示商品名称，无需每次 join 商品表）。

- 注意：需保证冗余字段的一致性（可通过触发器、定时任务、应用层同步更新）。

##### 策略 2：合并表

- 做法：将多个满足高范式的小表合并为一个大表，减少连接次数。

- 例子：

    - 将 “订单表 + 订单明细表 + 商品表” 合并为 “订单宽表”，用于报表统计；
    - 将 “用户表 + 用户地址表 + 用户电话表” 合并为 “用户全量表”，用于用户信息查询。



- 适用场景：批量查询、报表生成（如电商后台的 “订单详情页”，需一次性展示所有信息）。

##### 策略 3：增加派生字段

- 做法：在表中新增 “计算后的值”（如求和、平均值），避免查询时实时计算。

- 例子：

    - 订单表中新增 “订单总金额”（原本需 sum (订单明细。金额)）；
    - 商品表中新增 “月销量”（原本需 count (订单明细。商品 ID)）。



- 适用场景：实时性要求低、计算成本高的字段（如月销量可定时更新，无需每次查询计算）。

##### 策略 4：分区表 / 分桶表

- 做法：按时间、地域等维度拆分大表，但在逻辑上保留冗余的 “全量字段”。

- 例子：

    - 订单表按 “年 + 月” 分区（2026_01、2026_02），每个分区都包含完整的订单字段；
    - 商品表按 “品类” 分桶，每个桶都包含商品名称、单价、库存等字段。



- 适用场景：超大型表（千万级以上），既减少单表数据量，又避免跨分区 join。

##### 策略 5：使用缓存 / 物化视图

- 做法：将多表连接的结果缓存为 “物化视图”（物理存储的视图），定期刷新。

- 例子：

    - 创建 “用户订单统计视图”（用户 ID + 订单数 + 总消费金额），物化后直接查询；
    - Redis 缓存 “商品详情 + 库存”，避免每次查询数据库。



- 适用场景：读远大于写、查询逻辑固定的场景。

#### 2. 反范式的注意事项

- 冗余可控：仅对高频查询字段做冗余，避免全表冗余；
- 一致性保障：通过**触发器**（数据库层）、**事务**（应用层）、**定时任务**（离线同步）保证冗余字段与源字段一致；
- 按需使用：核心交易表（如订单支付表）优先满足 3NF，避免更新异常；报表 / 查询表可反范式优化性能。

### 总结

#### 1. 五大范式核心

- 1NF：字段原子性（不可拆）；
- 2NF：消除部分依赖（非主键字段依赖整个主键）；
- 3NF：消除传递依赖（非主键字段仅依赖主键）；
- 4NF：消除多值依赖（一个主键不对应多个独立多值字段）；
- 5NF：消除连接依赖（表拆分后无冗余，可还原）。

#### 2. 反范式核心策略

- 冗余字段：减少 join，适用于高频查询；
- 合并表：减少连接次数，适用于报表统计；
- 派生字段：避免实时计算，适用于聚合查询；
- 物化视图 / 缓存：提升读性能，适用于读多写少场景。

#### 3. 设计原则

- 写优先的核心表（如订单、支付）：遵循 3NF，保证数据一致性；
- 读优先的查询表（如报表、详情页）：适度反范式，提升查询性能；
- 冗余≠混乱：反范式需有明确的一致性保障机制，避免数据脏读。