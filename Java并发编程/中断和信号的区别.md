### 一、`interrupt` 与 `signal` 的核心差别

两者本质上是不同层面的 “事件通知机制”，核心区别如下：

| 维度           | `interrupt`（中断）                                          | `signal`（信号）                                             |
| -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **触发源**     | 主要是硬件设备（如键盘、硬盘、网卡），少数是软件（如系统调用陷阱）。 | 主要是软件（进程间通过系统调用发送），或内核（检测到异常时）。 |
| **处理对象**   | 目标是 CPU，用于通知 CPU 暂停当前任务处理紧急事件。          | 目标是进程，用于通知进程发生了需要关注的事件（如异常、终止请求）。 |
| **作用层面**   | 底层硬件与 CPU / 内核的交互机制，属于 “硬件级” 或 “内核级”。 | 用户态进程间或内核与用户态进程的通信机制，属于 “软件级”。    |
| **处理流程**   | CPU 直接响应，暂停当前指令流，跳转至中断服务程序（ISR）。    | 由内核递送给目标进程，进程根据预设逻辑（忽略 / 默认处理 / 自定义函数）响应。 |
| **用途**       | 处理硬件紧急事件（如设备完成数据传输、错误），确保硬件与系统同步。 | 处理进程级事件（如终止请求、异常报错、用户输入），协调进程行为。 |
| **响应时效性** | 实时性高（硬件事件不可拖延，如硬盘数据不及时处理会丢失）。   | 实时性较低（信号可被延迟递送，进程可能在执行关键代码时暂时屏蔽信号）。 |

### 二、`interrupt`（中断）的发起者、接收者与操作系统的作用

`interrupt` 是硬件与 CPU 之间的 “紧急呼叫”，目的是让 CPU 暂停当前任务，优先处理硬件的需求。

#### 1. 发起者

- 硬件设备 ：绝大多数中断由硬件发起。例如：

    - 键盘按下时，键盘控制器向 CPU 发送中断，请求处理按键数据；
    - 硬盘完成数据读写后，硬盘控制器发送中断，通知 CPU 读取结果；
    - 网卡收到网络数据包时，发送中断，请求 CPU 处理数据。

- 软件触发 ：少数情况由软件发起（称为 “软中断” 或 “陷阱”），例如：

    - 进程执行系统调用（如 `read()`）时，会主动触发一个软中断，让 CPU 从用户态切换到内核态执行内核代码；
    - 程序执行非法指令（如除零）时，CPU 会自动触发一个软中断（陷阱），通知内核处理异常。

#### 2. 接收者

`interrupt` 的接收者是 **CPU**。中断信号直接发送到 CPU 的中断引脚（硬件中断）或通过指令触发（软中断），强制 CPU 暂停当前执行的指令流。

#### 3. 操作系统在 `interrupt` 中的作用

操作系统是中断的 “管理者”，核心作用包括：

- **维护中断向量表**：中断向量表是一个存储 “中断号→中断服务程序（ISR）入口地址” 的映射表。每个硬件设备的中断都对应一个唯一的中断号，操作系统负责将该中断号与处理该设备的 ISR 绑定（如硬盘中断对应硬盘数据读取的 ISR）。
- **处理中断上下文**：当 CPU 收到中断后，操作系统会保存当前 CPU 寄存器状态（上下文），确保中断处理完成后能恢复原任务；然后跳转到中断向量表中对应的 ISR 执行。
- **管理中断优先级**：操作系统会为不同中断分配优先级（如硬盘中断优先级高于键盘），避免低优先级中断打断高优先级中断的处理，确保系统稳定。
- **屏蔽与恢复中断**：在执行关键代码（如内核数据结构修改）时，操作系统会暂时屏蔽中断，防止中断干扰导致数据不一致；完成后再恢复中断响应。

### 三、`signal`（信号）的发起者、接收者与操作系统的作用

`signal` 是软件层面的 “事件通知”，用于进程间或内核与进程间传递信息，告知进程发生了特定事件。

#### 1. 发起者

`signal` 的发起者主要有两类：

- **其他进程**：进程可通过系统调用（如 `kill()`、`pthread_kill()`）向目标进程发送信号。例如，进程 A 调用 `kill(pid, SIGKILL)` 可强制进程 B 终止。

- 内核 ：当内核检测到与进程相关的异常或事件时，会主动向进程发送信号。例如：

    - 进程执行除零操作时，内核发送 `SIGFPE` 信号；
    - 进程访问非法内存（段错误）时，内核发送 `SIGSEGV` 信号；
    - 用户按下 `Ctrl+C` 时，内核向前台进程发送 `SIGINT` 信号（终止请求）。

#### 2. 接收者

`signal` 的接收者是 **特定进程**（或线程）。每个信号都有明确的目标进程（通过进程 ID 指定），只有目标进程会响应该信号。

#### 3. 操作系统在 `signal` 中的作用

操作系统是信号的 “递送者” 和 “协调者”，核心作用包括：

- **信号的存储与递送**：当信号被发送后，内核会先将其存储在目标进程的 “信号队列” 中（标记为 “未决”），待进程从内核态返回用户态时，内核会将信号递送给进程。
- **管理信号处理逻辑**：每个信号都有默认处理行为（如 `SIGKILL` 默认终止进程，`SIGINT` 默认终止进程），进程可通过 `signal()` 或 `sigaction()` 注册自定义处理函数（覆盖默认行为），操作系统负责执行这些逻辑。
- **信号屏蔽与优先级**：进程可通过 `sigprocmask()` 屏蔽某些信号（暂时不处理），操作系统会记录被屏蔽的信号，待屏蔽解除后再递送；同时，内核会处理信号的优先级（如 `SIGKILL` 无法被屏蔽或忽略）。

### 总结

- `interrupt` 是硬件（或软件陷阱）向 CPU 发送的 “紧急请求”，由操作系统通过中断服务程序处理，确保硬件与系统的实时交互；
- `signal` 是软件（进程或内核）向目标进程发送的 “事件通知”，由操作系统协调递送，用于进程间通信或异常处理。

两者的核心差异在于：中断是底层硬件 - CPU 交互，信号是上层软件 - 进程交互，操作系统在两者中分别扮演 “中断管理者” 和 “信号递送者” 的角色。