在偏向锁的对象头中，`epoch`字段是**Java 虚拟机（HotSpot）用于批量撤销偏向锁、优化锁重偏向效率**的关键标记，主要解决 “大量偏向锁因安全点操作（如 GC）集体失效后，重新偏向的性能问题”。

### 1. 先明确：偏向锁的对象头结构与`epoch`的位置



偏向锁是 Java 为 “无竞争场景” 设计的轻量级锁，对象头的`Mark Word`中会存储**偏向的线程 ID（Thread ID）**，表示该对象 “偏向” 于该线程，后续该线程再次获取锁时无需 CAS 操作，直接成功。

`epoch`字段是`Mark Word`中专门为偏向锁设计的一个**整数标记位**（通常占 2 位或更多，具体取决于 JVM 实现），与偏向线程 ID 共存于对象头中，用于标记对象偏向锁的 “有效性周期”。

### 2. `epoch`字段的核心作用：批量管理偏向锁的有效性



#### （1）问题背景：偏向锁的 “批量撤销” 与性能痛点



当偏向锁遇到竞争（如其他线程尝试获取该锁），或在安全点（如 GC）时，JVM 可能会**批量撤销一批对象的偏向锁**（将其转为无锁或轻量级锁）。但如果后续这些对象又进入 “无竞争” 状态，需要重新偏向线程，若逐个处理每个对象的偏向锁，会产生大量 CAS 操作，效率极低。

`epoch`字段的设计正是为了**避免逐个处理对象，通过 “周期标记” 实现批量重偏向**。

#### （2）`epoch`的工作原理：“有效性周期” 标记



- **每个锁对象的`epoch`**：记录该对象当前偏向锁所属的 “有效性周期”（初始值与所在类的`epoch`一致）。
- **每个类的`epoch`**：JVM 为每个类维护一个全局`epoch`（存在于类元数据中），表示 “当前有效的偏向周期”。

当发生**批量撤销偏向锁**时，JVM 会：

1. 将该类的全局`epoch`值**加 1**（进入新的周期）；
2. 不修改现有对象的`epoch`值（这些对象的`epoch`仍为旧周期）。

此时，所有旧周期的对象（`epoch` < 类的当前`epoch`）的偏向锁被视为 “无效”，但对象头的线程 ID 并未被清除（避免逐个修改的开销）。

#### （3）实现 “批量重偏向”：高效复用偏向锁



当线程再次尝试获取 “旧周期对象” 的锁时：

- 检查对象`epoch`与类的当前`epoch`：若对象`epoch`更小（属于旧周期），说明该对象的偏向锁已无效。
- 此时无需重新 CAS 修改对象头的线程 ID，只需将对象的`epoch`更新为类的当前`epoch`，即可完成 “重偏向”（相当于将对象纳入新的有效周期），后续该线程再次获取锁时直接生效。

这一过程避免了对每个对象的偏向锁进行逐个撤销和重建，通过`epoch`的周期标记实现了**批量处理**，大幅提升了重偏向的效率。

### 3. 总结：`epoch`的核心价值



偏向锁中的`epoch`字段是一种 “**轻量级的批量管理机制**”，通过标记偏向锁的 “有效性周期”，解决了两个关键问题：

1. **批量撤销的低成本**：无需逐个修改对象头，只需更新类的`epoch`即可标记一批对象的偏向锁无效；
2. **高效重偏向**：线程可通过更新对象`epoch`快速将其纳入新周期，复用偏向锁的无竞争优化。

这使得 JVM 在处理大量偏向锁的场景（如创建大量对象且无竞争）时，既能保证锁的轻量性，又能应对批量失效后的高效恢复。