JWT Token、Session、Cookie 是 Web 开发中处理**用户身份认证**的核心技术，三者定位不同、底层逻辑差异显著，先上核心结论：

- **Cookie**：客户端（浏览器）存储的小型文本文件，是「传输载体」，用于在客户端和服务端之间传递数据；
- **Session**：服务端存储的用户会话数据，是「状态存储」，依赖 Cookie 传递 SessionID 实现身份关联；
- **JWT Token**：加密的字符串令牌，是「自包含凭证」，可在客户端存储（Cookie / 本地存储），无需服务端存储会话状态。

下面从**定义、工作原理、核心区别、优缺点、适用场景**五个维度拆解：

### 一、核心定义与工作原理

#### 1. Cookie

- **定义**：由服务器响应头（`Set-Cookie`）下发给浏览器，浏览器保存在本地的键值对文本（大小限制～4KB），后续请求会自动携带该域名下的 Cookie 到服务器。

- **核心作用**：作为「客户端 - 服务端」的状态传递载体，最典型的用途是携带 SessionID。

- 工作流程 ：

    1. 客户端首次请求服务器，服务器生成 Cookie（如 `JSESSIONID=xxx`），通过 `Set-Cookie` 响应头返回；
    2. 浏览器将 Cookie 存储到本地（按域名隔离）；
    3. 客户端后续请求该域名时，自动在请求头（`Cookie`）中携带该 Cookie；
    4. 服务器读取 Cookie 中的数据（如 SessionID），识别用户身份。

#### 2. Session

- **定义**：服务端为每个用户会话创建的「内存 / 数据库存储对象」，存储用户登录状态、权限等信息，通过 SessionID 关联到具体用户。

- **核心作用**：服务端侧的「状态管理」，解决 HTTP 无状态问题。

- 工作流程 （依赖 Cookie）：

    1. 用户登录成功，服务器创建 Session 对象（存储用户 ID、昵称等），生成唯一 SessionID；
    2. 服务器通过 `Set-Cookie: JSESSIONID=xxx` 将 SessionID 下发给浏览器；
    3. 浏览器后续请求携带 `JSESSIONID`，服务器通过 SessionID 从内存 / Redis 中查询对应的 Session 对象；
    4. 用户登出 / 会话超时，服务器删除 Session 对象。

#### 3. JWT Token

- **定义**：JSON Web Token，将用户信息加密为「三段式字符串」（Header.Payload.Signature），是「自包含」的身份凭证（Payload 中可存储用户基础信息）。

- **核心作用**：无状态的身份认证，无需服务端存储会话数据。

- 工作流程 ：

    1. 用户登录成功，服务器根据用户信息（ID、权限）生成 JWT Token（Header 声明加密算法，Payload 存储用户信息，Signature 签名防篡改）；
    2. 服务器将 Token 返回给客户端，客户端存储在 Cookie/localStorage/sessionStorage；
    3. 客户端后续请求通过请求头（`Authorization: Bearer `）或 Cookie 携带 Token；
    4. 服务器接收 Token 后，验证签名是否合法、是否过期，解析 Payload 中的用户信息，完成身份认证。

### 二、核心区别对比表

| 维度       | Cookie                                          | Session                                               | JWT Token                                                    |
| ---------- | ----------------------------------------------- | ----------------------------------------------------- | ------------------------------------------------------------ |
| 存储位置   | 客户端（浏览器）                                | 服务端（内存 / Redis / 数据库）                       | 客户端（Cookie / 本地存储）                                  |
| 存储内容   | 键值对文本（如 SessionID、token）               | 用户会话数据（ID、权限、状态）                        | 加密的 JSON 数据（用户信息、过期时间）                       |
| 状态特性   | 无状态（仅传递数据）                            | 有状态（服务端维护会话）                              | 无状态（服务端无需存储）                                     |
| 数据大小   | 限制～4KB                                       | 无明确限制（受服务端内存影响）                        | 无严格限制（建议 <1KB，避免请求头过大）                      |
| 传递方式   | 自动携带在 HTTP 请求头（Cookie）                | 依赖 Cookie 传递 SessionID                            | 手动携带（请求头 / Cookie/ 请求体）                          |
| 安全性     | 易被 XSS/CSRF 攻击（需配置 HttpOnly、SameSite） | 相对安全（数据在服务端），但 SessionID 泄露会导致冒充 | 签名防篡改，但 Payload 可解码（勿存敏感信息），Token 泄露则身份被盗 |
| 过期控制   | 可设置 `Expires/Max-Age` 过期                   | 服务端主动设置超时时间（如 30 分钟）                  | Payload 中内置过期时间（exp），服务端校验                    |
| 分布式适配 | 无（仅传递数据）                                | 需分布式存储（如 Redis），否则多实例无法共享          | 天然适配（服务端无需存储，直接校验）                         |
| 跨域支持   | 受同源策略限制（需配置 CORS + SameSite=None）   | 依赖 Cookie，跨域需特殊配置                           | 易跨域（通过请求头携带，无需 Cookie）                        |

### 三、优缺点分析

#### 1. Cookie

- ✅ 优点：自动携带，使用简单；支持过期、域名、路径限制，可控性强；
- ❌ 缺点：大小限制；易受 XSS（窃取 Cookie）、CSRF（利用 Cookie 冒充请求）攻击；跨域配置复杂。

#### 2. Session

- ✅ 优点：数据存储在服务端，安全性高；支持灵活的会话控制（主动踢人、修改权限）；
- ❌ 缺点：服务端存储开销大，高并发需分布式存储（Redis）；依赖 Cookie，跨域 / 移动端（如 App）适配差；SessionID 泄露会导致会话劫持。

#### 3. JWT Token

- ✅ 优点：无状态，服务端无需存储，分布式 / 微服务场景友好；跨域 / 跨端（App / 小程序）适配简单；Payload 可携带基础信息，减少数据库查询；
- ❌ 缺点：Token 一旦签发无法主动作废（需配合黑名单 / 刷新令牌解决）；Payload 未加密（仅 base64 编码），不能存密码等敏感信息；Token 过长会增加请求开销。

### 四、适用场景

| 技术      | 最佳适用场景                                                 | 不适用场景                                       |
| --------- | ------------------------------------------------------------ | ------------------------------------------------ |
| Cookie    | 存储非敏感的客户端状态（如语言偏好、主题）；传递 SessionID/JWT | 存储敏感信息；跨域高频请求                       |
| Session   | 中小型单体应用；需严格控制会话（如后台管理系统）；对安全性要求极高 | 分布式 / 微服务架构；跨端（App）应用             |
| JWT Token | 分布式 / 微服务架构；跨域 / 跨端（App / 小程序）应用；临时授权（如第三方登录） | 需主动作废令牌的场景（如账号冻结）；存储敏感信息 |

### 五、典型组合使用方式

1. **Session + Cookie**（传统单体应用）：
    - 服务器生成 SessionID，通过 HttpOnly、Secure 的 Cookie 下发；
    - 浏览器携带 Cookie 中的 SessionID，服务器查询 Session 验证身份；
    - 配置 `HttpOnly` 防 XSS，`SameSite=Strict` 防 CSRF。
2. **JWT Token + 本地存储 + 请求头**（前后端分离 / 微服务）：
    - 登录成功后，服务器返回 JWT Token，客户端存储在 localStorage；
    - 后续请求通过 `Authorization: Bearer ` 携带 Token；
    - 配合「刷新令牌（Refresh Token）」解决 Token 过期问题，配合 Redis 黑名单解决 Token 主动作废问题。
3. **JWT Token + HttpOnly Cookie**（兼顾安全与无状态）：
    - 将 JWT Token 存储在 HttpOnly、Secure 的 Cookie 中，避免 XSS 攻击；
    - 服务器校验 Token 时无需依赖 Session，同时利用 Cookie 的安全配置降低风险。

### 总结

- Cookie 是「载体」，不是认证方式，Session 和 JWT 都可基于 Cookie 传递；
- Session 是「服务端状态」，适合单体、高安全场景；
- JWT 是「客户端自包含凭证」，适合分布式、跨端场景；
- 实际开发中，很少单独使用某一种，而是组合使用（如 Session + Cookie、JWT + 刷新令牌 + Cookie），平衡安全性、易用性和性能。
